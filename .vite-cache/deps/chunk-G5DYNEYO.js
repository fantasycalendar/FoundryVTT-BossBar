import {
  require_browserslist,
  require_fs,
  require_lib,
  require_postcss,
  require_unpacker
} from "./chunk-3THRRXLU.js";
import {
  require_path,
  require_url
} from "./chunk-42OO5JCR.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/yaml/browser/dist/PlainValue-b8036b75.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property2, receiver2) {
      var base = _superPropBase(target2, property2);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property2);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property, receiver || target);
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i2) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function(e2) {
          throw e2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = o2[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e2) {
      didErr = true;
      err = e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function findLineStarts(src) {
  var ls = [0];
  var offset = src.indexOf("\n");
  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf("\n", offset);
  }
  return ls;
}
function getSrcInfo(cst) {
  var lineStarts, src;
  if (typeof cst === "string") {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst))
      cst = cst[0];
    if (cst && cst.context) {
      if (!cst.lineStarts)
        cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }
  return {
    lineStarts,
    src
  };
}
function getLinePos(offset, cst) {
  if (typeof offset !== "number" || offset < 0)
    return null;
  var _getSrcInfo = getSrcInfo(cst), lineStarts = _getSrcInfo.lineStarts, src = _getSrcInfo.src;
  if (!lineStarts || !src || offset > src.length)
    return null;
  for (var i2 = 0; i2 < lineStarts.length; ++i2) {
    var start = lineStarts[i2];
    if (offset < start) {
      return {
        line: i2,
        col: offset - lineStarts[i2 - 1] + 1
      };
    }
    if (offset === start)
      return {
        line: i2 + 1,
        col: 1
      };
  }
  var line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
function getLine(line, cst) {
  var _getSrcInfo2 = getSrcInfo(cst), lineStarts = _getSrcInfo2.lineStarts, src = _getSrcInfo2.src;
  if (!lineStarts || !(line >= 1) || line > lineStarts.length)
    return null;
  var start = lineStarts[line - 1];
  var end = lineStarts[line];
  while (end && end > start && src[end - 1] === "\n") {
    --end;
  }
  return src.slice(start, end);
}
function getPrettyContext(_ref, cst) {
  var start = _ref.start, end = _ref.end;
  var maxWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80;
  var src = getLine(start.line, cst);
  if (!src)
    return null;
  var col = start.col;
  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + "\u2026";
    } else {
      var halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth)
        src = src.substr(0, col + halfWidth - 1) + "\u2026";
      col -= src.length - maxWidth;
      src = "\u2026" + src.substr(1 - maxWidth);
    }
  }
  var errLen = 1;
  var errEnd = "";
  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = "\u2026";
    }
  }
  var offset = col > 1 ? " ".repeat(col - 1) : "";
  var err = "^".repeat(errLen);
  return "".concat(src, "\n").concat(offset).concat(err).concat(errEnd);
}
var Char, Type, defaultTagPrefix, defaultTags, Range, Node, YAMLError, YAMLReferenceError, YAMLSemanticError, YAMLSyntaxError, YAMLWarning, PlainValue;
var init_PlainValue_b8036b75 = __esm({
  "node_modules/yaml/browser/dist/PlainValue-b8036b75.js"() {
    Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    defaultTagPrefix = "tag:yaml.org,2002:";
    defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    Range = function() {
      function Range2(start, end) {
        _classCallCheck(this, Range2);
        this.start = start;
        this.end = end || start;
      }
      _createClass(Range2, [{
        key: "isEmpty",
        value: function isEmpty() {
          return typeof this.start !== "number" || !this.end || this.end <= this.start;
        }
      }, {
        key: "setOrigRange",
        value: function setOrigRange(cr, offset) {
          var start = this.start, end = this.end;
          if (cr.length === 0 || end <= cr[0]) {
            this.origStart = start;
            this.origEnd = end;
            return offset;
          }
          var i2 = offset;
          while (i2 < cr.length) {
            if (cr[i2] > start)
              break;
            else
              ++i2;
          }
          this.origStart = start + i2;
          var nextOffset = i2;
          while (i2 < cr.length) {
            if (cr[i2] >= end)
              break;
            else
              ++i2;
          }
          this.origEnd = end + i2;
          return nextOffset;
        }
      }], [{
        key: "copy",
        value: function copy(orig) {
          return new Range2(orig.start, orig.end);
        }
      }]);
      return Range2;
    }();
    Node = function() {
      function Node4(type, props, context) {
        _classCallCheck(this, Node4);
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      _createClass(Node4, [{
        key: "getPropValue",
        value: function getPropValue(idx, key, skipKey) {
          if (!this.context)
            return null;
          var src = this.context.src;
          var prop = this.props[idx];
          return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
        }
      }, {
        key: "anchor",
        get: function get() {
          for (var i2 = 0; i2 < this.props.length; ++i2) {
            var anchor = this.getPropValue(i2, Char.ANCHOR, true);
            if (anchor != null)
              return anchor;
          }
          return null;
        }
      }, {
        key: "comment",
        get: function get() {
          var comments = [];
          for (var i2 = 0; i2 < this.props.length; ++i2) {
            var comment = this.getPropValue(i2, Char.COMMENT, true);
            if (comment != null)
              comments.push(comment);
          }
          return comments.length > 0 ? comments.join("\n") : null;
        }
      }, {
        key: "commentHasRequiredWhitespace",
        value: function commentHasRequiredWhitespace(start) {
          var src = this.context.src;
          if (this.header && start === this.header.end)
            return false;
          if (!this.valueRange)
            return false;
          var end = this.valueRange.end;
          return start !== end || Node4.atBlank(src, end - 1);
        }
      }, {
        key: "hasComment",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i2 = 0; i2 < this.props.length; ++i2) {
              if (src[this.props[i2].start] === Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "hasProps",
        get: function get() {
          if (this.context) {
            var src = this.context.src;
            for (var i2 = 0; i2 < this.props.length; ++i2) {
              if (src[this.props[i2].start] !== Char.COMMENT)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "includesTrailingLines",
        get: function get() {
          return false;
        }
      }, {
        key: "jsonLike",
        get: function get() {
          var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
          return jsonLikeTypes.indexOf(this.type) !== -1;
        }
      }, {
        key: "rangeAsLinePos",
        get: function get() {
          if (!this.range || !this.context)
            return void 0;
          var start = getLinePos(this.range.start, this.context.root);
          if (!start)
            return void 0;
          var end = getLinePos(this.range.end, this.context.root);
          return {
            start,
            end
          };
        }
      }, {
        key: "rawValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          return this.context.src.slice(start, end);
        }
      }, {
        key: "tag",
        get: function get() {
          for (var i2 = 0; i2 < this.props.length; ++i2) {
            var tag = this.getPropValue(i2, Char.TAG, false);
            if (tag != null) {
              if (tag[1] === "<") {
                return {
                  verbatim: tag.slice(2, -1)
                };
              } else {
                var _tag$match = tag.match(/^(.*!)([^!]*)$/), _tag$match2 = _slicedToArray(_tag$match, 3);
                _tag$match2[0];
                var handle = _tag$match2[1], suffix = _tag$match2[2];
                return {
                  handle,
                  suffix
                };
              }
            }
          }
          return null;
        }
      }, {
        key: "valueRangeContainsNewline",
        get: function get() {
          if (!this.valueRange || !this.context)
            return false;
          var _this$valueRange2 = this.valueRange, start = _this$valueRange2.start, end = _this$valueRange2.end;
          var src = this.context.src;
          for (var i2 = start; i2 < end; ++i2) {
            if (src[i2] === "\n")
              return true;
          }
          return false;
        }
      }, {
        key: "parseComment",
        value: function parseComment(start) {
          var src = this.context.src;
          if (src[start] === Char.COMMENT) {
            var end = Node4.endOfLine(src, start + 1);
            var commentRange = new Range(start, end);
            this.props.push(commentRange);
            return end;
          }
          return start;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          if (this.range)
            offset = this.range.setOrigRange(cr, offset);
          if (this.valueRange)
            this.valueRange.setOrigRange(cr, offset);
          this.props.forEach(function(prop) {
            return prop.setOrigRange(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = src.slice(range.start, range.end);
          return Node4.addStringTerminator(src, range.end, str);
        }
      }], [{
        key: "addStringTerminator",
        value: function addStringTerminator(src, offset, str) {
          if (str[str.length - 1] === "\n")
            return str;
          var next = Node4.endOfWhiteSpace(src, offset);
          return next >= src.length || src[next] === "\n" ? str + "\n" : str;
        }
      }, {
        key: "atDocumentBoundary",
        value: function atDocumentBoundary(src, offset, sep) {
          var ch0 = src[offset];
          if (!ch0)
            return true;
          var prev = src[offset - 1];
          if (prev && prev !== "\n")
            return false;
          if (sep) {
            if (ch0 !== sep)
              return false;
          } else {
            if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
              return false;
          }
          var ch1 = src[offset + 1];
          var ch2 = src[offset + 2];
          if (ch1 !== ch0 || ch2 !== ch0)
            return false;
          var ch3 = src[offset + 3];
          return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
        }
      }, {
        key: "endOfIdentifier",
        value: function endOfIdentifier(src, offset) {
          var ch = src[offset];
          var isVerbatim = ch === "<";
          var notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
          while (ch && notOk.indexOf(ch) === -1) {
            ch = src[offset += 1];
          }
          if (isVerbatim && ch === ">")
            offset += 1;
          return offset;
        }
      }, {
        key: "endOfIndent",
        value: function endOfIndent(src, offset) {
          var ch = src[offset];
          while (ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfLine",
        value: function endOfLine(src, offset) {
          var ch = src[offset];
          while (ch && ch !== "\n") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "endOfWhiteSpace",
        value: function endOfWhiteSpace(src, offset) {
          var ch = src[offset];
          while (ch === "	" || ch === " ") {
            ch = src[offset += 1];
          }
          return offset;
        }
      }, {
        key: "startOfLine",
        value: function startOfLine(src, offset) {
          var ch = src[offset - 1];
          if (ch === "\n")
            return offset;
          while (ch && ch !== "\n") {
            ch = src[offset -= 1];
          }
          return offset + 1;
        }
      }, {
        key: "endOfBlockIndent",
        value: function endOfBlockIndent(src, indent, lineStart) {
          var inEnd = Node4.endOfIndent(src, lineStart);
          if (inEnd > lineStart + indent) {
            return inEnd;
          } else {
            var wsEnd = Node4.endOfWhiteSpace(src, inEnd);
            var ch = src[wsEnd];
            if (!ch || ch === "\n")
              return wsEnd;
          }
          return null;
        }
      }, {
        key: "atBlank",
        value: function atBlank(src, offset, endAsBlank) {
          var ch = src[offset];
          return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
        }
      }, {
        key: "nextNodeIsIndented",
        value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
          if (!ch || indentDiff < 0)
            return false;
          if (indentDiff > 0)
            return true;
          return indicatorAsIndent && ch === "-";
        }
      }, {
        key: "normalizeOffset",
        value: function normalizeOffset(src, offset) {
          var ch = src[offset];
          return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node4.endOfWhiteSpace(src, offset);
        }
      }, {
        key: "foldNewline",
        value: function foldNewline(src, offset, indent) {
          var inCount = 0;
          var error = false;
          var fold = "";
          var ch = src[offset + 1];
          while (ch === " " || ch === "	" || ch === "\n") {
            switch (ch) {
              case "\n":
                inCount = 0;
                offset += 1;
                fold += "\n";
                break;
              case "	":
                if (inCount <= indent)
                  error = true;
                offset = Node4.endOfWhiteSpace(src, offset + 2) - 1;
                break;
              case " ":
                inCount += 1;
                offset += 1;
                break;
            }
            ch = src[offset + 1];
          }
          if (!fold)
            fold = " ";
          if (ch && inCount <= indent)
            error = true;
          return {
            fold,
            offset,
            error
          };
        }
      }]);
      return Node4;
    }();
    YAMLError = function(_Error) {
      _inherits(YAMLError2, _Error);
      var _super = _createSuper(YAMLError2);
      function YAMLError2(name, source, message) {
        var _this;
        _classCallCheck(this, YAMLError2);
        if (!message || !(source instanceof Node))
          throw new Error("Invalid arguments for new ".concat(name));
        _this = _super.call(this);
        _this.name = name;
        _this.message = message;
        _this.source = source;
        return _this;
      }
      _createClass(YAMLError2, [{
        key: "makePretty",
        value: function makePretty() {
          if (!this.source)
            return;
          this.nodeType = this.source.type;
          var cst = this.source.context && this.source.context.root;
          if (typeof this.offset === "number") {
            this.range = new Range(this.offset, this.offset + 1);
            var start = cst && getLinePos(this.offset, cst);
            if (start) {
              var end = {
                line: start.line,
                col: start.col + 1
              };
              this.linePos = {
                start,
                end
              };
            }
            delete this.offset;
          } else {
            this.range = this.source.range;
            this.linePos = this.source.rangeAsLinePos;
          }
          if (this.linePos) {
            var _this$linePos$start = this.linePos.start, line = _this$linePos$start.line, col = _this$linePos$start.col;
            this.message += " at line ".concat(line, ", column ").concat(col);
            var ctx = cst && getPrettyContext(this.linePos, cst);
            if (ctx)
              this.message += ":\n\n".concat(ctx, "\n");
          }
          delete this.source;
        }
      }]);
      return YAMLError2;
    }(_wrapNativeSuper(Error));
    YAMLReferenceError = function(_YAMLError) {
      _inherits(YAMLReferenceError2, _YAMLError);
      var _super2 = _createSuper(YAMLReferenceError2);
      function YAMLReferenceError2(source, message) {
        _classCallCheck(this, YAMLReferenceError2);
        return _super2.call(this, "YAMLReferenceError", source, message);
      }
      return YAMLReferenceError2;
    }(YAMLError);
    YAMLSemanticError = function(_YAMLError2) {
      _inherits(YAMLSemanticError2, _YAMLError2);
      var _super3 = _createSuper(YAMLSemanticError2);
      function YAMLSemanticError2(source, message) {
        _classCallCheck(this, YAMLSemanticError2);
        return _super3.call(this, "YAMLSemanticError", source, message);
      }
      return YAMLSemanticError2;
    }(YAMLError);
    YAMLSyntaxError = function(_YAMLError3) {
      _inherits(YAMLSyntaxError2, _YAMLError3);
      var _super4 = _createSuper(YAMLSyntaxError2);
      function YAMLSyntaxError2(source, message) {
        _classCallCheck(this, YAMLSyntaxError2);
        return _super4.call(this, "YAMLSyntaxError", source, message);
      }
      return YAMLSyntaxError2;
    }(YAMLError);
    YAMLWarning = function(_YAMLError4) {
      _inherits(YAMLWarning2, _YAMLError4);
      var _super5 = _createSuper(YAMLWarning2);
      function YAMLWarning2(source, message) {
        _classCallCheck(this, YAMLWarning2);
        return _super5.call(this, "YAMLWarning", source, message);
      }
      return YAMLWarning2;
    }(YAMLError);
    PlainValue = function(_Node) {
      _inherits(PlainValue2, _Node);
      var _super = _createSuper(PlainValue2);
      function PlainValue2() {
        _classCallCheck(this, PlainValue2);
        return _super.apply(this, arguments);
      }
      _createClass(PlainValue2, [{
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var src = this.context.src;
          var ch = src[end - 1];
          while (start < end && (ch === "\n" || ch === "	" || ch === " ")) {
            ch = src[--end - 1];
          }
          var str = "";
          for (var i2 = start; i2 < end; ++i2) {
            var _ch = src[i2];
            if (_ch === "\n") {
              var _Node$foldNewline = Node.foldNewline(src, i2, -1), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset;
              str += fold;
              i2 = offset;
            } else if (_ch === " " || _ch === "	") {
              var wsStart = i2;
              var next = src[i2 + 1];
              while (i2 < end && (next === " " || next === "	")) {
                i2 += 1;
                next = src[i2 + 1];
              }
              if (next !== "\n")
                str += i2 > wsStart ? src.slice(wsStart, i2 + 1) : _ch;
            } else {
              str += _ch;
            }
          }
          var ch0 = src[start];
          switch (ch0) {
            case "	": {
              var msg = "Plain value cannot start with a tab character";
              var errors = [new YAMLSemanticError(this, msg)];
              return {
                errors,
                str
              };
            }
            case "@":
            case "`": {
              var _msg = "Plain value cannot start with reserved character ".concat(ch0);
              var _errors = [new YAMLSemanticError(this, _msg)];
              return {
                errors: _errors,
                str
              };
            }
            default:
              return str;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context = this.context, indent = _this$context.indent, inFlow = _this$context.inFlow, src = _this$context.src;
          var offset = start;
          var valueEnd = start;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            if (Node.atDocumentBoundary(src, offset + 1))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset + 1);
            if (end === null || src[end] === "#")
              break;
            if (src[end] === "\n") {
              offset = end;
            } else {
              valueEnd = PlainValue2.endOfLine(src, end, inFlow);
              offset = valueEnd;
            }
          }
          if (this.valueRange.isEmpty())
            this.valueRange.start = start;
          this.valueRange.end = valueEnd;
          return valueEnd;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var inFlow = context.inFlow, src = context.src;
          var offset = start;
          var ch = src[offset];
          if (ch && ch !== "#" && ch !== "\n") {
            offset = PlainValue2.endOfLine(src, start, inFlow);
          }
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          if (!this.hasComment || this.valueRange.isEmpty()) {
            offset = this.parseBlockValue(offset);
          }
          return offset;
        }
      }], [{
        key: "endOfLine",
        value: function endOfLine(src, start, inFlow) {
          var ch = src[start];
          var offset = start;
          while (ch && ch !== "\n") {
            if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
              break;
            var next = src[offset + 1];
            if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
              break;
            if ((ch === " " || ch === "	") && next === "#")
              break;
            offset += 1;
            ch = next;
          }
          return offset;
        }
      }]);
      return PlainValue2;
    }(Node);
  }
});

// node_modules/yaml/browser/dist/parse-cst.js
function grabCollectionEndComments(node) {
  var cnode = node;
  while (cnode instanceof CollectionItem) {
    cnode = cnode.node;
  }
  if (!(cnode instanceof Collection))
    return null;
  var len = cnode.items.length;
  var ci = -1;
  for (var i2 = len - 1; i2 >= 0; --i2) {
    var n2 = cnode.items[i2];
    if (n2.type === Type.COMMENT) {
      var _n$context = n2.context, indent = _n$context.indent, lineStart = _n$context.lineStart;
      if (indent > 0 && n2.range.start >= lineStart + indent)
        break;
      ci = i2;
    } else if (n2.type === Type.BLANK_LINE)
      ci = i2;
    else
      break;
  }
  if (ci === -1)
    return null;
  var ca = cnode.items.splice(ci, len - ci);
  var prevEnd = ca[0].range.start;
  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd)
      cnode.valueRange.end = prevEnd;
    if (cnode === node)
      break;
    cnode = cnode.context.parent;
  }
  return ca;
}
function createNewNode(type, props) {
  switch (type) {
    case Type.ALIAS:
      return new Alias(type, props);
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
      return new BlockValue(type, props);
    case Type.FLOW_MAP:
    case Type.FLOW_SEQ:
      return new FlowCollection(type, props);
    case Type.MAP_KEY:
    case Type.MAP_VALUE:
    case Type.SEQ_ITEM:
      return new CollectionItem(type, props);
    case Type.COMMENT:
    case Type.PLAIN:
      return new PlainValue(type, props);
    case Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);
    case Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);
    default:
      return null;
  }
}
function parse(src) {
  var cr = [];
  if (src.indexOf("\r") !== -1) {
    src = src.replace(/\r\n?/g, function(match, offset2) {
      if (match.length > 1)
        cr.push(offset2);
      return "\n";
    });
  }
  var documents = [];
  var offset = 0;
  do {
    var doc = new Document();
    var context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);
  documents.setOrigRanges = function() {
    if (cr.length === 0)
      return false;
    for (var i2 = 1; i2 < cr.length; ++i2) {
      cr[i2] -= i2;
    }
    var crOffset = 0;
    for (var _i = 0; _i < documents.length; ++_i) {
      crOffset = documents[_i].setOrigRanges(cr, crOffset);
    }
    cr.splice(0, cr.length);
    return true;
  };
  documents.toString = function() {
    return documents.join("...\n");
  };
  return documents;
}
var BlankLine, CollectionItem, Comment, Collection, Directive, Document, Alias, Chomp, BlockValue, FlowCollection, QuoteDouble, QuoteSingle, ParseContext;
var init_parse_cst = __esm({
  "node_modules/yaml/browser/dist/parse-cst.js"() {
    init_PlainValue_b8036b75();
    BlankLine = function(_Node) {
      _inherits(BlankLine2, _Node);
      var _super = _createSuper(BlankLine2);
      function BlankLine2() {
        _classCallCheck(this, BlankLine2);
        return _super.call(this, Type.BLANK_LINE);
      }
      _createClass(BlankLine2, [{
        key: "includesTrailingLines",
        get: function get() {
          return true;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          this.range = new Range(start, start + 1);
          return start + 1;
        }
      }]);
      return BlankLine2;
    }(Node);
    CollectionItem = function(_Node) {
      _inherits(CollectionItem2, _Node);
      var _super = _createSuper(CollectionItem2);
      function CollectionItem2(type, props) {
        var _this;
        _classCallCheck(this, CollectionItem2);
        _this = _super.call(this, type, props);
        _this.node = null;
        return _this;
      }
      _createClass(CollectionItem2, [{
        key: "includesTrailingLines",
        get: function get() {
          return !!this.node && this.node.includesTrailingLines;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var atLineStart = context.atLineStart, lineStart = context.lineStart;
          if (!atLineStart && this.type === Type.SEQ_ITEM)
            this.error = new YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
          var indent = atLineStart ? start - lineStart : context.indent;
          var offset = Node.endOfWhiteSpace(src, start + 1);
          var ch = src[offset];
          var inlineComment = ch === "#";
          var comments = [];
          var blankLine = null;
          while (ch === "\n" || ch === "#") {
            if (ch === "#") {
              var _end = Node.endOfLine(src, offset + 1);
              comments.push(new Range(offset, _end));
              offset = _end;
            } else {
              atLineStart = true;
              lineStart = offset + 1;
              var wsEnd = Node.endOfWhiteSpace(src, lineStart);
              if (src[wsEnd] === "\n" && comments.length === 0) {
                blankLine = new BlankLine();
                lineStart = blankLine.parse({
                  src
                }, lineStart);
              }
              offset = Node.endOfIndent(src, lineStart);
            }
            ch = src[offset];
          }
          if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {
            this.node = parseNode({
              atLineStart,
              inCollection: false,
              indent,
              lineStart,
              parent: this
            }, offset);
          } else if (ch && lineStart > start + 1) {
            offset = lineStart - 1;
          }
          if (this.node) {
            if (blankLine) {
              var items = context.parent.items || context.parent.contents;
              if (items)
                items.push(blankLine);
            }
            if (comments.length)
              Array.prototype.push.apply(this.props, comments);
            offset = this.node.range.end;
          } else {
            if (inlineComment) {
              var c2 = comments[0];
              this.props.push(c2);
              offset = c2.end;
            } else {
              offset = Node.endOfLine(src, start + 1);
            }
          }
          var end = this.node ? this.node.valueRange.end : offset;
          this.valueRange = new Range(start, end);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(CollectionItem2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.node ? this.node.setOrigRanges(cr, offset) : offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, node = this.node, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
          return Node.addStringTerminator(src, range.end, str);
        }
      }]);
      return CollectionItem2;
    }(Node);
    Comment = function(_Node) {
      _inherits(Comment2, _Node);
      var _super = _createSuper(Comment2);
      function Comment2() {
        _classCallCheck(this, Comment2);
        return _super.call(this, Type.COMMENT);
      }
      _createClass(Comment2, [{
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var offset = this.parseComment(start);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Comment2;
    }(Node);
    Collection = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(firstItem) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);
        for (var i2 = firstItem.props.length - 1; i2 >= 0; --i2) {
          if (firstItem.props[i2].start < firstItem.context.lineStart) {
            _this.props = firstItem.props.slice(0, i2 + 1);
            firstItem.props = firstItem.props.slice(i2 + 1);
            var itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        _this.items = [firstItem];
        var ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(_this.items, ec);
        return _this;
      }
      _createClass(Collection3, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.items.length > 0;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var lineStart = Node.startOfLine(src, start);
          var firstItem = this.items[0];
          firstItem.context.parent = this;
          this.valueRange = Range.copy(firstItem.valueRange);
          var indent = firstItem.range.start - firstItem.context.lineStart;
          var offset = start;
          offset = Node.normalizeOffset(src, offset);
          var ch = src[offset];
          var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;
          var prevIncludesTrailingLines = false;
          while (ch) {
            while (ch === "\n" || ch === "#") {
              if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
                var blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
                this.items.push(blankLine);
                offset -= 1;
              } else if (ch === "#") {
                if (offset < lineStart + indent && !Collection3.nextContentHasIndent(src, offset, indent)) {
                  return offset;
                }
                var comment = new Comment();
                offset = comment.parse({
                  indent,
                  lineStart,
                  src
                }, offset);
                this.items.push(comment);
                this.valueRange.end = offset;
                if (offset >= src.length) {
                  ch = null;
                  break;
                }
              }
              lineStart = offset + 1;
              offset = Node.endOfIndent(src, lineStart);
              if (Node.atBlank(src, offset)) {
                var wsEnd = Node.endOfWhiteSpace(src, offset);
                var next = src[wsEnd];
                if (!next || next === "\n" || next === "#") {
                  offset = wsEnd;
                }
              }
              ch = src[offset];
              atLineStart = true;
            }
            if (!ch) {
              break;
            }
            if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
              if (offset < lineStart + indent) {
                if (lineStart > start)
                  offset = lineStart;
                break;
              } else if (!this.error) {
                var msg = "All collection items must start at the same column";
                this.error = new YAMLSyntaxError(this, msg);
              }
            }
            if (firstItem.type === Type.SEQ_ITEM) {
              if (ch !== "-") {
                if (lineStart > start)
                  offset = lineStart;
                break;
              }
            } else if (ch === "-" && !this.error) {
              var _next = src[offset + 1];
              if (!_next || _next === "\n" || _next === "	" || _next === " ") {
                var _msg = "A collection cannot be both a mapping and a sequence";
                this.error = new YAMLSyntaxError(this, _msg);
              }
            }
            var node = parseNode({
              atLineStart,
              inCollection: true,
              indent,
              lineStart,
              parent: this
            }, offset);
            if (!node)
              return offset;
            this.items.push(node);
            this.valueRange.end = node.valueRange.end;
            offset = Node.normalizeOffset(src, node.range.end);
            ch = src[offset];
            atLineStart = false;
            prevIncludesTrailingLines = node.includesTrailingLines;
            if (ch) {
              var ls = offset - 1;
              var prev = src[ls];
              while (prev === " " || prev === "	") {
                prev = src[--ls];
              }
              if (prev === "\n") {
                lineStart = ls + 1;
                atLineStart = true;
              }
            }
            var ec = grabCollectionEndComments(node);
            if (ec)
              Array.prototype.push.apply(this.items, ec);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Collection3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, items = this.items, range = this.range, value = this.value;
          if (value != null)
            return value;
          var str = src.slice(range.start, items[0].range.start) + String(items[0]);
          for (var i2 = 1; i2 < items.length; ++i2) {
            var item = items[i2];
            var _item$context = item.context, atLineStart = _item$context.atLineStart, indent = _item$context.indent;
            if (atLineStart)
              for (var _i = 0; _i < indent; ++_i) {
                str += " ";
              }
            str += String(item);
          }
          return Node.addStringTerminator(src, range.end, str);
        }
      }], [{
        key: "nextContentHasIndent",
        value: function nextContentHasIndent(src, offset, indent) {
          var lineStart = Node.endOfLine(src, offset) + 1;
          offset = Node.endOfWhiteSpace(src, lineStart);
          var ch = src[offset];
          if (!ch)
            return false;
          if (offset >= lineStart + indent)
            return true;
          if (ch !== "#" && ch !== "\n")
            return false;
          return Collection3.nextContentHasIndent(src, offset, indent);
        }
      }]);
      return Collection3;
    }(Node);
    Directive = function(_Node) {
      _inherits(Directive2, _Node);
      var _super = _createSuper(Directive2);
      function Directive2() {
        var _this;
        _classCallCheck(this, Directive2);
        _this = _super.call(this, Type.DIRECTIVE);
        _this.name = null;
        return _this;
      }
      _createClass(Directive2, [{
        key: "parameters",
        get: function get() {
          var raw = this.rawValue;
          return raw ? raw.trim().split(/[ \t]+/) : [];
        }
      }, {
        key: "parseName",
        value: function parseName(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "	" && ch !== " ") {
            ch = src[offset += 1];
          }
          this.name = src.slice(start, offset);
          return offset;
        }
      }, {
        key: "parseParameters",
        value: function parseParameters(start) {
          var src = this.context.src;
          var offset = start;
          var ch = src[offset];
          while (ch && ch !== "\n" && ch !== "#") {
            ch = src[offset += 1];
          }
          this.valueRange = new Range(start, offset);
          return offset;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var offset = this.parseName(start + 1);
          offset = this.parseParameters(offset);
          offset = this.parseComment(offset);
          this.range = new Range(start, offset);
          return offset;
        }
      }]);
      return Directive2;
    }(Node);
    Document = function(_Node) {
      _inherits(Document3, _Node);
      var _super = _createSuper(Document3);
      function Document3() {
        var _this;
        _classCallCheck(this, Document3);
        _this = _super.call(this, Type.DOCUMENT);
        _this.directives = null;
        _this.contents = null;
        _this.directivesEndMarker = null;
        _this.documentEndMarker = null;
        return _this;
      }
      _createClass(Document3, [{
        key: "parseDirectives",
        value: function parseDirectives2(start) {
          var src = this.context.src;
          this.directives = [];
          var atLineStart = true;
          var hasDirectives = false;
          var offset = start;
          while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {
            offset = Document3.startCommentOrEndBlankLine(src, offset);
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.directives.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.directives.push(comment);
                  atLineStart = false;
                }
                break;
              case "%":
                {
                  var directive = new Directive();
                  offset = directive.parse({
                    parent: this,
                    src
                  }, offset);
                  this.directives.push(directive);
                  hasDirectives = true;
                  atLineStart = false;
                }
                break;
              default:
                if (hasDirectives) {
                  this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
                } else if (this.directives.length > 0) {
                  this.contents = this.directives;
                  this.directives = [];
                }
                return offset;
            }
          }
          if (src[offset]) {
            this.directivesEndMarker = new Range(offset, offset + 3);
            return offset + 3;
          }
          if (hasDirectives) {
            this.error = new YAMLSemanticError(this, "Missing directives-end indicator line");
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }
          return offset;
        }
      }, {
        key: "parseContents",
        value: function parseContents2(start) {
          var _this$context = this.context, parseNode = _this$context.parseNode, src = _this$context.src;
          if (!this.contents)
            this.contents = [];
          var lineStart = start;
          while (src[lineStart - 1] === "-") {
            lineStart -= 1;
          }
          var offset = Node.endOfWhiteSpace(src, start);
          var atLineStart = lineStart === start;
          this.valueRange = new Range(offset);
          while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {
            switch (src[offset]) {
              case "\n":
                if (atLineStart) {
                  var blankLine = new BlankLine();
                  offset = blankLine.parse({
                    src
                  }, offset);
                  if (offset < src.length) {
                    this.contents.push(blankLine);
                  }
                } else {
                  offset += 1;
                  atLineStart = true;
                }
                lineStart = offset;
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.contents.push(comment);
                  atLineStart = false;
                }
                break;
              default: {
                var iEnd = Node.endOfIndent(src, offset);
                var context = {
                  atLineStart,
                  indent: -1,
                  inFlow: false,
                  inCollection: false,
                  lineStart,
                  parent: this
                };
                var node = parseNode(context, iEnd);
                if (!node)
                  return this.valueRange.end = iEnd;
                this.contents.push(node);
                offset = node.range.end;
                atLineStart = false;
                var ec = grabCollectionEndComments(node);
                if (ec)
                  Array.prototype.push.apply(this.contents, ec);
              }
            }
            offset = Document3.startCommentOrEndBlankLine(src, offset);
          }
          this.valueRange.end = offset;
          if (src[offset]) {
            this.documentEndMarker = new Range(offset, offset + 3);
            offset += 3;
            if (src[offset]) {
              offset = Node.endOfWhiteSpace(src, offset);
              if (src[offset] === "#") {
                var _comment = new Comment();
                offset = _comment.parse({
                  src
                }, offset);
                this.contents.push(_comment);
              }
              switch (src[offset]) {
                case "\n":
                  offset += 1;
                  break;
                case void 0:
                  break;
                default:
                  this.error = new YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
              }
            }
          }
          return offset;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          context.root = this;
          this.context = context;
          var src = context.src;
          var offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
          offset = this.parseDirectives(offset);
          offset = this.parseContents(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(Document3.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.directives.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.directivesEndMarker)
            offset = this.directivesEndMarker.setOrigRange(cr, offset);
          this.contents.forEach(function(node) {
            offset = node.setOrigRanges(cr, offset);
          });
          if (this.documentEndMarker)
            offset = this.documentEndMarker.setOrigRange(cr, offset);
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var contents = this.contents, directives = this.directives, value = this.value;
          if (value != null)
            return value;
          var str = directives.join("");
          if (contents.length > 0) {
            if (directives.length > 0 || contents[0].type === Type.COMMENT)
              str += "---\n";
            str += contents.join("");
          }
          if (str[str.length - 1] !== "\n")
            str += "\n";
          return str;
        }
      }], [{
        key: "startCommentOrEndBlankLine",
        value: function startCommentOrEndBlankLine(src, start) {
          var offset = Node.endOfWhiteSpace(src, start);
          var ch = src[offset];
          return ch === "#" || ch === "\n" ? offset : start;
        }
      }]);
      return Document3;
    }(Node);
    Alias = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3() {
        _classCallCheck(this, Alias3);
        return _super.apply(this, arguments);
      }
      _createClass(Alias3, [{
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var src = context.src;
          var offset = Node.endOfIdentifier(src, start + 1);
          this.valueRange = new Range(start + 1, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }]);
      return Alias3;
    }(Node);
    Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    BlockValue = function(_Node) {
      _inherits(BlockValue2, _Node);
      var _super = _createSuper(BlockValue2);
      function BlockValue2(type, props) {
        var _this;
        _classCallCheck(this, BlockValue2);
        _this = _super.call(this, type, props);
        _this.blockIndent = null;
        _this.chomping = Chomp.CLIP;
        _this.header = null;
        return _this;
      }
      _createClass(BlockValue2, [{
        key: "includesTrailingLines",
        get: function get() {
          return this.chomping === Chomp.KEEP;
        }
      }, {
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (this.valueRange.isEmpty())
            return "";
          var lastNewLine = null;
          var ch = src[end - 1];
          while (ch === "\n" || ch === "	" || ch === " ") {
            end -= 1;
            if (end <= start) {
              if (this.chomping === Chomp.KEEP)
                break;
              else
                return "";
            }
            if (ch === "\n")
              lastNewLine = end;
            ch = src[end - 1];
          }
          var keepStart = end + 1;
          if (lastNewLine) {
            if (this.chomping === Chomp.KEEP) {
              keepStart = lastNewLine;
              end = this.valueRange.end;
            } else {
              end = lastNewLine;
            }
          }
          var bi = indent + this.blockIndent;
          var folded = this.type === Type.BLOCK_FOLDED;
          var atStart = true;
          var str = "";
          var sep = "";
          var prevMoreIndented = false;
          for (var i2 = start; i2 < end; ++i2) {
            for (var j2 = 0; j2 < bi; ++j2) {
              if (src[i2] !== " ")
                break;
              i2 += 1;
            }
            var _ch = src[i2];
            if (_ch === "\n") {
              if (sep === "\n")
                str += "\n";
              else
                sep = "\n";
            } else {
              var lineEnd = Node.endOfLine(src, i2);
              var line = src.slice(i2, lineEnd);
              i2 = lineEnd;
              if (folded && (_ch === " " || _ch === "	") && i2 < keepStart) {
                if (sep === " ")
                  sep = "\n";
                else if (!prevMoreIndented && !atStart && sep === "\n")
                  sep = "\n\n";
                str += sep + line;
                sep = lineEnd < end && src[lineEnd] || "";
                prevMoreIndented = true;
              } else {
                str += sep + line;
                sep = folded && i2 < keepStart ? " " : "\n";
                prevMoreIndented = false;
              }
              if (atStart && line !== "")
                atStart = false;
            }
          }
          return this.chomping === Chomp.STRIP ? str : str + "\n";
        }
      }, {
        key: "parseBlockHeader",
        value: function parseBlockHeader(start) {
          var src = this.context.src;
          var offset = start + 1;
          var bi = "";
          while (true) {
            var ch = src[offset];
            switch (ch) {
              case "-":
                this.chomping = Chomp.STRIP;
                break;
              case "+":
                this.chomping = Chomp.KEEP;
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                bi += ch;
                break;
              default:
                this.blockIndent = Number(bi) || null;
                this.header = new Range(start, offset);
                return offset;
            }
            offset += 1;
          }
        }
      }, {
        key: "parseBlockValue",
        value: function parseBlockValue(start) {
          var _this$context2 = this.context, indent = _this$context2.indent, src = _this$context2.src;
          var explicit = !!this.blockIndent;
          var offset = start;
          var valueEnd = start;
          var minBlockIndent = 1;
          for (var ch = src[offset]; ch === "\n"; ch = src[offset]) {
            offset += 1;
            if (Node.atDocumentBoundary(src, offset))
              break;
            var end = Node.endOfBlockIndent(src, indent, offset);
            if (end === null)
              break;
            var _ch2 = src[end];
            var lineIndent = end - (offset + indent);
            if (!this.blockIndent) {
              if (src[end] !== "\n") {
                if (lineIndent < minBlockIndent) {
                  var msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                  this.error = new YAMLSemanticError(this, msg);
                }
                this.blockIndent = lineIndent;
              } else if (lineIndent > minBlockIndent) {
                minBlockIndent = lineIndent;
              }
            } else if (_ch2 && _ch2 !== "\n" && lineIndent < this.blockIndent) {
              if (src[end] === "#")
                break;
              if (!this.error) {
                var _src = explicit ? "explicit indentation indicator" : "first line";
                var _msg = "Block scalars must not be less indented than their ".concat(_src);
                this.error = new YAMLSemanticError(this, _msg);
              }
            }
            if (src[end] === "\n") {
              offset = end;
            } else {
              offset = valueEnd = Node.endOfLine(src, end);
            }
          }
          if (this.chomping !== Chomp.KEEP) {
            offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
          }
          this.valueRange = new Range(start + 1, offset);
          return offset;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var src = context.src;
          var offset = this.parseBlockHeader(start);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          offset = this.parseBlockValue(offset);
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(BlockValue2.prototype), "setOrigRanges", this).call(this, cr, offset);
          return this.header ? this.header.setOrigRange(cr, offset) : offset;
        }
      }]);
      return BlockValue2;
    }(Node);
    FlowCollection = function(_Node) {
      _inherits(FlowCollection2, _Node);
      var _super = _createSuper(FlowCollection2);
      function FlowCollection2(type, props) {
        var _this;
        _classCallCheck(this, FlowCollection2);
        _this = _super.call(this, type, props);
        _this.items = null;
        return _this;
      }
      _createClass(FlowCollection2, [{
        key: "prevNodeIsJsonLike",
        value: function prevNodeIsJsonLike() {
          var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length;
          var node = this.items[idx - 1];
          return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var parseNode = context.parseNode, src = context.src;
          var indent = context.indent, lineStart = context.lineStart;
          var char = src[start];
          this.items = [{
            char,
            offset: start
          }];
          var offset = Node.endOfWhiteSpace(src, start + 1);
          char = src[offset];
          while (char && char !== "]" && char !== "}") {
            switch (char) {
              case "\n":
                {
                  lineStart = offset + 1;
                  var wsEnd = Node.endOfWhiteSpace(src, lineStart);
                  if (src[wsEnd] === "\n") {
                    var blankLine = new BlankLine();
                    lineStart = blankLine.parse({
                      src
                    }, lineStart);
                    this.items.push(blankLine);
                  }
                  offset = Node.endOfIndent(src, lineStart);
                  if (offset <= lineStart + indent) {
                    char = src[offset];
                    if (offset < lineStart + indent || char !== "]" && char !== "}") {
                      var msg = "Insufficient indentation in flow collection";
                      this.error = new YAMLSemanticError(this, msg);
                    }
                  }
                }
                break;
              case ",":
                {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                }
                break;
              case "#":
                {
                  var comment = new Comment();
                  offset = comment.parse({
                    src
                  }, offset);
                  this.items.push(comment);
                }
                break;
              case "?":
              case ":": {
                var next = src[offset + 1];
                if (next === "\n" || next === "	" || next === " " || next === "," || char === ":" && this.prevNodeIsJsonLike()) {
                  this.items.push({
                    char,
                    offset
                  });
                  offset += 1;
                  break;
                }
              }
              default: {
                var node = parseNode({
                  atLineStart: false,
                  inCollection: false,
                  inFlow: true,
                  indent: -1,
                  lineStart,
                  parent: this
                }, offset);
                if (!node) {
                  this.valueRange = new Range(start, offset);
                  return offset;
                }
                this.items.push(node);
                offset = Node.normalizeOffset(src, node.range.end);
              }
            }
            offset = Node.endOfWhiteSpace(src, offset);
            char = src[offset];
          }
          this.valueRange = new Range(start, offset + 1);
          if (char) {
            this.items.push({
              char,
              offset
            });
            offset = Node.endOfWhiteSpace(src, offset + 1);
            offset = this.parseComment(offset);
          }
          return offset;
        }
      }, {
        key: "setOrigRanges",
        value: function setOrigRanges(cr, offset) {
          offset = _get(_getPrototypeOf(FlowCollection2.prototype), "setOrigRanges", this).call(this, cr, offset);
          this.items.forEach(function(node) {
            if (node instanceof Node) {
              offset = node.setOrigRanges(cr, offset);
            } else if (cr.length === 0) {
              node.origOffset = node.offset;
            } else {
              var i2 = offset;
              while (i2 < cr.length) {
                if (cr[i2] > node.offset)
                  break;
                else
                  ++i2;
              }
              node.origOffset = node.offset + i2;
              offset = i2;
            }
          });
          return offset;
        }
      }, {
        key: "toString",
        value: function toString() {
          var src = this.context.src, items = this.items, range = this.range, value = this.value;
          if (value != null)
            return value;
          var nodes = items.filter(function(item) {
            return item instanceof Node;
          });
          var str = "";
          var prevEnd = range.start;
          nodes.forEach(function(node) {
            var prefix = src.slice(prevEnd, node.range.start);
            prevEnd = node.range.end;
            str += prefix + String(node);
            if (str[str.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
              prevEnd += 1;
            }
          });
          str += src.slice(prevEnd, range.end);
          return Node.addStringTerminator(src, range.end, str);
        }
      }]);
      return FlowCollection2;
    }(Node);
    QuoteDouble = function(_Node) {
      _inherits(QuoteDouble2, _Node);
      var _super = _createSuper(QuoteDouble2);
      function QuoteDouble2() {
        _classCallCheck(this, QuoteDouble2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteDouble2, [{
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var errors = [];
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (src[end - 1] !== '"')
            errors.push(new YAMLSyntaxError(this, 'Missing closing "quote'));
          var str = "";
          for (var i2 = start + 1; i2 < end - 1; ++i2) {
            var ch = src[i2];
            if (ch === "\n") {
              if (Node.atDocumentBoundary(src, i2 + 1))
                errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
              var _Node$foldNewline = Node.foldNewline(src, i2, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
              str += fold;
              i2 = offset;
              if (error)
                errors.push(new YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
            } else if (ch === "\\") {
              i2 += 1;
              switch (src[i2]) {
                case "0":
                  str += "\0";
                  break;
                case "a":
                  str += "\x07";
                  break;
                case "b":
                  str += "\b";
                  break;
                case "e":
                  str += "\x1B";
                  break;
                case "f":
                  str += "\f";
                  break;
                case "n":
                  str += "\n";
                  break;
                case "r":
                  str += "\r";
                  break;
                case "t":
                  str += "	";
                  break;
                case "v":
                  str += "\v";
                  break;
                case "N":
                  str += "\x85";
                  break;
                case "_":
                  str += "\xA0";
                  break;
                case "L":
                  str += "\u2028";
                  break;
                case "P":
                  str += "\u2029";
                  break;
                case " ":
                  str += " ";
                  break;
                case '"':
                  str += '"';
                  break;
                case "/":
                  str += "/";
                  break;
                case "\\":
                  str += "\\";
                  break;
                case "	":
                  str += "	";
                  break;
                case "x":
                  str += this.parseCharCode(i2 + 1, 2, errors);
                  i2 += 2;
                  break;
                case "u":
                  str += this.parseCharCode(i2 + 1, 4, errors);
                  i2 += 4;
                  break;
                case "U":
                  str += this.parseCharCode(i2 + 1, 8, errors);
                  i2 += 8;
                  break;
                case "\n":
                  while (src[i2 + 1] === " " || src[i2 + 1] === "	") {
                    i2 += 1;
                  }
                  break;
                default:
                  errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(i2 - 1, 2))));
                  str += "\\" + src[i2];
              }
            } else if (ch === " " || ch === "	") {
              var wsStart = i2;
              var next = src[i2 + 1];
              while (next === " " || next === "	") {
                i2 += 1;
                next = src[i2 + 1];
              }
              if (next !== "\n")
                str += i2 > wsStart ? src.slice(wsStart, i2 + 1) : ch;
            } else {
              str += ch;
            }
          }
          return errors.length > 0 ? {
            errors,
            str
          } : str;
        }
      }, {
        key: "parseCharCode",
        value: function parseCharCode(offset, length, errors) {
          var src = this.context.src;
          var cc = src.substr(offset, length);
          var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
          var code = ok ? parseInt(cc, 16) : NaN;
          if (isNaN(code)) {
            errors.push(new YAMLSyntaxError(this, "Invalid escape sequence ".concat(src.substr(offset - 2, length + 2))));
            return src.substr(offset - 2, length + 2);
          }
          return String.fromCodePoint(code);
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteDouble2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch && ch !== '"') {
            offset += ch === "\\" ? 2 : 1;
            ch = src[offset];
          }
          return offset + 1;
        }
      }]);
      return QuoteDouble2;
    }(Node);
    QuoteSingle = function(_Node) {
      _inherits(QuoteSingle2, _Node);
      var _super = _createSuper(QuoteSingle2);
      function QuoteSingle2() {
        _classCallCheck(this, QuoteSingle2);
        return _super.apply(this, arguments);
      }
      _createClass(QuoteSingle2, [{
        key: "strValue",
        get: function get() {
          if (!this.valueRange || !this.context)
            return null;
          var errors = [];
          var _this$valueRange = this.valueRange, start = _this$valueRange.start, end = _this$valueRange.end;
          var _this$context = this.context, indent = _this$context.indent, src = _this$context.src;
          if (src[end - 1] !== "'")
            errors.push(new YAMLSyntaxError(this, "Missing closing 'quote"));
          var str = "";
          for (var i2 = start + 1; i2 < end - 1; ++i2) {
            var ch = src[i2];
            if (ch === "\n") {
              if (Node.atDocumentBoundary(src, i2 + 1))
                errors.push(new YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
              var _Node$foldNewline = Node.foldNewline(src, i2, indent), fold = _Node$foldNewline.fold, offset = _Node$foldNewline.offset, error = _Node$foldNewline.error;
              str += fold;
              i2 = offset;
              if (error)
                errors.push(new YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
            } else if (ch === "'") {
              str += ch;
              i2 += 1;
              if (src[i2] !== "'")
                errors.push(new YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
            } else if (ch === " " || ch === "	") {
              var wsStart = i2;
              var next = src[i2 + 1];
              while (next === " " || next === "	") {
                i2 += 1;
                next = src[i2 + 1];
              }
              if (next !== "\n")
                str += i2 > wsStart ? src.slice(wsStart, i2 + 1) : ch;
            } else {
              str += ch;
            }
          }
          return errors.length > 0 ? {
            errors,
            str
          } : str;
        }
      }, {
        key: "parse",
        value: function parse4(context, start) {
          this.context = context;
          var src = context.src;
          var offset = QuoteSingle2.endOfQuote(src, start + 1);
          this.valueRange = new Range(start, offset);
          offset = Node.endOfWhiteSpace(src, offset);
          offset = this.parseComment(offset);
          return offset;
        }
      }], [{
        key: "endOfQuote",
        value: function endOfQuote(src, offset) {
          var ch = src[offset];
          while (ch) {
            if (ch === "'") {
              if (src[offset + 1] !== "'")
                break;
              ch = src[offset += 2];
            } else {
              ch = src[offset += 1];
            }
          }
          return offset + 1;
        }
      }]);
      return QuoteSingle2;
    }(Node);
    ParseContext = function() {
      function ParseContext2() {
        var _this = this;
        var orig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, atLineStart = _ref.atLineStart, inCollection = _ref.inCollection, inFlow = _ref.inFlow, indent = _ref.indent, lineStart = _ref.lineStart, parent = _ref.parent;
        _classCallCheck(this, ParseContext2);
        _defineProperty(this, "parseNode", function(overlay, start) {
          if (Node.atDocumentBoundary(_this.src, start))
            return null;
          var context = new ParseContext2(_this, overlay);
          var _context$parseProps = context.parseProps(start), props = _context$parseProps.props, type = _context$parseProps.type, valueStart = _context$parseProps.valueStart;
          var node = createNewNode(type, props);
          var offset = node.parse(context, valueStart);
          node.range = new Range(start, offset);
          if (offset <= start) {
            node.error = new Error("Node#parse consumed no characters");
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {
              node.error = new YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            var collection = new Collection(node);
            offset = collection.parse(new ParseContext2(context), offset);
            collection.range = new Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      _createClass(ParseContext2, [{
        key: "nodeStartsCollection",
        value: function nodeStartsCollection(node) {
          var inCollection = this.inCollection, inFlow = this.inFlow, src = this.src;
          if (inCollection || inFlow)
            return false;
          if (node instanceof CollectionItem)
            return true;
          var offset = node.range.end;
          if (src[offset] === "\n" || src[offset - 1] === "\n")
            return false;
          offset = Node.endOfWhiteSpace(src, offset);
          return src[offset] === ":";
        }
      }, {
        key: "parseProps",
        value: function parseProps(offset) {
          var inFlow = this.inFlow, parent = this.parent, src = this.src;
          var props = [];
          var lineHasProps = false;
          offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);
          var ch = src[offset];
          while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === "\n") {
            if (ch === "\n") {
              var inEnd = offset;
              var lineStart = void 0;
              do {
                lineStart = inEnd + 1;
                inEnd = Node.endOfIndent(src, lineStart);
              } while (src[inEnd] === "\n");
              var indentDiff = inEnd - (lineStart + this.indent);
              var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;
              if (src[inEnd] !== "#" && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
                break;
              this.atLineStart = true;
              this.lineStart = lineStart;
              lineHasProps = false;
              offset = inEnd;
            } else if (ch === Char.COMMENT) {
              var end = Node.endOfLine(src, offset + 1);
              props.push(new Range(offset, end));
              offset = end;
            } else {
              var _end = Node.endOfIdentifier(src, offset + 1);
              if (ch === Char.TAG && src[_end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, _end + 13))) {
                _end = Node.endOfIdentifier(src, _end + 5);
              }
              props.push(new Range(offset, _end));
              lineHasProps = true;
              offset = Node.endOfWhiteSpace(src, _end);
            }
            ch = src[offset];
          }
          if (lineHasProps && ch === ":" && Node.atBlank(src, offset + 1, true))
            offset -= 1;
          var type = ParseContext2.parseType(src, offset, inFlow);
          return {
            props,
            type,
            valueStart: offset
          };
        }
      }], [{
        key: "parseType",
        value: function parseType(src, offset, inFlow) {
          switch (src[offset]) {
            case "*":
              return Type.ALIAS;
            case ">":
              return Type.BLOCK_FOLDED;
            case "|":
              return Type.BLOCK_LITERAL;
            case "{":
              return Type.FLOW_MAP;
            case "[":
              return Type.FLOW_SEQ;
            case "?":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;
            case ":":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;
            case "-":
              return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;
            case '"':
              return Type.QUOTE_DOUBLE;
            case "'":
              return Type.QUOTE_SINGLE;
            default:
              return Type.PLAIN;
          }
        }
      }]);
      return ParseContext2;
    }();
  }
});

// node_modules/yaml/browser/dist/resolveSeq-492ab440.js
function addCommentBefore(str, indent, comment) {
  if (!comment)
    return str;
  var cc = comment.replace(/[\s\S]^/gm, "$&".concat(indent, "#"));
  return "#".concat(cc, "\n").concat(indent).concat(str);
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf("\n") === -1 ? "".concat(str, " #").concat(comment) : "".concat(str, "\n") + comment.replace(/^/gm, "".concat(indent || "", "#"));
}
function toJSON(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map(function(v2, i2) {
      return toJSON(v2, String(i2), ctx);
    });
  if (value && typeof value.toJSON === "function") {
    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor)
      ctx.onCreate = function(res2) {
        anchor.res = res2;
        delete ctx.onCreate;
      };
    var res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if ((!ctx || !ctx.keep) && typeof value === "bigint")
    return Number(value);
  return value;
}
function collectionFromPath(schema, path, value) {
  var v2 = value;
  for (var i2 = path.length - 1; i2 >= 0; --i2) {
    var k2 = path[i2];
    if (Number.isInteger(k2) && k2 >= 0) {
      var a2 = [];
      a2[k2] = v2;
      v2 = a2;
    } else {
      var o2 = {};
      Object.defineProperty(o2, k2, {
        value: v2,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v2 = o2;
    }
  }
  return schema.createNode(v2, false);
}
function asItemIndex(key) {
  var idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function findPair(items, key) {
  var k2 = key instanceof Scalar ? key.value : key;
  var _iterator = _createForOfIteratorHelper(items), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      if (it instanceof Pair) {
        if (it.key === key || it.key === k2)
          return it;
        if (it.key && it.key.value === k2)
          return it;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return void 0;
}
function resolveScalar(str, tags2, scalarFallback) {
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, format = _step$value.format, test = _step$value.test, resolve27 = _step$value.resolve;
      if (test) {
        var match = str.match(test);
        if (match) {
          var res = resolve27.apply(null, match);
          if (!(res instanceof Scalar))
            res = new Scalar(res);
          if (format)
            res.format = format;
          return res;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (scalarFallback)
    str = scalarFallback(str);
  return new Scalar(str);
}
function foldFlowLines(text, indent, mode, _ref) {
  var indentAtStart = _ref.indentAtStart, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth, _ref$minContentWidth = _ref.minContentWidth, minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth, onFold = _ref.onFold, onOverflow = _ref.onOverflow;
  if (!lineWidth || lineWidth < 0)
    return text;
  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  var folds = [];
  var escapedFolds = {};
  var end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  var split = void 0;
  var prev = void 0;
  var overflow = false;
  var i2 = -1;
  var escStart = -1;
  var escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (var ch; ch = text[i2 += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        var next = text[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i2 += 1];
            overflow = true;
          }
          var j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j2])
            return text;
          folds.push(j2);
          escapedFolds[j2] = true;
          end = j2 + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  var res = text.slice(0, folds[0]);
  for (var _i = 0; _i < folds.length; ++_i) {
    var fold = folds[_i];
    var _end = folds[_i + 1] || text.length;
    if (fold === 0)
      res = "\n".concat(indent).concat(text.slice(0, _end));
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += "".concat(text[fold], "\\");
      res += "\n".concat(indent).concat(text.slice(fold + 1, _end));
    }
  }
  return res;
}
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  var limit = lineWidth - indentLength;
  var strLen = str.length;
  if (strLen <= limit)
    return false;
  for (var i2 = 0, start = 0; i2 < strLen; ++i2) {
    if (str[i2] === "\n") {
      if (i2 - start > limit)
        return true;
      start = i2 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  var implicitKey = ctx.implicitKey;
  var _strOptions$doubleQuo = strOptions.doubleQuoted, jsonEncoding = _strOptions$doubleQuo.jsonEncoding, minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;
  var json2 = JSON.stringify(value);
  if (jsonEncoding)
    return json2;
  var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  var str = "";
  var start = 0;
  for (var i2 = 0, ch = json2[i2]; ch; ch = json2[++i2]) {
    if (ch === " " && json2[i2 + 1] === "\\" && json2[i2 + 2] === "n") {
      str += json2.slice(start, i2) + "\\ ";
      i2 += 1;
      start = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i2 + 1]) {
        case "u":
          {
            str += json2.slice(start, i2);
            var code = json2.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json2.substr(i2, 6);
            }
            i2 += 5;
            start = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i2 + 2] === '"' || json2.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str += json2.slice(start, i2) + "\n\n";
            while (json2[i2 + 2] === "\\" && json2[i2 + 3] === "n" && json2[i2 + 4] !== '"') {
              str += "\n";
              i2 += 2;
            }
            str += indent;
            if (json2[i2 + 2] === " ")
              str += "\\";
            i2 += 1;
            start = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str = start ? str + json2.slice(start) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value))
      return doubleQuotedString(value, ctx);
  } else {
    if (/[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
  }
  var indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  var res = "'" + value.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(indent)) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function blockString(_ref2, ctx, onComment, onChompKeep) {
  var comment = _ref2.comment, type = _ref2.type, value = _ref2.value;
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }
  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  var indentSize = indent ? "2" : "1";
  var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
  var header = literal ? "|" : ">";
  if (!value)
    return header + "\n";
  var wsStart = "";
  var wsEnd = "";
  value = value.replace(/[\n\t ]*$/, function(ws) {
    var n2 = ws.indexOf("\n");
    if (n2 === -1) {
      header += "-";
    } else if (value === ws || n2 !== ws.length - 1) {
      header += "+";
      if (onChompKeep)
        onChompKeep();
    }
    wsEnd = ws.replace(/\n$/, "");
    return "";
  }).replace(/^[\n ]*/, function(ws) {
    if (ws.indexOf(" ") !== -1)
      header += indentSize;
    var m2 = ws.match(/ +$/);
    if (m2) {
      wsStart = ws.slice(0, -m2[0].length);
      return m2[0];
    } else {
      wsStart = ws;
      return "";
    }
  });
  if (wsEnd)
    wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, "$&".concat(indent));
  if (wsStart)
    wsStart = wsStart.replace(/\n+/g, "$&".concat(indent));
  if (comment) {
    header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
    if (onComment)
      onComment();
  }
  if (!value)
    return "".concat(header).concat(indentSize, "\n").concat(indent).concat(wsEnd);
  if (literal) {
    value = value.replace(/\n+/g, "$&".concat(indent));
    return "".concat(header, "\n").concat(indent).concat(wsStart).concat(value).concat(wsEnd);
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(indent));
  var body = foldFlowLines("".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);
  return "".concat(header, "\n").concat(indent).concat(body);
}
function plainString(item, ctx, onComment, onChompKeep) {
  var comment = item.comment, type = item.type, value = item.value;
  var actualString = ctx.actualString, implicitKey = ctx.implicitKey, indent = ctx.indent, inFlow = ctx.inFlow;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  var str = value.replace(/\n+/g, "$&\n".concat(indent));
  if (actualString) {
    var tags2 = ctx.doc.schema.tags;
    var resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
    if (typeof resolved !== "string")
      return doubleQuotedString(value, ctx);
  }
  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
  if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
    if (onComment)
      onComment();
    return addCommentBefore(body, indent, comment);
  }
  return body;
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  var defaultType = strOptions.defaultType;
  var implicitKey = ctx.implicitKey, inFlow = ctx.inFlow;
  var _item = item, type = _item.type, value = _item.value;
  if (typeof value !== "string") {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }
  var _stringify = function _stringify2(_type) {
    switch (_type) {
      case Type.BLOCK_FOLDED:
      case Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);
      case Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);
      case Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);
      case Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  if (type !== Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    type = Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {
    type = Type.QUOTE_DOUBLE;
  }
  var res = _stringify(type);
  if (res === null) {
    res = _stringify(defaultType);
    if (res === null)
      throw new Error("Unsupported default string type ".concat(defaultType));
  }
  return res;
}
function stringifyNumber(_ref) {
  var format = _ref.format, minFractionDigits = _ref.minFractionDigits, tag = _ref.tag, value = _ref.value;
  if (typeof value === "bigint")
    return String(value);
  if (!isFinite(value))
    return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
  var n2 = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    var i2 = n2.indexOf(".");
    if (i2 < 0) {
      i2 = n2.length;
      n2 += ".";
    }
    var d2 = minFractionDigits - (n2.length - i2 - 1);
    while (d2-- > 0) {
      n2 += "0";
    }
  }
  return n2;
}
function checkFlowCollectionEnd(errors, cst) {
  var char, name;
  switch (cst.type) {
    case Type.FLOW_MAP:
      char = "}";
      name = "flow map";
      break;
    case Type.FLOW_SEQ:
      char = "]";
      name = "flow sequence";
      break;
    default:
      errors.push(new YAMLSemanticError(cst, "Not a flow collection!?"));
      return;
  }
  var lastItem;
  for (var i2 = cst.items.length - 1; i2 >= 0; --i2) {
    var item = cst.items[i2];
    if (!item || item.type !== Type.COMMENT) {
      lastItem = item;
      break;
    }
  }
  if (lastItem && lastItem.char !== char) {
    var msg = "Expected ".concat(name, " to end with ").concat(char);
    var err;
    if (typeof lastItem.offset === "number") {
      err = new YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end)
        err.offset = lastItem.range.end - lastItem.range.start;
    }
    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  var prev = comment.context.src[comment.range.start - 1];
  if (prev !== "\n" && prev !== "	" && prev !== " ") {
    var msg = "Comments must be separated from other tokens by white space characters";
    errors.push(new YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  var sk = String(key);
  var k2 = sk.substr(0, 8) + "..." + sk.substr(-8);
  return new YAMLSemanticError(source, 'The "'.concat(k2, '" key is too long'));
}
function resolveComments(collection, comments) {
  var _iterator = _createForOfIteratorHelper(comments), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, afterKey = _step$value.afterKey, before = _step$value.before, comment = _step$value.comment;
      var item = collection.items[before];
      if (!item) {
        if (comment !== void 0) {
          if (collection.comment)
            collection.comment += "\n" + comment;
          else
            collection.comment = comment;
        }
      } else {
        if (afterKey && item.value)
          item = item.value;
        if (comment === void 0) {
          if (afterKey || !item.commentBefore)
            item.spaceBefore = true;
        } else {
          if (item.commentBefore)
            item.commentBefore += "\n" + comment;
          else
            item.commentBefore = comment;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function resolveString(doc, node) {
  var res = node.strValue;
  if (!res)
    return "";
  if (typeof res === "string")
    return res;
  res.errors.forEach(function(error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}
function resolveTagHandle(doc, node) {
  var _node$tag = node.tag, handle = _node$tag.handle, suffix = _node$tag.suffix;
  var prefix = doc.tagPrefixes.find(function(p2) {
    return p2.handle === handle;
  });
  if (!prefix) {
    var dtp = doc.getDefaults().tagPrefixes;
    if (dtp)
      prefix = dtp.find(function(p2) {
        return p2.handle === handle;
      });
    if (!prefix)
      throw new YAMLSemanticError(node, "The ".concat(handle, " tag handle is non-default and was not declared."));
  }
  if (!suffix)
    throw new YAMLSemanticError(node, "The ".concat(handle, " tag has no suffix."));
  if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
    if (suffix[0] === "^") {
      doc.warnings.push(new YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
      return suffix;
    }
    if (/[:/]/.test(suffix)) {
      var vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? "tag:".concat(vocab[1], ".yaml.org,2002:").concat(vocab[2]) : "tag:".concat(suffix);
    }
  }
  return prefix.prefix + decodeURIComponent(suffix);
}
function resolveTagName(doc, node) {
  var tag = node.tag, type = node.type;
  var nonSpecific = false;
  if (tag) {
    var handle = tag.handle, suffix = tag.suffix, verbatim = tag.verbatim;
    if (verbatim) {
      if (verbatim !== "!" && verbatim !== "!!")
        return verbatim;
      var msg = "Verbatim tags aren't resolved, so ".concat(verbatim, " is invalid.");
      doc.errors.push(new YAMLSemanticError(node, msg));
    } else if (handle === "!" && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }
  switch (type) {
    case Type.BLOCK_FOLDED:
    case Type.BLOCK_LITERAL:
    case Type.QUOTE_DOUBLE:
    case Type.QUOTE_SINGLE:
      return defaultTags.STR;
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    case Type.PLAIN:
      return nonSpecific ? defaultTags.STR : null;
    default:
      return null;
  }
}
function resolveByTagName(doc, node, tagName) {
  var tags2 = doc.schema.tags;
  var matchWithTest = [];
  var _iterator = _createForOfIteratorHelper(tags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var tag = _step.value;
      if (tag.tag === tagName) {
        if (tag.test)
          matchWithTest.push(tag);
        else {
          var res = tag.resolve(doc, node);
          return res instanceof Collection2 ? res : new Scalar(res);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var str = resolveString(doc, node);
  if (typeof str === "string" && matchWithTest.length > 0)
    return resolveScalar(str, matchWithTest, tags2.scalarFallback);
  return null;
}
function getFallbackTagName(_ref) {
  var type = _ref.type;
  switch (type) {
    case Type.FLOW_MAP:
    case Type.MAP:
      return defaultTags.MAP;
    case Type.FLOW_SEQ:
    case Type.SEQ:
      return defaultTags.SEQ;
    default:
      return defaultTags.STR;
  }
}
function resolveTag(doc, node, tagName) {
  try {
    var res = resolveByTagName(doc, node, tagName);
    if (res) {
      if (tagName && node.tag)
        res.tag = tagName;
      return res;
    }
  } catch (error) {
    if (!error.source)
      error.source = node;
    doc.errors.push(error);
    return null;
  }
  try {
    var fallback = getFallbackTagName(node);
    if (!fallback)
      throw new Error("The tag ".concat(tagName, " is unavailable"));
    var msg = "The tag ".concat(tagName, " is unavailable, falling back to ").concat(fallback);
    doc.warnings.push(new YAMLWarning(node, msg));
    var _res = resolveByTagName(doc, node, fallback);
    _res.tag = tagName;
    return _res;
  } catch (error) {
    var refError = new YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}
function resolveNodeProps(errors, node) {
  var comments = {
    before: [],
    after: []
  };
  var hasAnchor = false;
  var hasTag = false;
  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
  var _iterator = _createForOfIteratorHelper(props), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _step$value = _step.value, start = _step$value.start, end = _step$value.end;
      switch (node.context.src[start]) {
        case Char.COMMENT: {
          if (!node.commentHasRequiredWhitespace(start)) {
            var msg = "Comments must be separated from other tokens by white space characters";
            errors.push(new YAMLSemanticError(node, msg));
          }
          var header = node.header, valueRange = node.valueRange;
          var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
        case Char.ANCHOR:
          if (hasAnchor) {
            var _msg = "A node can have at most one anchor";
            errors.push(new YAMLSemanticError(node, _msg));
          }
          hasAnchor = true;
          break;
        case Char.TAG:
          if (hasTag) {
            var _msg2 = "A node can have at most one tag";
            errors.push(new YAMLSemanticError(node, _msg2));
          }
          hasTag = true;
          break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    comments,
    hasAnchor,
    hasTag
  };
}
function resolveNodeValue(doc, node) {
  var anchors = doc.anchors, errors = doc.errors, schema = doc.schema;
  if (node.type === Type.ALIAS) {
    var name = node.rawValue;
    var src = anchors.getNode(name);
    if (!src) {
      var msg = "Aliased anchor not found: ".concat(name);
      errors.push(new YAMLReferenceError(node, msg));
      return null;
    }
    var res = new Alias2(src);
    anchors._cstAliases.push(res);
    return res;
  }
  var tagName = resolveTagName(doc, node);
  if (tagName)
    return resolveTag(doc, node, tagName);
  if (node.type !== Type.PLAIN) {
    var _msg3 = "Failed to resolve ".concat(node.type, " node here");
    errors.push(new YAMLSyntaxError(node, _msg3));
    return null;
  }
  try {
    var str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source)
      error.source = node;
    errors.push(error);
    return null;
  }
}
function resolveNode(doc, node) {
  if (!node)
    return null;
  if (node.error)
    doc.errors.push(node.error);
  var _resolveNodeProps = resolveNodeProps(doc.errors, node), comments = _resolveNodeProps.comments, hasAnchor = _resolveNodeProps.hasAnchor, hasTag = _resolveNodeProps.hasTag;
  if (hasAnchor) {
    var anchors = doc.anchors;
    var name = node.anchor;
    var prev = anchors.getNode(name);
    if (prev)
      anchors.map[anchors.newName(name)] = prev;
    anchors.map[name] = node;
  }
  if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {
    var msg = "An alias node must not specify any properties";
    doc.errors.push(new YAMLSemanticError(node, msg));
  }
  var res = resolveNodeValue(doc, node);
  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes)
      res.cstNode = node;
    if (doc.options.keepNodeTypes)
      res.type = node.type;
    var cb = comments.before.join("\n");
    if (cb) {
      res.commentBefore = res.commentBefore ? "".concat(res.commentBefore, "\n").concat(cb) : cb;
    }
    var ca = comments.after.join("\n");
    if (ca)
      res.comment = res.comment ? "".concat(res.comment, "\n").concat(ca) : ca;
  }
  return node.resolved = res;
}
function resolveMap(doc, cst) {
  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a mapping");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var map2 = new YAMLMap();
  map2.items = items;
  resolveComments(map2, comments);
  var hasCollectionKey = false;
  for (var i2 = 0; i2 < items.length; ++i2) {
    var iKey = items[i2].key;
    if (iKey instanceof Collection2)
      hasCollectionKey = true;
    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i2] = new Merge(items[i2]);
      var sources = items[i2].value.items;
      var error = null;
      sources.some(function(node) {
        if (node instanceof Alias2) {
          var type = node.source.type;
          if (type === Type.MAP || type === Type.FLOW_MAP)
            return false;
          return error = "Merge nodes aliases can only point to maps";
        }
        return error = "Merge nodes can only have Alias nodes as values";
      });
      if (error)
        doc.errors.push(new YAMLSemanticError(cst, error));
    } else {
      for (var j2 = i2 + 1; j2 < items.length; ++j2) {
        var jKey = items[j2].key;
        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
          var _msg = 'Map keys must be unique; "'.concat(iKey, '" is repeated');
          doc.errors.push(new YAMLSemanticError(cst, _msg));
          break;
        }
      }
    }
  }
  if (hasCollectionKey && !doc.options.mapAsMap) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = map2;
  return map2;
}
function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item))
    return;
  var comment = item.getPropValue(0, Char.COMMENT, true);
  var found = false;
  var cb = pair.value.commentBefore;
  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    var cc = pair.value.comment;
    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }
  if (found)
    pair.comment = comment;
}
function resolveBlockMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var keyStart = null;
  for (var i2 = 0; i2 < cst.items.length; ++i2) {
    var item = cst.items[i2];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;
      case Type.MAP_KEY:
        if (key !== void 0)
          items.push(new Pair(key));
        if (item.error)
          doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;
      case Type.MAP_VALUE:
        {
          if (key === void 0)
            key = null;
          if (item.error)
            doc.errors.push(item.error);
          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {
            var msg = "Nested mappings are not allowed in compact mappings";
            doc.errors.push(new YAMLSemanticError(item.node, msg));
          }
          var valueNode = item.node;
          if (!valueNode && item.props.length > 0) {
            valueNode = new PlainValue(Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            var pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };
            if (typeof item.range.origStart === "number") {
              var origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }
          var pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);
          if (key && typeof keyStart === "number") {
            if (item.range.start > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
          }
          key = void 0;
          keyStart = null;
        }
        break;
      default:
        if (key !== void 0)
          items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error)
          doc.errors.push(item.error);
        next:
          for (var j2 = i2 + 1; ; ++j2) {
            var nextItem = cst.items[j2];
            switch (nextItem && nextItem.type) {
              case Type.BLANK_LINE:
              case Type.COMMENT:
                continue next;
              case Type.MAP_VALUE:
                break next;
              default: {
                var _msg2 = "Implicit map keys need to be followed by map values";
                doc.errors.push(new YAMLSemanticError(item, _msg2));
                break next;
              }
            }
          }
        if (item.valueRangeContainsNewline) {
          var _msg3 = "Implicit map keys need to be on a single line";
          doc.errors.push(new YAMLSemanticError(item, _msg3));
        }
    }
  }
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveFlowMapItems(doc, cst) {
  var comments = [];
  var items = [];
  var key = void 0;
  var explicitKey = false;
  var next = "{";
  for (var i2 = 0; i2 < cst.items.length; ++i2) {
    var item = cst.items[i2];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char === "?" && key === void 0 && !explicitKey) {
        explicitKey = true;
        next = ":";
        continue;
      }
      if (char === ":") {
        if (key === void 0)
          key = null;
        if (next === ":") {
          next = ",";
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === void 0 && char !== ",")
            key = null;
          explicitKey = false;
        }
        if (key !== void 0) {
          items.push(new Pair(key));
          key = void 0;
          if (char === ",") {
            next = ":";
            continue;
          }
        }
      }
      if (char === "}") {
        if (i2 === cst.items.length - 1)
          continue;
      } else if (char === next) {
        next = ":";
        continue;
      }
      var msg = "Flow map contains an unexpected ".concat(char);
      var err = new YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === void 0) {
      if (next === ",")
        doc.errors.push(new YAMLSemanticError(item, "Separator , missing in flow map"));
      key = resolveNode(doc, item);
    } else {
      if (next !== ",")
        doc.errors.push(new YAMLSemanticError(item, "Indicator : missing in flow map entry"));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = void 0;
      explicitKey = false;
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
function resolveSeq(doc, cst) {
  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {
    var msg = "A ".concat(cst.type, " node cannot be resolved as a sequence");
    doc.errors.push(new YAMLSyntaxError(cst, msg));
    return null;
  }
  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst), comments = _ref.comments, items = _ref.items;
  var seq2 = new YAMLSeq();
  seq2.items = items;
  resolveComments(seq2, comments);
  if (!doc.options.mapAsMap && items.some(function(it) {
    return it instanceof Pair && it.key instanceof Collection2;
  })) {
    var warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
    doc.warnings.push(new YAMLWarning(cst, warn2));
  }
  cst.resolved = seq2;
  return seq2;
}
function resolveBlockSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  for (var i2 = 0; i2 < cst.items.length; ++i2) {
    var item = cst.items[i2];
    switch (item.type) {
      case Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;
      case Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;
      case Type.SEQ_ITEM:
        if (item.error)
          doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));
        if (item.hasProps) {
          var msg = "Sequence items cannot have tags or anchors before the - indicator";
          doc.errors.push(new YAMLSemanticError(item, msg));
        }
        break;
      default:
        if (item.error)
          doc.errors.push(item.error);
        doc.errors.push(new YAMLSyntaxError(item, "Unexpected ".concat(item.type, " node in sequence")));
    }
  }
  return {
    comments,
    items
  };
}
function resolveFlowSeqItems(doc, cst) {
  var comments = [];
  var items = [];
  var explicitKey = false;
  var key = void 0;
  var keyStart = null;
  var next = "[";
  var prevItem = null;
  for (var i2 = 0; i2 < cst.items.length; ++i2) {
    var item = cst.items[i2];
    if (typeof item.char === "string") {
      var char = item.char, offset = item.offset;
      if (char !== ":" && (explicitKey || key !== void 0)) {
        if (explicitKey && key === void 0)
          key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = void 0;
        keyStart = null;
      }
      if (char === next) {
        next = null;
      } else if (!next && char === "?") {
        explicitKey = true;
      } else if (next !== "[" && char === ":" && key === void 0) {
        if (next === ",") {
          key = items.pop();
          if (key instanceof Pair) {
            var msg = "Chaining flow sequence pairs is invalid";
            var err = new YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
          if (!explicitKey && typeof keyStart === "number") {
            var keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024)
              doc.errors.push(getLongKeyError(cst, key));
            var src = prevItem.context.src;
            for (var _i = keyStart; _i < keyEnd; ++_i) {
              if (src[_i] === "\n") {
                var _msg = "Implicit keys of flow sequence pairs need to be on a single line";
                doc.errors.push(new YAMLSemanticError(prevItem, _msg));
                break;
              }
            }
          }
        } else {
          key = null;
        }
        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === "[" || char !== "]" || i2 < cst.items.length - 1) {
        var _msg2 = "Flow sequence contains an unexpected ".concat(char);
        var _err = new YAMLSyntaxError(cst, _msg2);
        _err.offset = offset;
        doc.errors.push(_err);
      }
    } else if (item.type === Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        var _msg3 = "Expected a ".concat(next, " in flow sequence");
        doc.errors.push(new YAMLSemanticError(item, _msg3));
      }
      var value = resolveNode(doc, item);
      if (key === void 0) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair(key, value));
        key = void 0;
      }
      keyStart = item.range.start;
      next = ",";
    }
  }
  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== void 0)
    items.push(new Pair(key));
  return {
    comments,
    items
  };
}
var Node2, Scalar, isEmptyPath, Collection2, YAMLSeq, stringifyKey, Pair, getAliasCount, Alias2, YAMLMap, MERGE_KEY, Merge, binaryOptions, boolOptions, intOptions, nullOptions, strOptions, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, consumeMoreIndentedLines, getFoldOptions, containsDocumentMarker, isCollectionItem, valueHasPairComment;
var init_resolveSeq_492ab440 = __esm({
  "node_modules/yaml/browser/dist/resolveSeq-492ab440.js"() {
    init_PlainValue_b8036b75();
    Node2 = function Node3() {
      _classCallCheck(this, Node3);
    };
    Scalar = function(_Node) {
      _inherits(Scalar2, _Node);
      var _super = _createSuper(Scalar2);
      function Scalar2(value) {
        var _this;
        _classCallCheck(this, Scalar2);
        _this = _super.call(this);
        _this.value = value;
        return _this;
      }
      _createClass(Scalar2, [{
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
        }
      }, {
        key: "toString",
        value: function toString() {
          return String(this.value);
        }
      }]);
      return Scalar2;
    }(Node2);
    isEmptyPath = function isEmptyPath2(path) {
      return path == null || _typeof(path) === "object" && path[Symbol.iterator]().next().done;
    };
    Collection2 = function(_Node) {
      _inherits(Collection3, _Node);
      var _super = _createSuper(Collection3);
      function Collection3(schema) {
        var _this;
        _classCallCheck(this, Collection3);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "items", []);
        _this.schema = schema;
        return _this;
      }
      _createClass(Collection3, [{
        key: "addIn",
        value: function addIn(path, value) {
          if (isEmptyPath(path))
            this.add(value);
          else {
            var _path = _toArray(path), key = _path[0], rest = _path.slice(1);
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.addIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(_ref) {
          var _ref2 = _toArray(_ref), key = _ref2[0], rest = _ref2.slice(1);
          if (rest.length === 0)
            return this.delete(key);
          var node = this.get(key, true);
          if (node instanceof Collection3)
            return node.deleteIn(rest);
          else
            throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
        }
      }, {
        key: "getIn",
        value: function getIn(_ref3, keepScalar) {
          var _ref4 = _toArray(_ref3), key = _ref4[0], rest = _ref4.slice(1);
          var node = this.get(key, true);
          if (rest.length === 0)
            return !keepScalar && node instanceof Scalar ? node.value : node;
          else
            return node instanceof Collection3 ? node.getIn(rest, keepScalar) : void 0;
        }
      }, {
        key: "hasAllNullValues",
        value: function hasAllNullValues() {
          return this.items.every(function(node) {
            if (!node || node.type !== "PAIR")
              return false;
            var n2 = node.value;
            return n2 == null || n2 instanceof Scalar && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
          });
        }
      }, {
        key: "hasIn",
        value: function hasIn(_ref5) {
          var _ref6 = _toArray(_ref5), key = _ref6[0], rest = _ref6.slice(1);
          if (rest.length === 0)
            return this.has(key);
          var node = this.get(key, true);
          return node instanceof Collection3 ? node.hasIn(rest) : false;
        }
      }, {
        key: "setIn",
        value: function setIn(_ref7, value) {
          var _ref8 = _toArray(_ref7), key = _ref8[0], rest = _ref8.slice(1);
          if (rest.length === 0) {
            this.set(key, value);
          } else {
            var node = this.get(key, true);
            if (node instanceof Collection3)
              node.setIn(rest, value);
            else if (node === void 0 && this.schema)
              this.set(key, collectionFromPath(this.schema, rest, value));
            else
              throw new Error("Expected YAML collection at ".concat(key, ". Remaining path: ").concat(rest));
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON2() {
          return null;
        }
      }, {
        key: "toString",
        value: function toString(ctx, _ref9, onComment, onChompKeep) {
          var _this2 = this;
          var blockItem = _ref9.blockItem, flowChars = _ref9.flowChars, isMap = _ref9.isMap, itemIndent = _ref9.itemIndent;
          var _ctx = ctx, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify17 = _ctx.stringify;
          var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;
          if (inFlow)
            itemIndent += indentStep;
          var allNullValues = isMap && this.hasAllNullValues();
          ctx = Object.assign({}, ctx, {
            allNullValues,
            indent: itemIndent,
            inFlow,
            type: null
          });
          var chompKeep = false;
          var hasItemWithNewLine = false;
          var nodes = this.items.reduce(function(nodes2, item, i2) {
            var comment;
            if (item) {
              if (!chompKeep && item.spaceBefore)
                nodes2.push({
                  type: "comment",
                  str: ""
                });
              if (item.commentBefore)
                item.commentBefore.match(/^.*$/gm).forEach(function(line) {
                  nodes2.push({
                    type: "comment",
                    str: "#".concat(line)
                  });
                });
              if (item.comment)
                comment = item.comment;
              if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
                hasItemWithNewLine = true;
            }
            chompKeep = false;
            var str2 = stringify17(item, ctx, function() {
              return comment = null;
            }, function() {
              return chompKeep = true;
            });
            if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
              hasItemWithNewLine = true;
            if (inFlow && i2 < _this2.items.length - 1)
              str2 += ",";
            str2 = addComment(str2, itemIndent, comment);
            if (chompKeep && (comment || inFlow))
              chompKeep = false;
            nodes2.push({
              type: "item",
              str: str2
            });
            return nodes2;
          }, []);
          var str;
          if (nodes.length === 0) {
            str = flowChars.start + flowChars.end;
          } else if (inFlow) {
            var start = flowChars.start, end = flowChars.end;
            var strings = nodes.map(function(n2) {
              return n2.str;
            });
            if (hasItemWithNewLine || strings.reduce(function(sum, str2) {
              return sum + str2.length + 2;
            }, 2) > Collection3.maxFlowStringSingleLineLength) {
              str = start;
              var _iterator = _createForOfIteratorHelper(strings), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var s2 = _step.value;
                  str += s2 ? "\n".concat(indentStep).concat(indent).concat(s2) : "\n";
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              str += "\n".concat(indent).concat(end);
            } else {
              str = "".concat(start, " ").concat(strings.join(" "), " ").concat(end);
            }
          } else {
            var _strings = nodes.map(blockItem);
            str = _strings.shift();
            var _iterator2 = _createForOfIteratorHelper(_strings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _s = _step2.value;
                str += _s ? "\n".concat(indent).concat(_s) : "\n";
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          if (this.comment) {
            str += "\n" + this.comment.replace(/^/gm, "".concat(indent, "#"));
            if (onComment)
              onComment();
          } else if (chompKeep && onChompKeep)
            onChompKeep();
          return str;
        }
      }]);
      return Collection3;
    }(Node2);
    _defineProperty(Collection2, "maxFlowStringSingleLineLength", 60);
    YAMLSeq = function(_Collection) {
      _inherits(YAMLSeq2, _Collection);
      var _super = _createSuper(YAMLSeq2);
      function YAMLSeq2() {
        _classCallCheck(this, YAMLSeq2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLSeq2, [{
        key: "add",
        value: function add(value) {
          this.items.push(value);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return false;
          var del = this.items.splice(idx, 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            return void 0;
          var it = this.items[idx];
          return !keepScalar && it instanceof Scalar ? it.value : it;
        }
      }, {
        key: "has",
        value: function has(key) {
          var idx = asItemIndex(key);
          return typeof idx === "number" && idx < this.items.length;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          var idx = asItemIndex(key);
          if (typeof idx !== "number")
            throw new Error("Expected a valid index, not ".concat(key, "."));
          this.items[idx] = value;
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var seq2 = [];
          if (ctx && ctx.onCreate)
            ctx.onCreate(seq2);
          var i2 = 0;
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var item = _step.value;
              seq2.push(toJSON(item, String(i2++), ctx));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return seq2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          return _get(_getPrototypeOf(YAMLSeq2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n2) {
              return n2.type === "comment" ? n2.str : "- ".concat(n2.str);
            },
            flowChars: {
              start: "[",
              end: "]"
            },
            isMap: false,
            itemIndent: (ctx.indent || "") + "  "
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLSeq2;
    }(Collection2);
    stringifyKey = function stringifyKey2(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (_typeof(jsKey) !== "object")
        return String(jsKey);
      if (key instanceof Node2 && ctx && ctx.doc)
        return key.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    Pair = function(_Node) {
      _inherits(Pair2, _Node);
      var _super = _createSuper(Pair2);
      function Pair2(key) {
        var _this;
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Pair2);
        _this = _super.call(this);
        _this.key = key;
        _this.value = value;
        _this.type = Pair2.Type.PAIR;
        return _this;
      }
      _createClass(Pair2, [{
        key: "commentBefore",
        get: function get() {
          return this.key instanceof Node2 ? this.key.commentBefore : void 0;
        },
        set: function set2(cb) {
          if (this.key == null)
            this.key = new Scalar(null);
          if (this.key instanceof Node2)
            this.key.commentBefore = cb;
          else {
            var msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
            throw new Error(msg);
          }
        }
      }, {
        key: "addToJSMap",
        value: function addToJSMap(ctx, map2) {
          var key = toJSON(this.key, "", ctx);
          if (map2 instanceof Map) {
            var value = toJSON(this.value, key, ctx);
            map2.set(key, value);
          } else if (map2 instanceof Set) {
            map2.add(key);
          } else {
            var stringKey = stringifyKey(this.key, key, ctx);
            var _value = toJSON(this.value, stringKey, ctx);
            if (stringKey in map2)
              Object.defineProperty(map2, stringKey, {
                value: _value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            else
              map2[stringKey] = _value;
          }
          return map2;
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          var pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          return this.addToJSMap(ctx, pair);
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx || !ctx.doc)
            return JSON.stringify(this);
          var _ctx$doc$options = ctx.doc.options, indentSize = _ctx$doc$options.indent, indentSeq = _ctx$doc$options.indentSeq, simpleKeys = _ctx$doc$options.simpleKeys;
          var key = this.key, value = this.value;
          var keyComment = key instanceof Node2 && key.comment;
          if (simpleKeys) {
            if (keyComment) {
              throw new Error("With simple keys, key nodes cannot have comments");
            }
            if (key instanceof Collection2) {
              var msg = "With simple keys, collection cannot be used as a key value";
              throw new Error(msg);
            }
          }
          var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node2 ? key instanceof Collection2 || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === "object"));
          var _ctx = ctx, doc = _ctx.doc, indent = _ctx.indent, indentStep = _ctx.indentStep, stringify17 = _ctx.stringify;
          ctx = Object.assign({}, ctx, {
            implicitKey: !explicitKey,
            indent: indent + indentStep
          });
          var chompKeep = false;
          var str = stringify17(key, ctx, function() {
            return keyComment = null;
          }, function() {
            return chompKeep = true;
          });
          str = addComment(str, ctx.indent, keyComment);
          if (!explicitKey && str.length > 1024) {
            if (simpleKeys)
              throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
            explicitKey = true;
          }
          if (ctx.allNullValues && !simpleKeys) {
            if (this.comment) {
              str = addComment(str, ctx.indent, this.comment);
              if (onComment)
                onComment();
            } else if (chompKeep && !keyComment && onChompKeep)
              onChompKeep();
            return ctx.inFlow && !explicitKey ? str : "? ".concat(str);
          }
          str = explicitKey ? "? ".concat(str, "\n").concat(indent, ":") : "".concat(str, ":");
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          }
          var vcb = "";
          var valueComment = null;
          if (value instanceof Node2) {
            if (value.spaceBefore)
              vcb = "\n";
            if (value.commentBefore) {
              var cs = value.commentBefore.replace(/^/gm, "".concat(ctx.indent, "#"));
              vcb += "\n".concat(cs);
            }
            valueComment = value.comment;
          } else if (value && _typeof(value) === "object") {
            value = doc.schema.createNode(value, true);
          }
          ctx.implicitKey = false;
          if (!explicitKey && !this.comment && value instanceof Scalar)
            ctx.indentAtStart = str.length + 1;
          chompKeep = false;
          if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
            ctx.indent = ctx.indent.substr(2);
          }
          var valueStr = stringify17(value, ctx, function() {
            return valueComment = null;
          }, function() {
            return chompKeep = true;
          });
          var ws = " ";
          if (vcb || this.comment) {
            ws = "".concat(vcb, "\n").concat(ctx.indent);
          } else if (!explicitKey && value instanceof Collection2) {
            var flow = valueStr[0] === "[" || valueStr[0] === "{";
            if (!flow || valueStr.includes("\n"))
              ws = "\n".concat(ctx.indent);
          } else if (valueStr[0] === "\n")
            ws = "";
          if (chompKeep && !valueComment && onChompKeep)
            onChompKeep();
          return addComment(str + ws + valueStr, ctx.indent, valueComment);
        }
      }]);
      return Pair2;
    }(Node2);
    _defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    getAliasCount = function getAliasCount2(node, anchors) {
      if (node instanceof Alias2) {
        var anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection2) {
        var count = 0;
        var _iterator = _createForOfIteratorHelper(node.items), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            var c2 = getAliasCount2(item, anchors);
            if (c2 > count)
              count = c2;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return count;
      } else if (node instanceof Pair) {
        var kc = getAliasCount2(node.key, anchors);
        var vc = getAliasCount2(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    Alias2 = function(_Node) {
      _inherits(Alias3, _Node);
      var _super = _createSuper(Alias3);
      function Alias3(source) {
        var _this;
        _classCallCheck(this, Alias3);
        _this = _super.call(this);
        _this.source = source;
        _this.type = Type.ALIAS;
        return _this;
      }
      _createClass(Alias3, [{
        key: "tag",
        set: function set2(t2) {
          throw new Error("Alias nodes cannot have tags");
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, ctx) {
          if (!ctx)
            return toJSON(this.source, arg, ctx);
          var anchors = ctx.anchors, maxAliasCount = ctx.maxAliasCount;
          var anchor = anchors.get(this.source);
          if (!anchor || anchor.res === void 0) {
            var msg = "This should not happen: Alias anchor was not resolved?";
            if (this.cstNode)
              throw new YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
          if (maxAliasCount >= 0) {
            anchor.count += 1;
            if (anchor.aliasCount === 0)
              anchor.aliasCount = getAliasCount(this.source, anchors);
            if (anchor.count * anchor.aliasCount > maxAliasCount) {
              var _msg = "Excessive alias count indicates a resource exhaustion attack";
              if (this.cstNode)
                throw new YAMLReferenceError(this.cstNode, _msg);
              else
                throw new ReferenceError(_msg);
            }
          }
          return anchor.res;
        }
      }, {
        key: "toString",
        value: function toString(ctx) {
          return Alias3.stringify(this, ctx);
        }
      }], [{
        key: "stringify",
        value: function stringify17(_ref, _ref2) {
          var range = _ref.range, source = _ref.source;
          var anchors = _ref2.anchors, doc = _ref2.doc, implicitKey = _ref2.implicitKey, inStringifyKey = _ref2.inStringifyKey;
          var anchor = Object.keys(anchors).find(function(a2) {
            return anchors[a2] === source;
          });
          if (!anchor && inStringifyKey)
            anchor = doc.anchors.getName(source) || doc.anchors.newName();
          if (anchor)
            return "*".concat(anchor).concat(implicitKey ? " " : "");
          var msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
          throw new Error("".concat(msg, " [").concat(range, "]"));
        }
      }]);
      return Alias3;
    }(Node2);
    _defineProperty(Alias2, "default", true);
    YAMLMap = function(_Collection) {
      _inherits(YAMLMap2, _Collection);
      var _super = _createSuper(YAMLMap2);
      function YAMLMap2() {
        _classCallCheck(this, YAMLMap2);
        return _super.apply(this, arguments);
      }
      _createClass(YAMLMap2, [{
        key: "add",
        value: function add(pair, overwrite) {
          if (!pair)
            pair = new Pair(pair);
          else if (!(pair instanceof Pair))
            pair = new Pair(pair.key || pair, pair.value);
          var prev = findPair(this.items, pair.key);
          var sortEntries = this.schema && this.schema.sortMapEntries;
          if (prev) {
            if (overwrite)
              prev.value = pair.value;
            else
              throw new Error("Key ".concat(pair.key, " already set"));
          } else if (sortEntries) {
            var i2 = this.items.findIndex(function(item) {
              return sortEntries(pair, item) < 0;
            });
            if (i2 === -1)
              this.items.push(pair);
            else
              this.items.splice(i2, 0, pair);
          } else {
            this.items.push(pair);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var it = findPair(this.items, key);
          if (!it)
            return false;
          var del = this.items.splice(this.items.indexOf(it), 1);
          return del.length > 0;
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          var it = findPair(this.items, key);
          var node = it && it.value;
          return !keepScalar && node instanceof Scalar ? node.value : node;
        }
      }, {
        key: "has",
        value: function has(key) {
          return !!findPair(this.items, key);
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          this.add(new Pair(key, value), true);
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx, Type2) {
          var map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
          if (ctx && ctx.onCreate)
            ctx.onCreate(map2);
          var _iterator2 = _createForOfIteratorHelper(this.items), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var item = _step2.value;
              item.addToJSMap(ctx, map2);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return map2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          var _iterator3 = _createForOfIteratorHelper(this.items), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var item = _step3.value;
              if (!(item instanceof Pair))
                throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(item), " instead"));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return _get(_getPrototypeOf(YAMLMap2.prototype), "toString", this).call(this, ctx, {
            blockItem: function blockItem(n2) {
              return n2.str;
            },
            flowChars: {
              start: "{",
              end: "}"
            },
            isMap: true,
            itemIndent: ctx.indent || ""
          }, onComment, onChompKeep);
        }
      }]);
      return YAMLMap2;
    }(Collection2);
    MERGE_KEY = "<<";
    Merge = function(_Pair) {
      _inherits(Merge2, _Pair);
      var _super = _createSuper(Merge2);
      function Merge2(pair) {
        var _this;
        _classCallCheck(this, Merge2);
        if (pair instanceof Pair) {
          var seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          _this = _super.call(this, pair.key, seq2);
          _this.range = pair.range;
        } else {
          _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());
        }
        _this.type = Pair.Type.MERGE_PAIR;
        return _possibleConstructorReturn(_this);
      }
      _createClass(Merge2, [{
        key: "addToJSMap",
        value: function addToJSMap(ctx, map2) {
          var _iterator = _createForOfIteratorHelper(this.value.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var source = _step.value.source;
              if (!(source instanceof YAMLMap))
                throw new Error("Merge sources must be maps");
              var srcMap = source.toJSON(null, ctx, Map);
              var _iterator2 = _createForOfIteratorHelper(srcMap), _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], value = _step2$value[1];
                  if (map2 instanceof Map) {
                    if (!map2.has(key))
                      map2.set(key, value);
                  } else if (map2 instanceof Set) {
                    map2.add(key);
                  } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
                    Object.defineProperty(map2, key, {
                      value,
                      writable: true,
                      enumerable: true,
                      configurable: true
                    });
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map2;
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment) {
          var seq2 = this.value;
          if (seq2.items.length > 1)
            return _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2.items[0];
          var str = _get(_getPrototypeOf(Merge2.prototype), "toString", this).call(this, ctx, onComment);
          this.value = seq2;
          return str;
        }
      }]);
      return Merge2;
    }(Pair);
    binaryOptions = {
      defaultType: Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    intOptions = {
      asBigInt: false
    };
    nullOptions = {
      nullStr: "null"
    };
    strOptions = {
      defaultType: Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    consumeMoreIndentedLines = function consumeMoreIndentedLines2(text, i2) {
      var ch = text[i2 + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i2 += 1];
        } while (ch && ch !== "\n");
        ch = text[i2 + 1];
      }
      return i2;
    };
    getFoldOptions = function getFoldOptions2(_ref) {
      var indentAtStart = _ref.indentAtStart;
      return indentAtStart ? Object.assign({
        indentAtStart
      }, strOptions.fold) : strOptions.fold;
    };
    containsDocumentMarker = function containsDocumentMarker2(str) {
      return /^(%|---|\.\.\.)/m.test(str);
    };
    isCollectionItem = function isCollectionItem2(node) {
      if (!node)
        return false;
      var type = node.type;
      return type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM;
    };
    valueHasPairComment = function valueHasPairComment2(_ref2) {
      var _ref2$context = _ref2.context, lineStart = _ref2$context.lineStart, node = _ref2$context.node, src = _ref2$context.src, props = _ref2.props;
      if (props.length === 0)
        return false;
      var start = props[0].start;
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== Char.COMMENT)
        return false;
      for (var i2 = lineStart; i2 < start; ++i2) {
        if (src[i2] === "\n")
          return false;
      }
      return true;
    };
  }
});

// node_modules/yaml/browser/dist/warnings-df54cb69.js
function parsePairs(doc, cst) {
  var seq2 = resolveSeq(doc, cst);
  for (var i2 = 0; i2 < seq2.items.length; ++i2) {
    var item = seq2.items[i2];
    if (item instanceof Pair)
      continue;
    else if (item instanceof YAMLMap) {
      if (item.items.length > 1) {
        var msg = "Each pair must have its own sequence indicator";
        throw new YAMLSemanticError(cst, msg);
      }
      var pair = item.items[0] || new Pair();
      if (item.commentBefore)
        pair.commentBefore = pair.commentBefore ? "".concat(item.commentBefore, "\n").concat(pair.commentBefore) : item.commentBefore;
      if (item.comment)
        pair.comment = pair.comment ? "".concat(item.comment, "\n").concat(pair.comment) : item.comment;
      item = pair;
    }
    seq2.items[i2] = item instanceof Pair ? item : new Pair(item);
  }
  return seq2;
}
function createPairs(schema, iterable, ctx) {
  var pairs2 = new YAMLSeq(schema);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var it = _step.value;
      var key = void 0, value = void 0;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError("Expected [key, value] tuple: ".concat(it));
      } else if (it && it instanceof Object) {
        var keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError("Expected { key: value } tuple: ".concat(it));
      } else {
        key = it;
      }
      var pair = schema.createPair(key, value, ctx);
      pairs2.items.push(pair);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return pairs2;
}
function parseOMap(doc, cst) {
  var pairs2 = parsePairs(doc, cst);
  var seenKeys = [];
  var _iterator2 = _createForOfIteratorHelper(pairs2.items), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var key = _step2.value.key;
      if (key instanceof Scalar) {
        if (seenKeys.includes(key.value)) {
          var msg = "Ordered maps must not include duplicate keys";
          throw new YAMLSemanticError(cst, msg);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return Object.assign(new YAMLOMap(), pairs2);
}
function createOMap(schema, iterable, ctx) {
  var pairs2 = createPairs(schema, iterable, ctx);
  var omap2 = new YAMLOMap();
  omap2.items = pairs2.items;
  return omap2;
}
function parseSet(doc, cst) {
  var map2 = resolveMap(doc, cst);
  if (!map2.hasAllNullValues())
    throw new YAMLSemanticError(cst, "Set items must all have null values");
  return Object.assign(new YAMLSet(), map2);
}
function createSet(schema, iterable, ctx) {
  var set2 = new YAMLSet();
  var _iterator = _createForOfIteratorHelper(iterable), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var value = _step.value;
      set2.items.push(schema.createPair(value, null, ctx));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return set2;
}
function shouldWarn(deprecation) {
  var env = typeof process !== "undefined" && process.env || {};
  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
      return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }
  if (typeof YAML_SILENCE_WARNINGS !== "undefined")
    return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}
function warn(warning, type) {
  if (shouldWarn(false)) {
    var emit = typeof process !== "undefined" && process.emitWarning;
    if (emit)
      emit(warning, type);
    else {
      console.warn(type ? "".concat(type, ": ").concat(warning) : warning);
    }
  }
}
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    var msg = "The option '".concat(name, "' will be removed in a future release");
    msg += alternative ? ", use '".concat(alternative, "' instead.") : ".";
    warn(msg, "DeprecationWarning");
  }
}
var binary, pairs, YAMLOMap, omap, YAMLSet, set, parseSexagesimal, stringifySexagesimal, intTime, floatTime, timestamp, warned;
var init_warnings_df54cb69 = __esm({
  "node_modules/yaml/browser/dist/warnings-df54cb69.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    binary = {
      identify: function identify(value) {
        return value instanceof Uint8Array;
      },
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: function resolve(doc, node) {
        var src = resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          var str = atob(src.replace(/[\n\r]/g, ""));
          var buffer = new Uint8Array(str.length);
          for (var i2 = 0; i2 < str.length; ++i2) {
            buffer[i2] = str.charCodeAt(i2);
          }
          return buffer;
        } else {
          var msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: binaryOptions,
      stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
        var comment = _ref.comment, type = _ref.type, value = _ref.value;
        var src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          var s2 = "";
          for (var i2 = 0; i2 < value.length; ++i2) {
            s2 += String.fromCharCode(value[i2]);
          }
          src = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = binaryOptions.defaultType;
        if (type === Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          var lineWidth = binaryOptions.lineWidth;
          var n2 = Math.ceil(src.length / lineWidth);
          var lines = new Array(n2);
          for (var _i = 0, o2 = 0; _i < n2; ++_i, o2 += lineWidth) {
            lines[_i] = src.substr(o2, lineWidth);
          }
          value = lines.join(type === Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    YAMLOMap = function(_YAMLSeq) {
      _inherits(YAMLOMap2, _YAMLSeq);
      var _super = _createSuper(YAMLOMap2);
      function YAMLOMap2() {
        var _this;
        _classCallCheck(this, YAMLOMap2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "add", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "delete", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "get", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "has", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));
        _defineProperty(_assertThisInitialized(_this), "set", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));
        _this.tag = YAMLOMap2.tag;
        return _this;
      }
      _createClass(YAMLOMap2, [{
        key: "toJSON",
        value: function toJSON$1(_, ctx) {
          var map2 = /* @__PURE__ */ new Map();
          if (ctx && ctx.onCreate)
            ctx.onCreate(map2);
          var _iterator = _createForOfIteratorHelper(this.items), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var pair = _step.value;
              var key = void 0, value = void 0;
              if (pair instanceof Pair) {
                key = toJSON(pair.key, "", ctx);
                value = toJSON(pair.value, key, ctx);
              } else {
                key = toJSON(pair, "", ctx);
              }
              if (map2.has(key))
                throw new Error("Ordered maps must not include duplicate keys");
              map2.set(key, value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return map2;
        }
      }]);
      return YAMLOMap2;
    }(YAMLSeq);
    _defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    omap = {
      identify: function identify2(value) {
        return value instanceof Map;
      },
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    YAMLSet = function(_YAMLMap) {
      _inherits(YAMLSet2, _YAMLMap);
      var _super = _createSuper(YAMLSet2);
      function YAMLSet2() {
        var _this;
        _classCallCheck(this, YAMLSet2);
        _this = _super.call(this);
        _this.tag = YAMLSet2.tag;
        return _this;
      }
      _createClass(YAMLSet2, [{
        key: "add",
        value: function add(key) {
          var pair = key instanceof Pair ? key : new Pair(key);
          var prev = findPair(this.items, pair.key);
          if (!prev)
            this.items.push(pair);
        }
      }, {
        key: "get",
        value: function get(key, keepPair) {
          var pair = findPair(this.items, key);
          return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          if (typeof value !== "boolean")
            throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(_typeof(value)));
          var prev = findPair(this.items, key);
          if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
          } else if (!prev && value) {
            this.items.push(new Pair(key));
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON2(_, ctx) {
          return _get(_getPrototypeOf(YAMLSet2.prototype), "toJSON", this).call(this, _, ctx, Set);
        }
      }, {
        key: "toString",
        value: function toString(ctx, onComment, onChompKeep) {
          if (!ctx)
            return JSON.stringify(this);
          if (this.hasAllNullValues())
            return _get(_getPrototypeOf(YAMLSet2.prototype), "toString", this).call(this, ctx, onComment, onChompKeep);
          else
            throw new Error("Set items must all have null values");
        }
      }]);
      return YAMLSet2;
    }(YAMLMap);
    _defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    set = {
      identify: function identify3(value) {
        return value instanceof Set;
      },
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    parseSexagesimal = function parseSexagesimal2(sign, parts) {
      var n2 = parts.split(":").reduce(function(n3, p2) {
        return n3 * 60 + Number(p2);
      }, 0);
      return sign === "-" ? -n2 : n2;
    };
    stringifySexagesimal = function stringifySexagesimal2(_ref) {
      var value = _ref.value;
      if (isNaN(value) || !isFinite(value))
        return stringifyNumber(value);
      var sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      var parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map(function(n2) {
        return n2 < 10 ? "0" + String(n2) : String(n2);
      }).join(":").replace(/000000\d*$/, "");
    };
    intTime = {
      identify: function identify4(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: function resolve2(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: function identify5(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: function resolve3(str, sign, parts) {
        return parseSexagesimal(sign, parts.replace(/_/g, ""));
      },
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: function identify6(value) {
        return value instanceof Date;
      },
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: function resolve4(str, year, month, day, hour, minute, second, millisec, tz) {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          var d2 = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d2) < 30)
            d2 *= 60;
          date -= 6e4 * d2;
        }
        return new Date(date);
      },
      stringify: function stringify2(_ref2) {
        var value = _ref2.value;
        return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
      }
    };
    warned = {};
  }
});

// node_modules/yaml/browser/dist/Schema-e94716c8.js
function createMap(schema, obj, ctx) {
  var map2 = new YAMLMap(schema);
  if (obj instanceof Map) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
        map2.items.push(schema.createPair(key, value, ctx));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (obj && _typeof(obj) === "object") {
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      map2.items.push(schema.createPair(_key, obj[_key], ctx));
    }
  }
  if (typeof schema.sortMapEntries === "function") {
    map2.items.sort(schema.sortMapEntries);
  }
  return map2;
}
function createSeq(schema, obj, ctx) {
  var seq2 = new YAMLSeq(schema);
  if (obj && obj[Symbol.iterator]) {
    var _iterator = _createForOfIteratorHelper(obj), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var it = _step.value;
        var v2 = schema.createNode(it, ctx.wrapScalars, null, ctx);
        seq2.items.push(v2);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return seq2;
}
function intStringify$1(node, radix, prefix) {
  var value = node.value;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
function intResolve2(sign, src, radix) {
  var str = src.replace(/_/g, "");
  if (intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = "0b".concat(str);
        break;
      case 8:
        str = "0o".concat(str);
        break;
      case 16:
        str = "0x".concat(str);
        break;
    }
    var _n = BigInt(str);
    return sign === "-" ? BigInt(-1) * _n : _n;
  }
  var n2 = parseInt(str, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify(node, radix, prefix) {
  var value = node.value;
  if (intIdentify3(value)) {
    var str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
function findTagObject(value, tagName, tags2) {
  if (tagName) {
    var match = tags2.filter(function(t2) {
      return t2.tag === tagName;
    });
    var tagObj = match.find(function(t2) {
      return !t2.format;
    }) || match[0];
    if (!tagObj)
      throw new Error("Tag ".concat(tagName, " not found"));
    return tagObj;
  }
  return tags2.find(function(t2) {
    return (t2.identify && t2.identify(value) || t2.class && value instanceof t2.class) && !t2.format;
  });
}
function createNode4(value, tagName, ctx) {
  if (value instanceof Node2)
    return value;
  var defaultPrefix = ctx.defaultPrefix, onTagObj = ctx.onTagObj, prevObjects = ctx.prevObjects, schema = ctx.schema, wrapScalars = ctx.wrapScalars;
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultPrefix + tagName.slice(2);
  var tagObj = findTagObject(value, tagName, schema.tags);
  if (!tagObj) {
    if (typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || _typeof(value) !== "object")
      return wrapScalars ? new Scalar(value) : value;
    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  var obj = {
    value: void 0,
    node: void 0
  };
  if (value && _typeof(value) === "object" && prevObjects) {
    var prev = prevObjects.get(value);
    if (prev) {
      var alias = new Alias2(prev);
      ctx.aliasNodes.push(alias);
      return alias;
    }
    obj.value = value;
    prevObjects.set(value, obj);
  }
  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;
  if (tagName && obj.node instanceof Node2)
    obj.node.tag = tagName;
  return obj.node;
}
function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
  var tags2 = schemas2[schemaId.replace(/\W/g, "")];
  if (!tags2) {
    var keys = Object.keys(schemas2).map(function(key) {
      return JSON.stringify(key);
    }).join(", ");
    throw new Error('Unknown schema "'.concat(schemaId, '"; use one of ').concat(keys));
  }
  if (Array.isArray(customTags)) {
    var _iterator = _createForOfIteratorHelper(customTags), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var tag = _step.value;
        tags2 = tags2.concat(tag);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  for (var i2 = 0; i2 < tags2.length; ++i2) {
    var _tag = tags2[i2];
    if (typeof _tag === "string") {
      var tagObj = knownTags[_tag];
      if (!tagObj) {
        var _keys = Object.keys(knownTags).map(function(key) {
          return JSON.stringify(key);
        }).join(", ");
        throw new Error('Unknown custom tag "'.concat(_tag, '"; use one of ').concat(_keys));
      }
      tags2[i2] = tagObj;
    }
  }
  return tags2;
}
var map, seq, string, failsafe, intIdentify$2, intResolve$1, nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj, core, intIdentify$1, stringifyJSON, json, boolStringify, intIdentify3, yaml11, schemas, tags, sortMapEntriesByKey, Schema;
var init_Schema_e94716c8 = __esm({
  "node_modules/yaml/browser/dist/Schema-e94716c8.js"() {
    init_PlainValue_b8036b75();
    init_resolveSeq_492ab440();
    init_warnings_df54cb69();
    map = {
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveMap
    };
    seq = {
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq
    };
    string = {
      identify: function identify7(value) {
        return typeof value === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: function stringify3(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: strOptions
    };
    failsafe = [map, seq, string];
    intIdentify$2 = function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    intResolve$1 = function intResolve(src, part, radix) {
      return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    };
    nullObj = {
      identify: function identify8(value) {
        return value == null;
      },
      createNode: function createNode(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve5() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify4() {
        return nullOptions.nullStr;
      }
    };
    boolObj = {
      identify: function identify9(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: function resolve6(str) {
        return str[0] === "t" || str[0] === "T";
      },
      options: boolOptions,
      stringify: function stringify5(_ref) {
        var value = _ref.value;
        return value ? boolOptions.trueStr : boolOptions.falseStr;
      }
    };
    octObj = {
      identify: function identify10(value) {
        return intIdentify$2(value) && value >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: function resolve7(str, oct) {
        return intResolve$1(str, oct, 8);
      },
      options: intOptions,
      stringify: function stringify6(node) {
        return intStringify$1(node, 8, "0o");
      }
    };
    intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: function resolve8(str) {
        return intResolve$1(str, str, 10);
      },
      options: intOptions,
      stringify: stringifyNumber
    };
    hexObj = {
      identify: function identify11(value) {
        return intIdentify$2(value) && value >= 0;
      },
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: function resolve9(str, hex) {
        return intResolve$1(str, hex, 16);
      },
      options: intOptions,
      stringify: function stringify7(node) {
        return intStringify$1(node, 16, "0x");
      }
    };
    nanObj = {
      identify: function identify12(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve10(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    };
    expObj = {
      identify: function identify13(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: function resolve11(str) {
        return parseFloat(str);
      },
      stringify: function stringify8(_ref2) {
        var value = _ref2.value;
        return Number(value).toExponential();
      }
    };
    floatObj = {
      identify: function identify14(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve: function resolve12(str, frac1, frac2) {
        var frac = frac1 || frac2;
        var node = new Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: stringifyNumber
    };
    core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    intIdentify$1 = function intIdentify2(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    stringifyJSON = function stringifyJSON2(_ref) {
      var value = _ref.value;
      return JSON.stringify(value);
    };
    json = [map, seq, {
      identify: function identify15(value) {
        return typeof value === "string";
      },
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveString,
      stringify: stringifyJSON
    }, {
      identify: function identify16(value) {
        return value == null;
      },
      createNode: function createNode2(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: function resolve13() {
        return null;
      },
      stringify: stringifyJSON
    }, {
      identify: function identify17(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: function resolve14(str) {
        return str === "true";
      },
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: function resolve15(str) {
        return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);
      },
      stringify: function stringify9(_ref2) {
        var value = _ref2.value;
        return intIdentify$1(value) ? value.toString() : JSON.stringify(value);
      }
    }, {
      identify: function identify18(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: function resolve16(str) {
        return parseFloat(str);
      },
      stringify: stringifyJSON
    }];
    json.scalarFallback = function(str) {
      throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(str)));
    };
    boolStringify = function boolStringify2(_ref) {
      var value = _ref.value;
      return value ? boolOptions.trueStr : boolOptions.falseStr;
    };
    intIdentify3 = function intIdentify4(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    };
    yaml11 = failsafe.concat([{
      identify: function identify19(value) {
        return value == null;
      },
      createNode: function createNode3(schema, value, ctx) {
        return ctx.wrapScalars ? new Scalar(null) : null;
      },
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: function resolve17() {
        return null;
      },
      options: nullOptions,
      stringify: function stringify10() {
        return nullOptions.nullStr;
      }
    }, {
      identify: function identify20(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: function resolve18() {
        return true;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: function identify21(value) {
        return typeof value === "boolean";
      },
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: function resolve19() {
        return false;
      },
      options: boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: function resolve20(str, sign, bin) {
        return intResolve2(sign, bin, 2);
      },
      stringify: function stringify11(node) {
        return intStringify(node, 2, "0b");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: function resolve21(str, sign, oct) {
        return intResolve2(sign, oct, 8);
      },
      stringify: function stringify12(node) {
        return intStringify(node, 8, "0");
      }
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: function resolve22(str, sign, abs) {
        return intResolve2(sign, abs, 10);
      },
      stringify: stringifyNumber
    }, {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: function resolve23(str, sign, hex) {
        return intResolve2(sign, hex, 16);
      },
      stringify: function stringify13(node) {
        return intStringify(node, 16, "0x");
      }
    }, {
      identify: function identify22(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: function resolve24(str, nan) {
        return nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      },
      stringify: stringifyNumber
    }, {
      identify: function identify23(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: function resolve25(str) {
        return parseFloat(str.replace(/_/g, ""));
      },
      stringify: function stringify14(_ref2) {
        var value = _ref2.value;
        return Number(value).toExponential();
      }
    }, {
      identify: function identify24(value) {
        return typeof value === "number";
      },
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve: function resolve26(str, frac) {
        var node = new Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          var f2 = frac.replace(/_/g, "");
          if (f2[f2.length - 1] === "0")
            node.minFractionDigits = f2.length;
        }
        return node;
      },
      stringify: stringifyNumber
    }], binary, omap, pairs, set, intTime, floatTime, timestamp);
    schemas = {
      core,
      failsafe,
      json,
      yaml11
    };
    tags = {
      binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime,
      map,
      null: nullObj,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    sortMapEntriesByKey = function sortMapEntriesByKey2(a2, b2) {
      return a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
    };
    Schema = function() {
      function Schema2(_ref) {
        var customTags = _ref.customTags, merge = _ref.merge, schema = _ref.schema, sortMapEntries = _ref.sortMapEntries, deprecatedCustomTags = _ref.tags;
        _classCallCheck(this, Schema2);
        this.merge = !!merge;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      _createClass(Schema2, [{
        key: "createNode",
        value: function createNode$1(value, wrapScalars, tagName, ctx) {
          var baseCtx = {
            defaultPrefix: Schema2.defaultPrefix,
            schema: this,
            wrapScalars
          };
          var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
          return createNode4(value, tagName, createCtx);
        }
      }, {
        key: "createPair",
        value: function createPair(key, value, ctx) {
          if (!ctx)
            ctx = {
              wrapScalars: true
            };
          var k2 = this.createNode(key, ctx.wrapScalars, null, ctx);
          var v2 = this.createNode(value, ctx.wrapScalars, null, ctx);
          return new Pair(k2, v2);
        }
      }]);
      return Schema2;
    }();
    _defineProperty(Schema, "defaultPrefix", defaultTagPrefix);
    _defineProperty(Schema, "defaultTags", defaultTags);
  }
});

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  YAML: () => YAML
});
function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === "1.0") {
    var priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv)
      return "!" + priv[1];
    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? "!".concat(vocab[1], "/").concat(vocab[2]) : "!".concat(tag.replace(/^tag:/, ""));
  }
  var p2 = doc.tagPrefixes.find(function(p3) {
    return tag.indexOf(p3.prefix) === 0;
  });
  if (!p2) {
    var dtp = doc.getDefaults().tagPrefixes;
    p2 = dtp && dtp.find(function(p3) {
      return tag.indexOf(p3.prefix) === 0;
    });
  }
  if (!p2)
    return tag[0] === "!" ? tag : "!<".concat(tag, ">");
  var suffix = tag.substr(p2.prefix.length).replace(/[!,[\]{}]/g, function(ch) {
    return {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }[ch];
  });
  return p2.handle + suffix;
}
function getTagObject(tags2, item) {
  if (item instanceof Alias2)
    return Alias2;
  if (item.tag) {
    var match = tags2.filter(function(t2) {
      return t2.tag === item.tag;
    });
    if (match.length > 0)
      return match.find(function(t2) {
        return t2.format === item.format;
      }) || match[0];
  }
  var tagObj, obj;
  if (item instanceof Scalar) {
    obj = item.value;
    var _match = tags2.filter(function(t2) {
      return t2.identify && t2.identify(obj) || t2.class && obj instanceof t2.class;
    });
    tagObj = _match.find(function(t2) {
      return t2.format === item.format;
    }) || _match.find(function(t2) {
      return !t2.format;
    });
  } else {
    obj = item;
    tagObj = tags2.find(function(t2) {
      return t2.nodeClass && obj instanceof t2.nodeClass;
    });
  }
  if (!tagObj) {
    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);
    throw new Error("Tag not resolved for ".concat(name, " value"));
  }
  return tagObj;
}
function stringifyProps(node, tagObj, _ref) {
  var anchors = _ref.anchors, doc = _ref.doc;
  var props = [];
  var anchor = doc.anchors.getName(node);
  if (anchor) {
    anchors[anchor] = node;
    props.push("&".concat(anchor));
  }
  if (node.tag) {
    props.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }
  return props.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
  var _ctx$doc = ctx.doc, anchors = _ctx$doc.anchors, schema = _ctx$doc.schema;
  var tagObj;
  if (!(item instanceof Node2)) {
    var createCtx = {
      aliasNodes: [],
      onTagObj: function onTagObj(o2) {
        return tagObj = o2;
      },
      prevObjects: /* @__PURE__ */ new Map()
    };
    item = schema.createNode(item, true, null, createCtx);
    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var alias = _step.value;
        alias.source = alias.source.node;
        var name = anchors.getName(alias.source);
        if (!name) {
          name = anchors.newName();
          anchors.map[name] = alias.source;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (item instanceof Pair)
    return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj)
    tagObj = getTagObject(schema.tags, item);
  var props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  var str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return item instanceof Scalar || str[0] === "{" || str[0] === "[" ? "".concat(props, " ").concat(str) : "".concat(props, "\n").concat(ctx.indent).concat(str);
}
function parseContents(doc, contents) {
  var comments = {
    before: [],
    after: []
  };
  var body = void 0;
  var spaceBefore = false;
  var _iterator = _createForOfIteratorHelper(contents), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var node = _step.value;
      if (node.valueRange) {
        if (body !== void 0) {
          var msg = "Document contains trailing content not separated by a ... or --- line";
          doc.errors.push(new YAMLSyntaxError(node, msg));
          break;
        }
        var res = resolveNode(doc, node);
        if (spaceBefore) {
          res.spaceBefore = true;
          spaceBefore = false;
        }
        body = res;
      } else if (node.comment !== null) {
        var cc = body === void 0 ? comments.before : comments.after;
        cc.push(node.comment);
      } else if (node.type === Type.BLANK_LINE) {
        spaceBefore = true;
        if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
          doc.commentBefore = comments.before.join("\n");
          comments.before = [];
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  doc.contents = body || null;
  if (!body) {
    doc.comment = comments.before.concat(comments.after).join("\n") || null;
  } else {
    var cb = comments.before.join("\n");
    if (cb) {
      var cbNode = body instanceof Collection2 && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? "".concat(cb, "\n").concat(cbNode.commentBefore) : cb;
    }
    doc.comment = comments.after.join("\n") || null;
  }
}
function resolveTagDirective(_ref, directive) {
  var tagPrefixes = _ref.tagPrefixes;
  var _directive$parameters = _slicedToArray(directive.parameters, 2), handle = _directive$parameters[0], prefix = _directive$parameters[1];
  if (!handle || !prefix) {
    var msg = "Insufficient parameters given for %TAG directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (tagPrefixes.some(function(p2) {
    return p2.handle === handle;
  })) {
    var _msg = "The %TAG directive must only be given at most once per handle in the same document.";
    throw new YAMLSemanticError(directive, _msg);
  }
  return {
    handle,
    prefix
  };
}
function resolveYamlDirective(doc, directive) {
  var _directive$parameters2 = _slicedToArray(directive.parameters, 1), version = _directive$parameters2[0];
  if (directive.name === "YAML:1.0")
    version = "1.0";
  if (!version) {
    var msg = "Insufficient parameters given for %YAML directive";
    throw new YAMLSemanticError(directive, msg);
  }
  if (!documentOptions[version]) {
    var v0 = doc.version || doc.options.version;
    var _msg2 = "Document will be parsed as YAML ".concat(v0, " rather than YAML ").concat(version);
    doc.warnings.push(new YAMLWarning(directive, _msg2));
  }
  return version;
}
function parseDirectives(doc, directives, prevDoc) {
  var directiveComments = [];
  var hasDirectives = false;
  var _iterator = _createForOfIteratorHelper(directives), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var directive = _step.value;
      var comment = directive.comment, name = directive.name;
      switch (name) {
        case "TAG":
          try {
            doc.tagPrefixes.push(resolveTagDirective(doc, directive));
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        case "YAML":
        case "YAML:1.0":
          if (doc.version) {
            var msg = "The %YAML directive must only be given at most once per document.";
            doc.errors.push(new YAMLSemanticError(directive, msg));
          }
          try {
            doc.version = resolveYamlDirective(doc, directive);
          } catch (error) {
            doc.errors.push(error);
          }
          hasDirectives = true;
          break;
        default:
          if (name) {
            var _msg3 = "YAML only supports %TAG and %YAML directives, and not %".concat(name);
            doc.warnings.push(new YAMLWarning(directive, _msg3));
          }
      }
      if (comment)
        directiveComments.push(comment);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
    var copyTagPrefix = function copyTagPrefix2(_ref2) {
      var handle = _ref2.handle, prefix = _ref2.prefix;
      return {
        handle,
        prefix
      };
    };
    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }
  doc.commentBefore = directiveComments.join("\n") || null;
}
function assertCollection(contents) {
  if (contents instanceof Collection2)
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function createNode5(value) {
  var wrapScalars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var tag = arguments.length > 2 ? arguments[2] : void 0;
  if (tag === void 0 && typeof wrapScalars === "string") {
    tag = wrapScalars;
    wrapScalars = true;
  }
  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);
  var schema = new Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}
function parseAllDocuments(src, options) {
  var stream = [];
  var prev;
  var _iterator = _createForOfIteratorHelper(parse(src)), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var cstDoc = _step.value;
      var doc = new Document2(options);
      doc.parse(cstDoc, prev);
      stream.push(doc);
      prev = doc;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return stream;
}
function parseDocument(src, options) {
  var cst = parse(src);
  var doc = new Document2(options).parse(cst[0]);
  if (cst.length > 1) {
    var errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));
  }
  return doc;
}
function parse2(src, options) {
  var doc = parseDocument(src, options);
  doc.warnings.forEach(function(warning) {
    return warn(warning);
  });
  if (doc.errors.length > 0)
    throw doc.errors[0];
  return doc.toJSON();
}
function stringify15(value, options) {
  var doc = new Document2(options);
  doc.contents = value;
  return String(doc);
}
var defaultOptions, scalarOptions, documentOptions, Anchors, visit, listTagNames, Document$1, Document2, YAML;
var init_dist = __esm({
  "node_modules/yaml/browser/dist/index.js"() {
    init_PlainValue_b8036b75();
    init_parse_cst();
    init_resolveSeq_492ab440();
    init_Schema_e94716c8();
    init_warnings_df54cb69();
    defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      simpleKeys: false,
      version: "1.2"
    };
    scalarOptions = {
      get binary() {
        return binaryOptions;
      },
      set binary(opt) {
        Object.assign(binaryOptions, opt);
      },
      get bool() {
        return boolOptions;
      },
      set bool(opt) {
        Object.assign(boolOptions, opt);
      },
      get int() {
        return intOptions;
      },
      set int(opt) {
        Object.assign(intOptions, opt);
      },
      get null() {
        return nullOptions;
      },
      set null(opt) {
        Object.assign(nullOptions, opt);
      },
      get str() {
        return strOptions;
      },
      set str(opt) {
        Object.assign(strOptions, opt);
      }
    };
    documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: defaultTagPrefix
        }]
      }
    };
    Anchors = function() {
      function Anchors2(prefix) {
        _classCallCheck(this, Anchors2);
        _defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      _createClass(Anchors2, [{
        key: "createAlias",
        value: function createAlias(node, name) {
          this.setAnchor(node, name);
          return new Alias2(node);
        }
      }, {
        key: "createMergePair",
        value: function createMergePair() {
          var _this = this;
          var merge = new Merge();
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          merge.value.items = sources.map(function(s2) {
            if (s2 instanceof Alias2) {
              if (s2.source instanceof YAMLMap)
                return s2;
            } else if (s2 instanceof YAMLMap) {
              return _this.createAlias(s2);
            }
            throw new Error("Merge sources must be Map nodes or their Aliases");
          });
          return merge;
        }
      }, {
        key: "getName",
        value: function getName(node) {
          var map2 = this.map;
          return Object.keys(map2).find(function(a2) {
            return map2[a2] === node;
          });
        }
      }, {
        key: "getNames",
        value: function getNames() {
          return Object.keys(this.map);
        }
      }, {
        key: "getNode",
        value: function getNode(name) {
          return this.map[name];
        }
      }, {
        key: "newName",
        value: function newName(prefix) {
          if (!prefix)
            prefix = this.prefix;
          var names = Object.keys(this.map);
          for (var i2 = 1; true; ++i2) {
            var name = "".concat(prefix).concat(i2);
            if (!names.includes(name))
              return name;
          }
        }
      }, {
        key: "resolveNodes",
        value: function resolveNodes() {
          var map2 = this.map, _cstAliases = this._cstAliases;
          Object.keys(map2).forEach(function(a2) {
            map2[a2] = map2[a2].resolved;
          });
          _cstAliases.forEach(function(a2) {
            a2.source = a2.source.resolved;
          });
          delete this._cstAliases;
        }
      }, {
        key: "setAnchor",
        value: function setAnchor(node, name) {
          if (node != null && !Anchors2.validAnchorNode(node)) {
            throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
          }
          if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
            throw new Error("Anchor names must not contain whitespace or control characters");
          }
          var map2 = this.map;
          var prev = node && Object.keys(map2).find(function(a2) {
            return map2[a2] === node;
          });
          if (prev) {
            if (!name) {
              return prev;
            } else if (prev !== name) {
              delete map2[prev];
              map2[name] = node;
            }
          } else {
            if (!name) {
              if (!node)
                return null;
              name = this.newName();
            }
            map2[name] = node;
          }
          return name;
        }
      }], [{
        key: "validAnchorNode",
        value: function validAnchorNode(node) {
          return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;
        }
      }]);
      return Anchors2;
    }();
    visit = function visit2(node, tags2) {
      if (node && _typeof(node) === "object") {
        var tag = node.tag;
        if (node instanceof Collection2) {
          if (tag)
            tags2[tag] = true;
          node.items.forEach(function(n2) {
            return visit2(n2, tags2);
          });
        } else if (node instanceof Pair) {
          visit2(node.key, tags2);
          visit2(node.value, tags2);
        } else if (node instanceof Scalar) {
          if (tag)
            tags2[tag] = true;
        }
      }
      return tags2;
    };
    listTagNames = function listTagNames2(node) {
      return Object.keys(visit(node, {}));
    };
    Document$1 = function() {
      function Document3(options) {
        _classCallCheck(this, Document3);
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      _createClass(Document3, [{
        key: "add",
        value: function add(value) {
          assertCollection(this.contents);
          return this.contents.add(value);
        }
      }, {
        key: "addIn",
        value: function addIn(path, value) {
          assertCollection(this.contents);
          this.contents.addIn(path, value);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          assertCollection(this.contents);
          return this.contents.delete(key);
        }
      }, {
        key: "deleteIn",
        value: function deleteIn(path) {
          if (isEmptyPath(path)) {
            if (this.contents == null)
              return false;
            this.contents = null;
            return true;
          }
          assertCollection(this.contents);
          return this.contents.deleteIn(path);
        }
      }, {
        key: "getDefaults",
        value: function getDefaults() {
          return Document3.defaults[this.version] || Document3.defaults[this.options.version] || {};
        }
      }, {
        key: "get",
        value: function get(key, keepScalar) {
          return this.contents instanceof Collection2 ? this.contents.get(key, keepScalar) : void 0;
        }
      }, {
        key: "getIn",
        value: function getIn(path, keepScalar) {
          if (isEmptyPath(path))
            return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;
          return this.contents instanceof Collection2 ? this.contents.getIn(path, keepScalar) : void 0;
        }
      }, {
        key: "has",
        value: function has(key) {
          return this.contents instanceof Collection2 ? this.contents.has(key) : false;
        }
      }, {
        key: "hasIn",
        value: function hasIn(path) {
          if (isEmptyPath(path))
            return this.contents !== void 0;
          return this.contents instanceof Collection2 ? this.contents.hasIn(path) : false;
        }
      }, {
        key: "set",
        value: function set2(key, value) {
          assertCollection(this.contents);
          this.contents.set(key, value);
        }
      }, {
        key: "setIn",
        value: function setIn(path, value) {
          if (isEmptyPath(path))
            this.contents = value;
          else {
            assertCollection(this.contents);
            this.contents.setIn(path, value);
          }
        }
      }, {
        key: "setSchema",
        value: function setSchema(id, customTags) {
          if (!id && !customTags && this.schema)
            return;
          if (typeof id === "number")
            id = id.toFixed(1);
          if (id === "1.0" || id === "1.1" || id === "1.2") {
            if (this.version)
              this.version = id;
            else
              this.options.version = id;
            delete this.options.schema;
          } else if (id && typeof id === "string") {
            this.options.schema = id;
          }
          if (Array.isArray(customTags))
            this.options.customTags = customTags;
          var opt = Object.assign({}, this.getDefaults(), this.options);
          this.schema = new Schema(opt);
        }
      }, {
        key: "parse",
        value: function parse4(node, prevDoc) {
          if (this.options.keepCstNodes)
            this.cstNode = node;
          if (this.options.keepNodeTypes)
            this.type = "DOCUMENT";
          var _node$directives = node.directives, directives = _node$directives === void 0 ? [] : _node$directives, _node$contents = node.contents, contents = _node$contents === void 0 ? [] : _node$contents, directivesEndMarker = node.directivesEndMarker, error = node.error, valueRange = node.valueRange;
          if (error) {
            if (!error.source)
              error.source = this;
            this.errors.push(error);
          }
          parseDirectives(this, directives, prevDoc);
          if (directivesEndMarker)
            this.directivesEndMarker = true;
          this.range = valueRange ? [valueRange.start, valueRange.end] : null;
          this.setSchema();
          this.anchors._cstAliases = [];
          parseContents(this, contents);
          this.anchors.resolveNodes();
          if (this.options.prettyErrors) {
            var _iterator = _createForOfIteratorHelper(this.errors), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _error = _step.value;
                if (_error instanceof YAMLError)
                  _error.makePretty();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper(this.warnings), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var warn2 = _step2.value;
                if (warn2 instanceof YAMLError)
                  warn2.makePretty();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return this;
        }
      }, {
        key: "listNonDefaultTags",
        value: function listNonDefaultTags() {
          return listTagNames(this.contents).filter(function(t2) {
            return t2.indexOf(Schema.defaultPrefix) !== 0;
          });
        }
      }, {
        key: "setTagPrefix",
        value: function setTagPrefix(handle, prefix) {
          if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
            throw new Error("Handle must start and end with !");
          if (prefix) {
            var prev = this.tagPrefixes.find(function(p2) {
              return p2.handle === handle;
            });
            if (prev)
              prev.prefix = prefix;
            else
              this.tagPrefixes.push({
                handle,
                prefix
              });
          } else {
            this.tagPrefixes = this.tagPrefixes.filter(function(p2) {
              return p2.handle !== handle;
            });
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON$1(arg, onAnchor) {
          var _this = this;
          var _this$options = this.options, keepBlobsInJSON = _this$options.keepBlobsInJSON, mapAsMap = _this$options.mapAsMap, maxAliasCount = _this$options.maxAliasCount;
          var keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof Scalar));
          var ctx = {
            doc: this,
            indentStep: "  ",
            keep,
            mapAsMap: keep && !!mapAsMap,
            maxAliasCount,
            stringify: stringify$1
          };
          var anchorNames = Object.keys(this.anchors.map);
          if (anchorNames.length > 0)
            ctx.anchors = new Map(anchorNames.map(function(name) {
              return [_this.anchors.map[name], {
                alias: [],
                aliasCount: 0,
                count: 1
              }];
            }));
          var res = toJSON(this.contents, arg, ctx);
          if (typeof onAnchor === "function" && ctx.anchors) {
            var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var _step3$value = _step3.value, count = _step3$value.count, _res = _step3$value.res;
                onAnchor(_res, count);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
          return res;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.errors.length > 0)
            throw new Error("Document with errors cannot be stringified");
          var indentSize = this.options.indent;
          if (!Number.isInteger(indentSize) || indentSize <= 0) {
            var s2 = JSON.stringify(indentSize);
            throw new Error('"indent" option must be a positive integer, not '.concat(s2));
          }
          this.setSchema();
          var lines = [];
          var hasDirectives = false;
          if (this.version) {
            var vd = "%YAML 1.2";
            if (this.schema.name === "yaml-1.1") {
              if (this.version === "1.0")
                vd = "%YAML:1.0";
              else if (this.version === "1.1")
                vd = "%YAML 1.1";
            }
            lines.push(vd);
            hasDirectives = true;
          }
          var tagNames = this.listNonDefaultTags();
          this.tagPrefixes.forEach(function(_ref) {
            var handle = _ref.handle, prefix = _ref.prefix;
            if (tagNames.some(function(t2) {
              return t2.indexOf(prefix) === 0;
            })) {
              lines.push("%TAG ".concat(handle, " ").concat(prefix));
              hasDirectives = true;
            }
          });
          if (hasDirectives || this.directivesEndMarker)
            lines.push("---");
          if (this.commentBefore) {
            if (hasDirectives || !this.directivesEndMarker)
              lines.unshift("");
            lines.unshift(this.commentBefore.replace(/^/gm, "#"));
          }
          var ctx = {
            anchors: /* @__PURE__ */ Object.create(null),
            doc: this,
            indent: "",
            indentStep: " ".repeat(indentSize),
            stringify: stringify$1
          };
          var chompKeep = false;
          var contentComment = null;
          if (this.contents) {
            if (this.contents instanceof Node2) {
              if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
                lines.push("");
              if (this.contents.commentBefore)
                lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
              ctx.forceBlockIndent = !!this.comment;
              contentComment = this.contents.comment;
            }
            var onChompKeep = contentComment ? null : function() {
              return chompKeep = true;
            };
            var body = stringify$1(this.contents, ctx, function() {
              return contentComment = null;
            }, onChompKeep);
            lines.push(addComment(body, "", contentComment));
          } else if (this.contents !== void 0) {
            lines.push(stringify$1(this.contents, ctx));
          }
          if (this.comment) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
              lines.push("");
            lines.push(this.comment.replace(/^/gm, "#"));
          }
          return lines.join("\n") + "\n";
        }
      }]);
      return Document3;
    }();
    _defineProperty(Document$1, "defaults", documentOptions);
    Document2 = function(_YAMLDocument) {
      _inherits(Document3, _YAMLDocument);
      var _super = _createSuper(Document3);
      function Document3(options) {
        _classCallCheck(this, Document3);
        return _super.call(this, Object.assign({}, defaultOptions, options));
      }
      return Document3;
    }(Document$1);
    YAML = {
      createNode: createNode5,
      defaultOptions,
      Document: Document2,
      parse: parse2,
      parseAllDocuments,
      parseCST: parse,
      parseDocument,
      scalarOptions,
      stringify: stringify15
    };
  }
});

// node_modules/yaml/browser/index.js
var require_browser = __commonJS({
  "node_modules/yaml/browser/index.js"(exports, module) {
    module.exports = (init_dist(), __toCommonJS(dist_exports)).YAML;
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/lilconfig/dist/index.js
var require_dist = __commonJS({
  "node_modules/lilconfig/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
    var path = require_path();
    var fs = require_fs();
    var os = require_os();
    var fsReadFileAsync = fs.promises.readFile;
    function getDefaultSearchPlaces(name) {
      return [
        "package.json",
        `.${name}rc.json`,
        `.${name}rc.js`,
        `${name}.config.js`,
        `.${name}rc.cjs`,
        `${name}.config.cjs`
      ];
    }
    function getSearchPaths(startDir, stopDir) {
      return startDir.split(path.sep).reduceRight((acc, _, ind, arr) => {
        const currentPath = arr.slice(0, ind + 1).join(path.sep);
        if (!acc.passedStopDir)
          acc.searchPlaces.push(currentPath || path.sep);
        if (currentPath === stopDir)
          acc.passedStopDir = true;
        return acc;
      }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
    }
    exports.defaultLoaders = Object.freeze({
      ".js": __require,
      ".json": __require,
      ".cjs": __require,
      noExt(_, content) {
        return JSON.parse(content);
      }
    });
    function getExtDesc(ext) {
      return ext === "noExt" ? "files without extensions" : `extension "${ext}"`;
    }
    function getOptions(name, options = {}) {
      const conf = {
        stopDir: os.homedir(),
        searchPlaces: getDefaultSearchPlaces(name),
        ignoreEmptySearchPlaces: true,
        transform: (x2) => x2,
        packageProp: [name],
        ...options,
        loaders: { ...exports.defaultLoaders, ...options.loaders }
      };
      conf.searchPlaces.forEach((place) => {
        const key = path.extname(place) || "noExt";
        const loader = conf.loaders[key];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
        }
        if (typeof loader !== "function") {
          throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
        }
      });
      return conf;
    }
    function getPackageProp(props, obj) {
      if (typeof props === "string" && props in obj)
        return obj[props];
      return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
    }
    function getSearchItems(searchPlaces, searchPaths) {
      return searchPaths.reduce((acc, searchPath) => {
        searchPlaces.forEach((fileName) => acc.push({
          fileName,
          filepath: path.join(searchPath, fileName),
          loaderKey: path.extname(fileName) || "noExt"
        }));
        return acc;
      }, []);
    }
    function validateFilePath(filepath) {
      if (!filepath)
        throw new Error("load must pass a non-empty string");
    }
    function validateLoader(loader, ext) {
      if (!loader)
        throw new Error(`No loader specified for extension "${ext}"`);
      if (typeof loader !== "function")
        throw new Error("loader is not a function");
    }
    function lilconfig(name, options) {
      const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform } = getOptions(name, options);
      return {
        async search(searchFrom = process.cwd()) {
          const searchPaths = getSearchPaths(searchFrom, stopDir);
          const result = {
            config: null,
            filepath: ""
          };
          const searchItems = getSearchItems(searchPlaces, searchPaths);
          for (const { fileName, filepath, loaderKey } of searchItems) {
            try {
              await fs.promises.access(filepath);
            } catch (_a) {
              continue;
            }
            const content = String(await fsReadFileAsync(filepath));
            const loader = loaders[loaderKey];
            if (fileName === "package.json") {
              const pkg = await loader(filepath, content);
              const maybeConfig = getPackageProp(packageProp, pkg);
              if (maybeConfig != null) {
                result.config = maybeConfig;
                result.filepath = filepath;
                break;
              }
              continue;
            }
            const isEmpty = content.trim() === "";
            if (isEmpty && ignoreEmptySearchPlaces)
              continue;
            if (isEmpty) {
              result.isEmpty = true;
              result.config = void 0;
            } else {
              validateLoader(loader, loaderKey);
              result.config = await loader(filepath, content);
            }
            result.filepath = filepath;
            break;
          }
          if (result.filepath === "" && result.config === null)
            return transform(null);
          return transform(result);
        },
        async load(filepath) {
          validateFilePath(filepath);
          const absPath = path.resolve(process.cwd(), filepath);
          const { base, ext } = path.parse(absPath);
          const loaderKey = ext || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(await fsReadFileAsync(absPath));
          if (base === "package.json") {
            const pkg = await loader(absPath, content);
            return transform({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty = content.trim() === "";
          if (isEmpty && ignoreEmptySearchPlaces)
            return transform({
              config: void 0,
              filepath: absPath,
              isEmpty: true
            });
          result.config = isEmpty ? void 0 : await loader(absPath, content);
          return transform(isEmpty ? { ...result, isEmpty, config: void 0 } : result);
        }
      };
    }
    exports.lilconfig = lilconfig;
    function lilconfigSync(name, options) {
      const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform } = getOptions(name, options);
      return {
        search(searchFrom = process.cwd()) {
          const searchPaths = getSearchPaths(searchFrom, stopDir);
          const result = {
            config: null,
            filepath: ""
          };
          const searchItems = getSearchItems(searchPlaces, searchPaths);
          for (const { fileName, filepath, loaderKey } of searchItems) {
            try {
              fs.accessSync(filepath);
            } catch (_a) {
              continue;
            }
            const loader = loaders[loaderKey];
            const content = String(fs.readFileSync(filepath));
            if (fileName === "package.json") {
              const pkg = loader(filepath, content);
              const maybeConfig = getPackageProp(packageProp, pkg);
              if (maybeConfig != null) {
                result.config = maybeConfig;
                result.filepath = filepath;
                break;
              }
              continue;
            }
            const isEmpty = content.trim() === "";
            if (isEmpty && ignoreEmptySearchPlaces)
              continue;
            if (isEmpty) {
              result.isEmpty = true;
              result.config = void 0;
            } else {
              validateLoader(loader, loaderKey);
              result.config = loader(filepath, content);
            }
            result.filepath = filepath;
            break;
          }
          if (result.filepath === "" && result.config === null)
            return transform(null);
          return transform(result);
        },
        load(filepath) {
          validateFilePath(filepath);
          const absPath = path.resolve(process.cwd(), filepath);
          const { base, ext } = path.parse(absPath);
          const loaderKey = ext || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(fs.readFileSync(absPath));
          if (base === "package.json") {
            const pkg = loader(absPath, content);
            return transform({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty = content.trim() === "";
          if (isEmpty && ignoreEmptySearchPlaces)
            return transform({
              filepath: absPath,
              config: void 0,
              isEmpty: true
            });
          result.config = isEmpty ? void 0 : loader(absPath, content);
          return transform(isEmpty ? { ...result, isEmpty, config: void 0 } : result);
        }
      };
    }
    exports.lilconfigSync = lilconfigSync;
  }
});

// node_modules/css-declaration-sorter/src/shorthand-data.mjs
var shorthandData;
var init_shorthand_data = __esm({
  "node_modules/css-declaration-sorter/src/shorthand-data.mjs"() {
    shorthandData = {
      "animation": [
        "animation-name",
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state"
      ],
      "background": [
        "background-image",
        "background-size",
        "background-position",
        "background-repeat",
        "background-origin",
        "background-clip",
        "background-attachment",
        "background-color"
      ],
      "columns": [
        "column-width",
        "column-count"
      ],
      "column-rule": [
        "column-rule-width",
        "column-rule-style",
        "column-rule-color"
      ],
      "flex": [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      "flex-flow": [
        "flex-direction",
        "flex-wrap"
      ],
      "font": [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "font-family",
        "line-height"
      ],
      "grid": [
        "grid-template-rows",
        "grid-template-columns",
        "grid-template-areas",
        "grid-auto-rows",
        "grid-auto-columns",
        "grid-auto-flow",
        "column-gap",
        "row-gap"
      ],
      "grid-area": [
        "grid-row-start",
        "grid-column-start",
        "grid-row-end",
        "grid-column-end"
      ],
      "grid-column": [
        "grid-column-start",
        "grid-column-end"
      ],
      "grid-row": [
        "grid-row-start",
        "grid-row-end"
      ],
      "grid-template": [
        "grid-template-columns",
        "grid-template-rows",
        "grid-template-areas"
      ],
      "list-style": [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      "padding": [
        "padding-block",
        "padding-block-start",
        "padding-block-end",
        "padding-inline",
        "padding-inline-start",
        "padding-inline-end",
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      "padding-block": [
        "padding-block-start",
        "padding-block-end",
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      "padding-block-start": [
        "padding-top",
        "padding-right",
        "padding-left"
      ],
      "padding-block-end": [
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      "padding-inline": [
        "padding-inline-start",
        "padding-inline-end",
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      "padding-inline-start": [
        "padding-top",
        "padding-right",
        "padding-left"
      ],
      "padding-inline-end": [
        "padding-right",
        "padding-bottom",
        "padding-left"
      ],
      "margin": [
        "margin-block",
        "margin-block-start",
        "margin-block-end",
        "margin-inline",
        "margin-inline-start",
        "margin-inline-end",
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      "margin-block": [
        "margin-block-start",
        "margin-block-end",
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      "margin-inline": [
        "margin-inline-start",
        "margin-inline-end",
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      "margin-inline-start": [
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      "margin-inline-end": [
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left"
      ],
      "border": [
        "border-top",
        "border-right",
        "border-bottom",
        "border-left",
        "border-width",
        "border-style",
        "border-color",
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width",
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style",
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color",
        "border-block",
        "border-block-start",
        "border-block-end",
        "border-block-width",
        "border-block-style",
        "border-block-color",
        "border-inline",
        "border-inline-start",
        "border-inline-end",
        "border-inline-width",
        "border-inline-style",
        "border-inline-color"
      ],
      "border-top": [
        "border-width",
        "border-style",
        "border-color",
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      "border-right": [
        "border-width",
        "border-style",
        "border-color",
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      "border-bottom": [
        "border-width",
        "border-style",
        "border-color",
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      "border-left": [
        "border-width",
        "border-style",
        "border-color",
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      "border-color": [
        "border-top-color",
        "border-bottom-color",
        "border-left-color",
        "border-right-color"
      ],
      "border-width": [
        "border-top-width",
        "border-bottom-width",
        "border-left-width",
        "border-right-width"
      ],
      "border-style": [
        "border-top-style",
        "border-bottom-style",
        "border-left-style",
        "border-right-style"
      ],
      "border-radius": [
        "border-top-right-radius",
        "border-top-left-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      "border-block": [
        "border-block-start",
        "border-block-end",
        "border-block-width",
        "border-width",
        "border-block-style",
        "border-style",
        "border-block-color",
        "border-color"
      ],
      "border-block-start": [
        "border-block-start-width",
        "border-width",
        "border-block-start-style",
        "border-style",
        "border-block-start-color",
        "border-color"
      ],
      "border-block-end": [
        "border-block-end-width",
        "border-width",
        "border-block-end-style",
        "border-style",
        "border-block-end-color",
        "border-color"
      ],
      "border-inline": [
        "border-inline-start",
        "border-inline-end",
        "border-inline-width",
        "border-width",
        "border-inline-style",
        "border-style",
        "border-inline-color",
        "border-color"
      ],
      "border-inline-start": [
        "border-inline-start-width",
        "border-width",
        "border-inline-start-style",
        "border-style",
        "border-inline-start-color",
        "border-color"
      ],
      "border-inline-end": [
        "border-inline-end-width",
        "border-width",
        "border-inline-end-style",
        "border-style",
        "border-inline-end-color",
        "border-color"
      ],
      "border-image": [
        "border-image-source",
        "border-image-slice",
        "border-image-width",
        "border-image-outset",
        "border-image-repeat"
      ],
      "mask": [
        "mask-image",
        "mask-mode",
        "mask-position",
        "mask-size",
        "mask-repeat",
        "mask-origin",
        "mask-clip",
        "mask-composite"
      ],
      "inline-size": [
        "width",
        "height"
      ],
      "block-size": [
        "width",
        "height"
      ],
      "max-inline-size": [
        "max-width",
        "max-height"
      ],
      "max-block-size": [
        "max-width",
        "max-height"
      ],
      "inset": [
        "inset-block",
        "inset-block-start",
        "inset-block-end",
        "inset-inline",
        "inset-inline-start",
        "inset-inline-end",
        "top",
        "right",
        "bottom",
        "left"
      ],
      "inset-block": [
        "inset-block-start",
        "inset-block-end",
        "top",
        "right",
        "bottom",
        "left"
      ],
      "inset-inline": [
        "inset-inline-start",
        "inset-inline-end",
        "top",
        "right",
        "bottom",
        "left"
      ],
      "outline": [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      "overflow": [
        "overflow-x",
        "overflow-y"
      ],
      "place-content": [
        "align-content",
        "justify-content"
      ],
      "place-items": [
        "align-items",
        "justify-items"
      ],
      "place-self": [
        "align-self",
        "justify-self"
      ],
      "text-decoration": [
        "text-decoration-color",
        "text-decoration-style",
        "text-decoration-line"
      ],
      "transition": [
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ],
      "text-emphasis": [
        "text-emphasis-style",
        "text-emphasis-color"
      ]
    };
  }
});

// node_modules/css-declaration-sorter/src/main.mjs
var main_exports = {};
__export(main_exports, {
  cssDeclarationSorter: () => cssDeclarationSorter,
  default: () => main_default
});
function processCss({ css, comparator }) {
  const comments = [];
  const rulesCache = [];
  css.walk((node) => {
    const nodes = node.nodes;
    const type = node.type;
    if (type === "comment") {
      const isNewlineNode = node.raws.before && node.raws.before.includes("\n");
      const lastNewlineNode = isNewlineNode && !node.next();
      const onlyNode = !node.prev() && !node.next() || !node.parent;
      if (lastNewlineNode || onlyNode || node.parent.type === "root") {
        return;
      }
      if (isNewlineNode) {
        const pairedNode = node.next() || node.prev();
        if (pairedNode) {
          comments.unshift({
            "comment": node,
            "pairedNode": pairedNode,
            "insertPosition": node.next() ? "Before" : "After"
          });
          node.remove();
        }
      } else {
        const pairedNode = node.prev() || node.next();
        if (pairedNode) {
          comments.push({
            "comment": node,
            "pairedNode": pairedNode,
            "insertPosition": "After"
          });
          node.remove();
        }
      }
      return;
    }
    const isRule = type === "rule" || type === "atrule";
    if (isRule && nodes && nodes.length > 1) {
      rulesCache.push(nodes);
    }
  });
  rulesCache.forEach((nodes) => {
    sortCssDeclarations({ nodes, comparator });
  });
  comments.forEach((node) => {
    const pairedNode = node.pairedNode;
    node.comment.remove();
    pairedNode.parent && pairedNode.parent["insert" + node.insertPosition](pairedNode, node.comment);
  });
}
function sortCssDeclarations({ nodes, comparator }) {
  nodes.sort((a2, b2) => {
    if (a2.type === "decl" && b2.type === "decl") {
      return comparator(a2.prop, b2.prop);
    } else {
      return compareDifferentType(a2, b2);
    }
  });
}
function withOverridesComparator(shorthandData2) {
  return function(comparator) {
    return function(a2, b2) {
      a2 = removeVendorPrefix(a2);
      b2 = removeVendorPrefix(b2);
      if (shorthandData2[a2] && shorthandData2[a2].includes(b2))
        return 0;
      if (shorthandData2[b2] && shorthandData2[b2].includes(a2))
        return 0;
      return comparator(a2, b2);
    };
  };
}
function orderComparator(order) {
  return function(a2, b2) {
    return order.indexOf(a2) - order.indexOf(b2);
  };
}
function compareDifferentType(a2, b2) {
  if (b2.type === "atrule") {
    return 0;
  }
  return a2.type === "decl" ? -1 : b2.type === "decl" ? 1 : 0;
}
function removeVendorPrefix(property) {
  return property.replace(/^-\w+-/, "");
}
var builtInOrders, cssDeclarationSorter, main_default;
var init_main = __esm({
  "node_modules/css-declaration-sorter/src/main.mjs"() {
    init_shorthand_data();
    builtInOrders = [
      "alphabetical",
      "concentric-css",
      "smacss"
    ];
    cssDeclarationSorter = ({ order = "alphabetical", keepOverrides = false } = {}) => ({
      postcssPlugin: "css-declaration-sorter",
      OnceExit(css) {
        let withKeepOverrides = (comparator) => comparator;
        if (keepOverrides) {
          withKeepOverrides = withOverridesComparator(shorthandData);
        }
        if (typeof order === "function") {
          return processCss({ css, comparator: withKeepOverrides(order) });
        }
        if (!builtInOrders.includes(order))
          return Promise.reject(
            Error([
              `Invalid built-in order '${order}' provided.`,
              `Available built-in orders are: ${builtInOrders}`
            ].join("\n"))
          );
        return import(`../orders/${order}.mjs`).then(({ properties }) => processCss({
          css,
          comparator: withKeepOverrides(orderComparator(properties))
        }));
      }
    });
    cssDeclarationSorter.postcss = true;
    main_default = cssDeclarationSorter;
  }
});

// node_modules/postcss-discard-comments/src/lib/commentRemover.js
var require_commentRemover = __commonJS({
  "node_modules/postcss-discard-comments/src/lib/commentRemover.js"(exports, module) {
    "use strict";
    function CommentRemover(options) {
      this.options = options;
    }
    CommentRemover.prototype.canRemove = function(comment) {
      const remove = this.options.remove;
      if (remove) {
        return remove(comment);
      } else {
        const isImportant = comment.indexOf("!") === 0;
        if (!isImportant) {
          return true;
        }
        if (this.options.removeAll || this._hasFirst) {
          return true;
        } else if (this.options.removeAllButFirst && !this._hasFirst) {
          this._hasFirst = true;
          return false;
        }
      }
    };
    module.exports = CommentRemover;
  }
});

// node_modules/postcss-discard-comments/src/lib/commentParser.js
var require_commentParser = __commonJS({
  "node_modules/postcss-discard-comments/src/lib/commentParser.js"(exports, module) {
    "use strict";
    module.exports = function commentParser(input) {
      const tokens = [];
      const length = input.length;
      let pos = 0;
      let next;
      while (pos < length) {
        next = input.indexOf("/*", pos);
        if (~next) {
          tokens.push([0, pos, next]);
          pos = next;
          next = input.indexOf("*/", pos + 2);
          tokens.push([1, pos + 2, next]);
          pos = next + 2;
        } else {
          tokens.push([0, pos, length]);
          pos = length;
        }
      }
      return tokens;
    };
  }
});

// node_modules/postcss-discard-comments/src/index.js
var require_src = __commonJS({
  "node_modules/postcss-discard-comments/src/index.js"(exports, module) {
    "use strict";
    var CommentRemover = require_commentRemover();
    var commentParser = require_commentParser();
    function pluginCreator(opts = {}) {
      const remover = new CommentRemover(opts);
      const matcherCache = /* @__PURE__ */ new Map();
      const replacerCache = /* @__PURE__ */ new Map();
      function matchesComments(source) {
        if (matcherCache.has(source)) {
          return matcherCache.get(source);
        }
        const result = commentParser(source).filter(([type]) => type);
        matcherCache.set(source, result);
        return result;
      }
      function replaceComments(source, space, separator = " ") {
        const key = source + "@|@" + separator;
        if (replacerCache.has(key)) {
          return replacerCache.get(key);
        }
        const parsed = commentParser(source).reduce((value, [type, start, end]) => {
          const contents = source.slice(start, end);
          if (!type) {
            return value + contents;
          }
          if (remover.canRemove(contents)) {
            return value + separator;
          }
          return `${value}/*${contents}*/`;
        }, "");
        const result = space(parsed).join(" ");
        replacerCache.set(key, result);
        return result;
      }
      return {
        postcssPlugin: "postcss-discard-comments",
        OnceExit(css, { list }) {
          css.walk((node) => {
            if (node.type === "comment" && remover.canRemove(node.text)) {
              node.remove();
              return;
            }
            if (typeof node.raws.between === "string") {
              node.raws.between = replaceComments(node.raws.between, list.space);
            }
            if (node.type === "decl") {
              if (node.raws.value && node.raws.value.raw) {
                if (node.raws.value.value === node.value) {
                  node.value = replaceComments(node.raws.value.raw, list.space);
                } else {
                  node.value = replaceComments(node.value, list.space);
                }
                node.raws.value = null;
              }
              if (node.raws.important) {
                node.raws.important = replaceComments(
                  node.raws.important,
                  list.space
                );
                const b2 = matchesComments(node.raws.important);
                node.raws.important = b2.length ? node.raws.important : "!important";
              } else {
                node.value = replaceComments(node.value, list.space);
              }
              return;
            }
            if (node.type === "rule" && node.raws.selector && node.raws.selector.raw) {
              node.raws.selector.raw = replaceComments(
                node.raws.selector.raw,
                list.space,
                ""
              );
              return;
            }
            if (node.type === "atrule") {
              if (node.raws.afterName) {
                const commentsReplaced = replaceComments(
                  node.raws.afterName,
                  list.space
                );
                if (!commentsReplaced.length) {
                  node.raws.afterName = commentsReplaced + " ";
                } else {
                  node.raws.afterName = " " + commentsReplaced + " ";
                }
              }
              if (node.raws.params && node.raws.params.raw) {
                node.raws.params.raw = replaceComments(
                  node.raws.params.raw,
                  list.space
                );
              }
            }
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/lodash.memoize/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.memoize/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    module.exports = memoize;
  }
});

// node_modules/lodash.uniq/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.uniq/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee ? null : createSet2(array);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet2 = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function noop() {
    }
    module.exports = uniq;
  }
});

// node_modules/caniuse-api/dist/utils.js
var require_utils = __commonJS({
  "node_modules/caniuse-api/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contains = contains;
    exports.parseCaniuseData = parseCaniuseData;
    exports.cleanBrowsersList = cleanBrowsersList;
    var _lodash = require_lodash2();
    var _lodash2 = _interopRequireDefault(_lodash);
    var _browserslist = require_browserslist();
    var _browserslist2 = _interopRequireDefault(_browserslist);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function contains(str, substr) {
      return !!~str.indexOf(substr);
    }
    function parseCaniuseData(feature, browsers) {
      var support = {};
      var letters;
      var letter;
      browsers.forEach(function(browser) {
        support[browser] = {};
        for (var info in feature.stats[browser]) {
          letters = feature.stats[browser][info].replace(/#\d+/, "").trim().split(" ");
          info = parseFloat(info.split("-")[0]);
          if (isNaN(info))
            continue;
          for (var i2 = 0; i2 < letters.length; i2++) {
            letter = letters[i2];
            if (letter === "d") {
              continue;
            } else if (letter === "y") {
              if (typeof support[browser][letter] === "undefined" || info < support[browser][letter]) {
                support[browser][letter] = info;
              }
            } else {
              if (typeof support[browser][letter] === "undefined" || info > support[browser][letter]) {
                support[browser][letter] = info;
              }
            }
          }
        }
      });
      return support;
    }
    function cleanBrowsersList(browserList) {
      return (0, _lodash2.default)((0, _browserslist2.default)(browserList).map(function(browser) {
        return browser.split(" ")[0];
      }));
    }
  }
});

// node_modules/caniuse-api/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/caniuse-api/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getBrowserScope = exports.setBrowserScope = exports.getLatestStableBrowsers = exports.find = exports.isSupported = exports.getSupport = exports.features = void 0;
    var _lodash = require_lodash();
    var _lodash2 = _interopRequireDefault(_lodash);
    var _browserslist = require_browserslist();
    var _browserslist2 = _interopRequireDefault(_browserslist);
    var _caniuseLite = require_unpacker();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var featuresList = Object.keys(_caniuseLite.features);
    var browsers = void 0;
    function setBrowserScope(browserList) {
      browsers = (0, _utils.cleanBrowsersList)(browserList);
    }
    function getBrowserScope() {
      return browsers;
    }
    var parse4 = (0, _lodash2.default)(_utils.parseCaniuseData, function(feat, browsers2) {
      return feat.title + browsers2;
    });
    function getSupport(query) {
      var feature = void 0;
      try {
        feature = (0, _caniuseLite.feature)(_caniuseLite.features[query]);
      } catch (e2) {
        var res = find(query);
        if (res.length === 1)
          return getSupport(res[0]);
        throw new ReferenceError("Please provide a proper feature name. Cannot find " + query);
      }
      return parse4(feature, browsers);
    }
    function isSupported(feature, browsers2) {
      var data = void 0;
      try {
        data = (0, _caniuseLite.feature)(_caniuseLite.features[feature]);
      } catch (e2) {
        var res = find(feature);
        if (res.length === 1) {
          data = _caniuseLite.features[res[0]];
        } else {
          throw new ReferenceError("Please provide a proper feature name. Cannot find " + feature);
        }
      }
      return (0, _browserslist2.default)(browsers2, { ignoreUnknownVersions: true }).map(function(browser) {
        return browser.split(" ");
      }).every(function(browser) {
        return data.stats[browser[0]] && data.stats[browser[0]][browser[1]] === "y";
      });
    }
    function find(query) {
      if (typeof query !== "string") {
        throw new TypeError("The `query` parameter should be a string.");
      }
      if (~featuresList.indexOf(query)) {
        return query;
      }
      return featuresList.filter(function(file) {
        return (0, _utils.contains)(file, query);
      });
    }
    function getLatestStableBrowsers() {
      return (0, _browserslist2.default)("last 1 version");
    }
    setBrowserScope();
    exports.features = featuresList;
    exports.getSupport = getSupport;
    exports.isSupported = isSupported;
    exports.find = find;
    exports.getLatestStableBrowsers = getLatestStableBrowsers;
    exports.setBrowserScope = setBrowserScope;
    exports.getBrowserScope = getBrowserScope;
  }
});

// node_modules/postcss-reduce-initial/src/data/fromInitial.json
var require_fromInitial = __commonJS({
  "node_modules/postcss-reduce-initial/src/data/fromInitial.json"(exports, module) {
    module.exports = {
      "-webkit-line-clamp": "none",
      "accent-color": "auto",
      "align-content": "normal",
      "align-items": "normal",
      "align-self": "auto",
      "align-tracks": "normal",
      "animation-delay": "0s",
      "animation-direction": "normal",
      "animation-duration": "0s",
      "animation-fill-mode": "none",
      "animation-iteration-count": "1",
      "animation-name": "none",
      "animation-timing-function": "ease",
      appearance: "auto",
      "aspect-ratio": "auto",
      azimuth: "center",
      "backdrop-filter": "none",
      "background-attachment": "scroll",
      "background-blend-mode": "normal",
      "background-image": "none",
      "background-position": "0% 0%",
      "background-position-x": "left",
      "background-position-y": "top",
      "background-repeat": "repeat",
      "block-overflow": "clip",
      "block-size": "auto",
      "border-block-style": "none",
      "border-block-width": "medium",
      "border-block-end-style": "none",
      "border-block-end-width": "medium",
      "border-block-start-style": "none",
      "border-block-start-width": "medium",
      "border-bottom-left-radius": "0",
      "border-bottom-right-radius": "0",
      "border-bottom-style": "none",
      "border-bottom-width": "medium",
      "border-end-end-radius": "0",
      "border-end-start-radius": "0",
      "border-image-outset": "0",
      "border-image-slice": "100%",
      "border-image-source": "none",
      "border-image-width": "1",
      "border-inline-style": "none",
      "border-inline-width": "medium",
      "border-inline-end-style": "none",
      "border-inline-end-width": "medium",
      "border-inline-start-style": "none",
      "border-inline-start-width": "medium",
      "border-left-style": "none",
      "border-left-width": "medium",
      "border-right-style": "none",
      "border-right-width": "medium",
      "border-spacing": "0",
      "border-start-end-radius": "0",
      "border-start-start-radius": "0",
      "border-top-left-radius": "0",
      "border-top-right-radius": "0",
      "border-top-style": "none",
      "border-top-width": "medium",
      bottom: "auto",
      "box-decoration-break": "slice",
      "box-shadow": "none",
      "break-after": "auto",
      "break-before": "auto",
      "break-inside": "auto",
      "caption-side": "top",
      "caret-color": "auto",
      clear: "none",
      clip: "auto",
      "clip-path": "none",
      "color-scheme": "normal",
      "column-count": "auto",
      "column-gap": "normal",
      "column-rule-style": "none",
      "column-rule-width": "medium",
      "column-span": "none",
      "column-width": "auto",
      contain: "none",
      content: "normal",
      "counter-increment": "none",
      "counter-reset": "none",
      "counter-set": "none",
      cursor: "auto",
      direction: "ltr",
      "empty-cells": "show",
      filter: "none",
      "flex-basis": "auto",
      "flex-direction": "row",
      "flex-grow": "0",
      "flex-shrink": "1",
      "flex-wrap": "nowrap",
      float: "none",
      "font-feature-settings": "normal",
      "font-kerning": "auto",
      "font-language-override": "normal",
      "font-optical-sizing": "auto",
      "font-variation-settings": "normal",
      "font-size": "medium",
      "font-size-adjust": "none",
      "font-stretch": "normal",
      "font-style": "normal",
      "font-variant": "normal",
      "font-variant-alternates": "normal",
      "font-variant-caps": "normal",
      "font-variant-east-asian": "normal",
      "font-variant-ligatures": "normal",
      "font-variant-numeric": "normal",
      "font-variant-position": "normal",
      "font-weight": "normal",
      "forced-color-adjust": "auto",
      "grid-auto-columns": "auto",
      "grid-auto-flow": "row",
      "grid-auto-rows": "auto",
      "grid-column-end": "auto",
      "grid-column-gap": "0",
      "grid-column-start": "auto",
      "grid-row-end": "auto",
      "grid-row-gap": "0",
      "grid-row-start": "auto",
      "grid-template-areas": "none",
      "grid-template-columns": "none",
      "grid-template-rows": "none",
      "hanging-punctuation": "none",
      height: "auto",
      hyphens: "manual",
      "image-rendering": "auto",
      "image-resolution": "1dppx",
      "ime-mode": "auto",
      "initial-letter": "normal",
      "initial-letter-align": "auto",
      "inline-size": "auto",
      inset: "auto",
      "inset-block": "auto",
      "inset-block-end": "auto",
      "inset-block-start": "auto",
      "inset-inline": "auto",
      "inset-inline-end": "auto",
      "inset-inline-start": "auto",
      isolation: "auto",
      "justify-content": "normal",
      "justify-items": "legacy",
      "justify-self": "auto",
      "justify-tracks": "normal",
      left: "auto",
      "letter-spacing": "normal",
      "line-break": "auto",
      "line-clamp": "none",
      "line-height": "normal",
      "line-height-step": "0",
      "list-style-image": "none",
      "list-style-type": "disc",
      "margin-block": "0",
      "margin-block-end": "0",
      "margin-block-start": "0",
      "margin-bottom": "0",
      "margin-inline": "0",
      "margin-inline-end": "0",
      "margin-inline-start": "0",
      "margin-left": "0",
      "margin-right": "0",
      "margin-top": "0",
      "margin-trim": "none",
      "mask-border-mode": "alpha",
      "mask-border-outset": "0",
      "mask-border-slice": "0",
      "mask-border-source": "none",
      "mask-border-width": "auto",
      "mask-composite": "add",
      "mask-image": "none",
      "mask-position": "center",
      "mask-repeat": "repeat",
      "mask-size": "auto",
      "masonry-auto-flow": "pack",
      "math-style": "normal",
      "max-block-size": "0",
      "max-height": "none",
      "max-inline-size": "0",
      "max-lines": "none",
      "max-width": "none",
      "min-block-size": "0",
      "min-height": "auto",
      "min-inline-size": "0",
      "min-width": "auto",
      "mix-blend-mode": "normal",
      "object-fit": "fill",
      "offset-anchor": "auto",
      "offset-distance": "0",
      "offset-path": "none",
      "offset-position": "auto",
      "offset-rotate": "auto",
      opacity: "1.0",
      order: "0",
      orphans: "2",
      "outline-offset": "0",
      "outline-style": "none",
      "outline-width": "medium",
      "overflow-anchor": "auto",
      "overflow-block": "auto",
      "overflow-clip-margin": "0px",
      "overflow-inline": "auto",
      "overflow-wrap": "normal",
      "overscroll-behavior": "auto",
      "overscroll-behavior-block": "auto",
      "overscroll-behavior-inline": "auto",
      "overscroll-behavior-x": "auto",
      "overscroll-behavior-y": "auto",
      "padding-block": "0",
      "padding-block-end": "0",
      "padding-block-start": "0",
      "padding-bottom": "0",
      "padding-inline": "0",
      "padding-inline-end": "0",
      "padding-inline-start": "0",
      "padding-left": "0",
      "padding-right": "0",
      "padding-top": "0",
      "page-break-after": "auto",
      "page-break-before": "auto",
      "page-break-inside": "auto",
      "paint-order": "normal",
      perspective: "none",
      "place-content": "normal",
      "pointer-events": "auto",
      position: "static",
      resize: "none",
      right: "auto",
      rotate: "none",
      "row-gap": "normal",
      scale: "none",
      "scrollbar-color": "auto",
      "scrollbar-gutter": "auto",
      "scrollbar-width": "auto",
      "scroll-behavior": "auto",
      "scroll-margin": "0",
      "scroll-margin-block": "0",
      "scroll-margin-block-start": "0",
      "scroll-margin-block-end": "0",
      "scroll-margin-bottom": "0",
      "scroll-margin-inline": "0",
      "scroll-margin-inline-start": "0",
      "scroll-margin-inline-end": "0",
      "scroll-margin-left": "0",
      "scroll-margin-right": "0",
      "scroll-margin-top": "0",
      "scroll-padding": "auto",
      "scroll-padding-block": "auto",
      "scroll-padding-block-start": "auto",
      "scroll-padding-block-end": "auto",
      "scroll-padding-bottom": "auto",
      "scroll-padding-inline": "auto",
      "scroll-padding-inline-start": "auto",
      "scroll-padding-inline-end": "auto",
      "scroll-padding-left": "auto",
      "scroll-padding-right": "auto",
      "scroll-padding-top": "auto",
      "scroll-snap-align": "none",
      "scroll-snap-coordinate": "none",
      "scroll-snap-points-x": "none",
      "scroll-snap-points-y": "none",
      "scroll-snap-stop": "normal",
      "scroll-snap-type": "none",
      "scroll-snap-type-x": "none",
      "scroll-snap-type-y": "none",
      "shape-image-threshold": "0.0",
      "shape-margin": "0",
      "shape-outside": "none",
      "tab-size": "8",
      "table-layout": "auto",
      "text-align-last": "auto",
      "text-combine-upright": "none",
      "text-decoration-line": "none",
      "text-decoration-skip-ink": "auto",
      "text-decoration-style": "solid",
      "text-decoration-thickness": "auto",
      "text-emphasis-style": "none",
      "text-indent": "0",
      "text-justify": "auto",
      "text-orientation": "mixed",
      "text-overflow": "clip",
      "text-rendering": "auto",
      "text-shadow": "none",
      "text-transform": "none",
      "text-underline-offset": "auto",
      "text-underline-position": "auto",
      top: "auto",
      "touch-action": "auto",
      transform: "none",
      "transform-style": "flat",
      "transition-delay": "0s",
      "transition-duration": "0s",
      "transition-property": "all",
      "transition-timing-function": "ease",
      translate: "none",
      "unicode-bidi": "normal",
      "user-select": "auto",
      "white-space": "normal",
      widows: "2",
      width: "auto",
      "will-change": "auto",
      "word-break": "normal",
      "word-spacing": "normal",
      "word-wrap": "normal",
      "z-index": "auto"
    };
  }
});

// node_modules/postcss-reduce-initial/src/data/toInitial.json
var require_toInitial = __commonJS({
  "node_modules/postcss-reduce-initial/src/data/toInitial.json"(exports, module) {
    module.exports = {
      "background-clip": "border-box",
      "background-color": "transparent",
      "background-origin": "padding-box",
      "background-size": "auto auto",
      "border-block-color": "currentcolor",
      "border-block-end-color": "currentcolor",
      "border-block-start-color": "currentcolor",
      "border-bottom-color": "currentcolor",
      "border-collapse": "separate",
      "border-inline-color": "currentcolor",
      "border-inline-end-color": "currentcolor",
      "border-inline-start-color": "currentcolor",
      "border-left-color": "currentcolor",
      "border-right-color": "currentcolor",
      "border-top-color": "currentcolor",
      "box-sizing": "content-box",
      "column-rule-color": "currentcolor",
      "font-synthesis": "weight style",
      "image-orientation": "from-image",
      "mask-clip": "border-box",
      "mask-mode": "match-source",
      "mask-origin": "border-box",
      "mask-type": "luminance",
      "ruby-align": "space-around",
      "ruby-merge": "separate",
      "ruby-position": "alternate",
      "text-decoration-color": "currentcolor",
      "text-emphasis-color": "currentcolor",
      "text-emphasis-position": "over right",
      "transform-box": "view-box",
      "transform-origin": "50% 50% 0",
      "vertical-align": "baseline",
      "writing-mode": "horizontal-tb"
    };
  }
});

// node_modules/postcss-reduce-initial/src/index.js
var require_src2 = __commonJS({
  "node_modules/postcss-reduce-initial/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var { isSupported } = require_dist2();
    var fromInitial = require_fromInitial();
    var toInitial = require_toInitial();
    var initial = "initial";
    var defaultIgnoreProps = ["writing-mode", "transform-box"];
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-reduce-initial",
        prepare(result) {
          const resultOpts = result.opts || {};
          const browsers = browserslist(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
          });
          const initialSupport = isSupported("css-initial-value", browsers);
          return {
            OnceExit(css) {
              css.walkDecls((decl) => {
                const lowerCasedProp = decl.prop.toLowerCase();
                const ignoreProp = new Set(
                  defaultIgnoreProps.concat(resultOpts.ignore || [])
                );
                if (ignoreProp.has(lowerCasedProp)) {
                  return;
                }
                if (initialSupport && Object.prototype.hasOwnProperty.call(toInitial, lowerCasedProp) && decl.value.toLowerCase() === toInitial[lowerCasedProp]) {
                  decl.value = initial;
                  return;
                }
                if (decl.value.toLowerCase() !== initial || !fromInitial[lowerCasedProp]) {
                  return;
                }
                decl.value = fromInitial[lowerCasedProp];
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/cssnano-utils/src/rawCache.js
var require_rawCache = __commonJS({
  "node_modules/cssnano-utils/src/rawCache.js"(exports, module) {
    "use strict";
    function pluginCreator() {
      return {
        postcssPlugin: "cssnano-util-raw-cache",
        OnceExit(css, { result }) {
          result.root.rawCache = {
            colon: ":",
            indent: "",
            beforeDecl: "",
            beforeRule: "",
            beforeOpen: "",
            beforeClose: "",
            beforeComment: "",
            after: "",
            emptyBody: "",
            commentLeft: "",
            commentRight: ""
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/cssnano-utils/src/getArguments.js
var require_getArguments = __commonJS({
  "node_modules/cssnano-utils/src/getArguments.js"(exports, module) {
    "use strict";
    module.exports = function getArguments(node) {
      const list = [[]];
      for (const child of node.nodes) {
        if (child.type !== "div") {
          list[list.length - 1].push(child);
        } else {
          list.push([]);
        }
      }
      return list;
    };
  }
});

// node_modules/cssnano-utils/src/sameParent.js
var require_sameParent = __commonJS({
  "node_modules/cssnano-utils/src/sameParent.js"(exports, module) {
    "use strict";
    function checkMatch(nodeA, nodeB) {
      if (nodeA.type === "atrule" && nodeB.type === "atrule") {
        return nodeA.params === nodeB.params && nodeA.name.toLowerCase() === nodeB.name.toLowerCase();
      }
      return nodeA.type === nodeB.type;
    }
    function sameParent(nodeA, nodeB) {
      if (!nodeA.parent) {
        return !nodeB.parent;
      }
      if (!nodeB.parent) {
        return false;
      }
      if (!checkMatch(nodeA.parent, nodeB.parent)) {
        return false;
      }
      return sameParent(nodeA.parent, nodeB.parent);
    }
    module.exports = sameParent;
  }
});

// node_modules/cssnano-utils/src/index.js
var require_src3 = __commonJS({
  "node_modules/cssnano-utils/src/index.js"(exports, module) {
    "use strict";
    var rawCache = require_rawCache();
    var getArguments = require_getArguments();
    var sameParent = require_sameParent();
    module.exports = { rawCache, getArguments, sameParent };
  }
});

// node_modules/colord/index.mjs
var colord_exports = {};
__export(colord_exports, {
  Colord: () => j,
  colord: () => w,
  extend: () => k,
  getFormat: () => I,
  random: () => E
});
var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, I, M, H, $, j, w, S, k, E;
var init_colord = __esm({
  "node_modules/colord/index.mjs"() {
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
      var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
      return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
      var t2, n2, e2;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
      var t2, n2, e2, u2;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2)
        return null;
      var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a2);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
      if (!t(n2) || !t(e2) || !t(u2))
        return null;
      var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
      return f(i2);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
      if (!t(n2) || !t(a2) || !t(o2))
        return null;
      var h2 = function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e2 = t2[n2][0](r2);
        if (e2)
          return [e2, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    I = function(r2) {
      return x(r2)[1];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
        var r3, t2, e2, u2, a2, i2;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    }();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
    E = function() {
      return new j({ r: 255 * Math.random(), g: 255 * Math.random(), b: 255 * Math.random() });
    };
  }
});

// node_modules/colord/plugins/names.mjs
var names_exports = {};
__export(names_exports, {
  default: () => names_default
});
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2)
    r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length)
        for (var c2 in a2)
          l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "node_modules/colord/plugins/names.mjs"() {
  }
});

// node_modules/postcss-minify-gradients/src/isColorStop.js
var require_isColorStop = __commonJS({
  "node_modules/postcss-minify-gradients/src/isColorStop.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    var { colord, extend } = (init_colord(), __toCommonJS(colord_exports));
    var namesPlugin = (init_names(), __toCommonJS(names_exports));
    extend([namesPlugin]);
    var lengthUnits = /* @__PURE__ */ new Set([
      "PX",
      "IN",
      "CM",
      "MM",
      "EM",
      "REM",
      "POINTS",
      "PC",
      "EX",
      "CH",
      "VW",
      "VH",
      "VMIN",
      "VMAX",
      "%"
    ]);
    function isCSSLengthUnit(input) {
      return lengthUnits.has(input.toUpperCase());
    }
    function isStop(str) {
      if (str) {
        let stop = false;
        const node = unit(str);
        if (node) {
          const number = Number(node.number);
          if (number === 0 || !isNaN(number) && isCSSLengthUnit(node.unit)) {
            stop = true;
          }
        } else {
          stop = /^calc\(\S+\)$/g.test(str);
        }
        return stop;
      }
      return true;
    }
    module.exports = function isColorStop(color, stop) {
      return colord(color).isValid() && isStop(stop);
    };
  }
});

// node_modules/postcss-minify-gradients/src/index.js
var require_src4 = __commonJS({
  "node_modules/postcss-minify-gradients/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var { getArguments } = require_src3();
    var isColorStop = require_isColorStop();
    var angles = {
      top: "0deg",
      right: "90deg",
      bottom: "180deg",
      left: "270deg"
    };
    function isLessThan(a2, b2) {
      return a2.unit.toLowerCase() === b2.unit.toLowerCase() && parseFloat(a2.number) >= parseFloat(b2.number);
    }
    function optimise(decl) {
      const value = decl.value;
      if (!value) {
        return;
      }
      const normalizedValue = value.toLowerCase();
      if (normalizedValue.includes("var(") || normalizedValue.includes("env(")) {
        return;
      }
      if (!normalizedValue.includes("gradient")) {
        return;
      }
      decl.value = valueParser(value).walk((node) => {
        if (node.type !== "function" || !node.nodes.length) {
          return false;
        }
        const lowerCasedValue = node.value.toLowerCase();
        if (lowerCasedValue === "linear-gradient" || lowerCasedValue === "repeating-linear-gradient" || lowerCasedValue === "-webkit-linear-gradient" || lowerCasedValue === "-webkit-repeating-linear-gradient") {
          let args = getArguments(node);
          if (node.nodes[0].value.toLowerCase() === "to" && args[0].length === 3) {
            node.nodes = node.nodes.slice(2);
            node.nodes[0].value = angles[node.nodes[0].value.toLowerCase()];
          }
          let lastStop;
          args.forEach((arg, index) => {
            if (arg.length !== 3) {
              return;
            }
            let isFinalStop = index === args.length - 1;
            let thisStop = valueParser.unit(arg[2].value);
            if (lastStop === void 0) {
              lastStop = thisStop;
              if (!isFinalStop && lastStop && lastStop.number === "0" && lastStop.unit.toLowerCase() !== "deg") {
                arg[1].value = arg[2].value = "";
              }
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
            if (isFinalStop && arg[2].value === "100%") {
              arg[1].value = arg[2].value = "";
            }
          });
          return false;
        }
        if (lowerCasedValue === "radial-gradient" || lowerCasedValue === "repeating-radial-gradient") {
          let args = getArguments(node);
          let lastStop;
          const hasAt = args[0].find((n2) => n2.value.toLowerCase() === "at");
          args.forEach((arg, index) => {
            if (!arg[2] || !index && hasAt) {
              return;
            }
            let thisStop = valueParser.unit(arg[2].value);
            if (!lastStop) {
              lastStop = thisStop;
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
          });
          return false;
        }
        if (lowerCasedValue === "-webkit-radial-gradient" || lowerCasedValue === "-webkit-repeating-radial-gradient") {
          let args = getArguments(node);
          let lastStop;
          args.forEach((arg) => {
            let color;
            let stop;
            if (arg[2] !== void 0) {
              if (arg[0].type === "function") {
                color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;
              } else {
                color = arg[0].value;
              }
              if (arg[2].type === "function") {
                stop = `${arg[2].value}(${valueParser.stringify(arg[2].nodes)})`;
              } else {
                stop = arg[2].value;
              }
            } else {
              if (arg[0].type === "function") {
                color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;
              }
              color = arg[0].value;
            }
            color = color.toLowerCase();
            const colorStop = stop !== void 0 ? isColorStop(color, stop.toLowerCase()) : isColorStop(color);
            if (!colorStop || !arg[2]) {
              return;
            }
            let thisStop = valueParser.unit(arg[2].value);
            if (!lastStop) {
              lastStop = thisStop;
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
          });
          return false;
        }
      }).toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-minify-gradients",
        OnceExit(css) {
          css.walkDecls(optimise);
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType.Root;
    exports.Text = ElementType.Text;
    exports.Directive = ElementType.Directive;
    exports.Comment = ElementType.Comment;
    exports.Script = ElementType.Script;
    exports.Style = ElementType.Style;
    exports.Tag = ElementType.Tag;
    exports.CDATA = ElementType.CDATA;
    exports.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib2();
    var nodeTypes = /* @__PURE__ */ new Map([
      [domelementtype_1.ElementType.Tag, 1],
      [domelementtype_1.ElementType.Script, 1],
      [domelementtype_1.ElementType.Style, 1],
      [domelementtype_1.ElementType.Directive, 1],
      [domelementtype_1.ElementType.Text, 3],
      [domelementtype_1.ElementType.CDATA, 4],
      [domelementtype_1.ElementType.Comment, 8],
      [domelementtype_1.ElementType.Root, 9]
    ]);
    var Node4 = function() {
      function Node5(type) {
        this.type = type;
        this.parent = null;
        this.prev = null;
        this.next = null;
        this.startIndex = null;
        this.endIndex = null;
      }
      Object.defineProperty(Node5.prototype, "nodeType", {
        get: function() {
          var _a;
          return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node5.prototype, "parentNode", {
        get: function() {
          return this.parent;
        },
        set: function(parent) {
          this.parent = parent;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node5.prototype, "previousSibling", {
        get: function() {
          return this.prev;
        },
        set: function(prev) {
          this.prev = prev;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node5.prototype, "nextSibling", {
        get: function() {
          return this.next;
        },
        set: function(next) {
          this.next = next;
        },
        enumerable: false,
        configurable: true
      });
      Node5.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        return cloneNode(this, recursive);
      };
      return Node5;
    }();
    exports.Node = Node4;
    var DataNode = function(_super) {
      __extends(DataNode2, _super);
      function DataNode2(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
      }
      Object.defineProperty(DataNode2.prototype, "nodeValue", {
        get: function() {
          return this.data;
        },
        set: function(data) {
          this.data = data;
        },
        enumerable: false,
        configurable: true
      });
      return DataNode2;
    }(Node4);
    exports.DataNode = DataNode;
    var Text = function(_super) {
      __extends(Text2, _super);
      function Text2(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
      }
      return Text2;
    }(DataNode);
    exports.Text = Text;
    var Comment2 = function(_super) {
      __extends(Comment3, _super);
      function Comment3(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
      }
      return Comment3;
    }(DataNode);
    exports.Comment = Comment2;
    var ProcessingInstruction = function(_super) {
      __extends(ProcessingInstruction2, _super);
      function ProcessingInstruction2(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
      }
      return ProcessingInstruction2;
    }(DataNode);
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = function(_super) {
      __extends(NodeWithChildren2, _super);
      function NodeWithChildren2(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
      }
      Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
        get: function() {
          var _a;
          return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
        get: function() {
          return this.children;
        },
        set: function(children) {
          this.children = children;
        },
        enumerable: false,
        configurable: true
      });
      return NodeWithChildren2;
    }(Node4);
    exports.NodeWithChildren = NodeWithChildren;
    var Document3 = function(_super) {
      __extends(Document4, _super);
      function Document4(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
      }
      return Document4;
    }(NodeWithChildren);
    exports.Document = Document3;
    var Element = function(_super) {
      __extends(Element2, _super);
      function Element2(name, attribs, children, type) {
        if (children === void 0) {
          children = [];
        }
        if (type === void 0) {
          type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
      }
      Object.defineProperty(Element2.prototype, "tagName", {
        get: function() {
          return this.name;
        },
        set: function(name) {
          this.name = name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element2.prototype, "attributes", {
        get: function() {
          var _this = this;
          return Object.keys(this.attribs).map(function(name) {
            var _a, _b;
            return {
              name,
              value: _this.attribs[name],
              namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
              prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
            };
          });
        },
        enumerable: false,
        configurable: true
      });
      return Element2;
    }(NodeWithChildren);
    exports.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment2(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document3(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i2 = 1; i2 < children.length; i2++) {
        children[i2].prev = children[i2 - 1];
        children[i2 - 1].next = children[i2];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib2();
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = function() {
      function DomHandler2(callback, options, elementCB) {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options === "function") {
          elementCB = options;
          options = defaultOpts;
        }
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser) {
        this.parser = parser;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
        var element = new node_1.Element(name, attribs, void 0, type);
        this.addNode(element);
        this.tagStack.push(element);
      };
      DomHandler2.prototype.ontext = function(data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
          if (normalizeWhitespace) {
            lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
          } else {
            lastNode.data += data;
          }
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          if (normalizeWhitespace) {
            data = data.replace(reWhitespace, " ");
          }
          var node = new node_1.Text(data);
          this.addNode(node);
          this.lastNode = node;
        }
      };
      DomHandler2.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
          this.lastNode.data += data;
          return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
          node.prev = previousSibling;
          previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }();
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "node_modules/entities/lib/maps/legacy.json"(exports, module) {
    module.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "node_modules/entities/lib/maps/xml.json"(exports, module) {
    module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "node_modules/entities/lib/maps/decode.json"(exports, module) {
    module.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    var fromCodePoint = String.fromCodePoint || function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      return fromCodePoint(codePoint);
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map2) {
      var replace = getReplacer(map2);
      return function(str) {
        return String(str).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a2, b2) {
      return a2 < b2 ? 1 : -1;
    };
    exports.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i2 = 0, j2 = 0; i2 < keys.length; i2++) {
        if (legacy[j2] === keys[i2]) {
          keys[i2] += ";?";
          j2++;
        } else {
          keys[i2] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str) {
        if (str.substr(-1) !== ";")
          str += ";";
        return replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    }();
    function getReplacer(map2) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map2[str.slice(1, -1)] || str;
      };
    }
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k2 = _a[_i];
        if (k2.length === 1) {
          single.push("\\" + k2);
        } else {
          multiple.push(k2);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count = 1 + end - start;
        if (count < 3)
          continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = String.prototype.codePointAt != null ? function(str) {
      return str.codePointAt(0);
    } : function(c2) {
      return (c2.charCodeAt(0) - 55296) * 1024 + c2.charCodeAt(1) - 56320 + 65536;
    };
    function singleCharReplacer(c2) {
      return "&#x" + (c2.length > 1 ? getCodePoint(c2) : c2.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c2) {
          return obj[c2] || singleCharReplacer(c2);
        });
      };
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = /* @__PURE__ */ new Map([
      ["altglyph", "altGlyph"],
      ["altglyphdef", "altGlyphDef"],
      ["altglyphitem", "altGlyphItem"],
      ["animatecolor", "animateColor"],
      ["animatemotion", "animateMotion"],
      ["animatetransform", "animateTransform"],
      ["clippath", "clipPath"],
      ["feblend", "feBlend"],
      ["fecolormatrix", "feColorMatrix"],
      ["fecomponenttransfer", "feComponentTransfer"],
      ["fecomposite", "feComposite"],
      ["feconvolvematrix", "feConvolveMatrix"],
      ["fediffuselighting", "feDiffuseLighting"],
      ["fedisplacementmap", "feDisplacementMap"],
      ["fedistantlight", "feDistantLight"],
      ["fedropshadow", "feDropShadow"],
      ["feflood", "feFlood"],
      ["fefunca", "feFuncA"],
      ["fefuncb", "feFuncB"],
      ["fefuncg", "feFuncG"],
      ["fefuncr", "feFuncR"],
      ["fegaussianblur", "feGaussianBlur"],
      ["feimage", "feImage"],
      ["femerge", "feMerge"],
      ["femergenode", "feMergeNode"],
      ["femorphology", "feMorphology"],
      ["feoffset", "feOffset"],
      ["fepointlight", "fePointLight"],
      ["fespecularlighting", "feSpecularLighting"],
      ["fespotlight", "feSpotLight"],
      ["fetile", "feTile"],
      ["feturbulence", "feTurbulence"],
      ["foreignobject", "foreignObject"],
      ["glyphref", "glyphRef"],
      ["lineargradient", "linearGradient"],
      ["radialgradient", "radialGradient"],
      ["textpath", "textPath"]
    ]);
    exports.attributeNames = /* @__PURE__ */ new Map([
      ["definitionurl", "definitionURL"],
      ["attributename", "attributeName"],
      ["attributetype", "attributeType"],
      ["basefrequency", "baseFrequency"],
      ["baseprofile", "baseProfile"],
      ["calcmode", "calcMode"],
      ["clippathunits", "clipPathUnits"],
      ["diffuseconstant", "diffuseConstant"],
      ["edgemode", "edgeMode"],
      ["filterunits", "filterUnits"],
      ["glyphref", "glyphRef"],
      ["gradienttransform", "gradientTransform"],
      ["gradientunits", "gradientUnits"],
      ["kernelmatrix", "kernelMatrix"],
      ["kernelunitlength", "kernelUnitLength"],
      ["keypoints", "keyPoints"],
      ["keysplines", "keySplines"],
      ["keytimes", "keyTimes"],
      ["lengthadjust", "lengthAdjust"],
      ["limitingconeangle", "limitingConeAngle"],
      ["markerheight", "markerHeight"],
      ["markerunits", "markerUnits"],
      ["markerwidth", "markerWidth"],
      ["maskcontentunits", "maskContentUnits"],
      ["maskunits", "maskUnits"],
      ["numoctaves", "numOctaves"],
      ["pathlength", "pathLength"],
      ["patterncontentunits", "patternContentUnits"],
      ["patterntransform", "patternTransform"],
      ["patternunits", "patternUnits"],
      ["pointsatx", "pointsAtX"],
      ["pointsaty", "pointsAtY"],
      ["pointsatz", "pointsAtZ"],
      ["preservealpha", "preserveAlpha"],
      ["preserveaspectratio", "preserveAspectRatio"],
      ["primitiveunits", "primitiveUnits"],
      ["refx", "refX"],
      ["refy", "refY"],
      ["repeatcount", "repeatCount"],
      ["repeatdur", "repeatDur"],
      ["requiredextensions", "requiredExtensions"],
      ["requiredfeatures", "requiredFeatures"],
      ["specularconstant", "specularConstant"],
      ["specularexponent", "specularExponent"],
      ["spreadmethod", "spreadMethod"],
      ["startoffset", "startOffset"],
      ["stddeviation", "stdDeviation"],
      ["stitchtiles", "stitchTiles"],
      ["surfacescale", "surfaceScale"],
      ["systemlanguage", "systemLanguage"],
      ["tablevalues", "tableValues"],
      ["targetx", "targetX"],
      ["targety", "targetY"],
      ["textlength", "textLength"],
      ["viewbox", "viewBox"],
      ["viewtarget", "viewTarget"],
      ["xchannelselector", "xChannelSelector"],
      ["ychannelselector", "yChannelSelector"],
      ["zoomandpan", "zoomAndPan"]
    ]);
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ElementType = __importStar(require_lib2());
    var entities_1 = require_lib4();
    var foreignNames_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function formatAttributes(attributes, opts) {
      if (!attributes)
        return;
      return Object.keys(attributes).map(function(key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return key + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i2 = 0; i2 < nodes.length; i2++) {
        output += renderNode(nodes[i2], options);
      }
      return output;
    }
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<" + elem.name;
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib3();
    var dom_serializer_1 = __importDefault(require_lib5());
    var domelementtype_1 = require_lib2();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib3();
    var emptyArray = [];
    function getChildren(elem) {
      var _a;
      return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
    }
    exports.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib3();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find(test, node, recurse, limit);
    }
    exports.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children = find(test, elem.children, recurse, limit);
          result.push.apply(result, children);
          limit -= children.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    exports.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
        var checked = nodes[i2];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a;
      var result = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
          stack.unshift.apply(stack, children);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
    exports.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib3();
    var querying_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a2, b2) {
      return function(elem) {
        return a2(elem) || b2(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib3();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return 1;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return 4 | 16;
        }
        return 4;
      }
      if (sharedParent === nodeA) {
        return 2 | 8;
      }
      return 2;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i2, arr) {
        return !arr.includes(node, i2 + 1);
      });
      nodes.sort(function(a2, b2) {
        var relative = compareDocumentPosition(a2, b2);
        if (relative & 2) {
          return -1;
        } else if (relative & 4) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_1 = require_stringify();
    var legacy_1 = require_legacy2();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
          if (href2) {
            entry.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs.medium,
          isDefault: !!attribs.isDefault
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs.expression) {
          media.expression = attribs.expression;
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy2(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib3();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/es/types.js
var SelectorType, IgnoreCaseMode, AttributeAction;
var init_types = __esm({
  "node_modules/css-what/lib/es/types.js"() {
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType || (SelectorType = {}));
    IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction || (AttributeAction = {}));
  }
});

// node_modules/css-what/lib/es/parse.js
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse3(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name = getName(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name = getName(2);
          } else {
            name = getName(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name;
              name = getName(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name = getName(1).toLowerCase();
          let data = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
              }
              data = [];
              selectorIndex = parseSelector(data, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name)) {
                const quot = data.charCodeAt(0);
                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                  data = data.slice(1, -1);
                }
              }
              data = unescapeCSS(data);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name, data });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name;
          if (firstChar === 42) {
            selectorIndex += 1;
            name = "*";
          } else if (firstChar === 124) {
            name = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name = getName(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name = "*";
              selectorIndex += 2;
            } else {
              name = getName(1);
            }
          }
          tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
var reName, reEscape, actionTypes, unpackPseudos, stripQuotesFromPseudos;
var init_parse = __esm({
  "node_modules/css-what/lib/es/parse.js"() {
    init_types();
    reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    actionTypes = /* @__PURE__ */ new Map([
      [126, AttributeAction.Element],
      [94, AttributeAction.Start],
      [36, AttributeAction.End],
      [42, AttributeAction.Any],
      [33, AttributeAction.Not],
      [124, AttributeAction.Hyphen]
    ]);
    unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
  }
});

// node_modules/css-what/lib/es/stringify.js
function stringify16(selector) {
  return selector.map((token) => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    case SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : `${getNamespace(token.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token);
    case SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify16(token.data)})`}`;
    case SelectorType.Attribute: {
      if (token.name === "id" && token.action === AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
        return `#${escapeName(token.value, charsToEscapeInName)}`;
      }
      if (token.name === "class" && token.action === AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
        return `.${escapeName(token.value, charsToEscapeInName)}`;
      }
      const name = getNamespacedName(token);
      if (token.action === AttributeAction.Exists) {
        return `[${name}]`;
      }
      return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    if (charsToEscape.has(str.charCodeAt(i2))) {
      ret += `${str.slice(lastIdx, i2)}\\${str.charAt(i2)}`;
      lastIdx = i2 + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
var attribValChars, pseudoValChars, charsToEscapeInAttributeValue, charsToEscapeInPseudoValue, charsToEscapeInName;
var init_stringify = __esm({
  "node_modules/css-what/lib/es/stringify.js"() {
    init_types();
    attribValChars = ["\\", '"'];
    pseudoValChars = [...attribValChars, "(", ")"];
    charsToEscapeInAttributeValue = new Set(attribValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInName = new Set([
      ...pseudoValChars,
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ].map((c2) => c2.charCodeAt(0)));
  }
});

// node_modules/css-what/lib/es/index.js
var es_exports = {};
__export(es_exports, {
  AttributeAction: () => AttributeAction,
  IgnoreCaseMode: () => IgnoreCaseMode,
  SelectorType: () => SelectorType,
  isTraversal: () => isTraversal,
  parse: () => parse3,
  stringify: () => stringify16
});
var init_es = __esm({
  "node_modules/css-what/lib/es/index.js"() {
    init_types();
    init_parse();
    init_stringify();
  }
});

// node_modules/css-select/lib/procedure.js
var require_procedure = __commonJS({
  "node_modules/css-select/lib/procedure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = exports.procedure = void 0;
    exports.procedure = {
      universal: 50,
      tag: 30,
      attribute: 1,
      pseudo: 0,
      "pseudo-element": 0,
      "column-combinator": -1,
      descendant: -1,
      child: -1,
      parent: -1,
      sibling: -1,
      adjacent: -1,
      _flexibleDescendant: -1
    };
    function isTraversal2(t2) {
      return exports.procedure[t2.type] < 0;
    }
    exports.isTraversal = isTraversal2;
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var procedure_1 = require_procedure();
    var attributes = {
      exists: 10,
      equals: 8,
      not: 7,
      start: 6,
      end: 6,
      any: 5,
      hyphen: 4,
      element: 4
    };
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i2 = 1; i2 < arr.length; i2++) {
        var procNew = procs[i2];
        if (procNew < 0)
          continue;
        for (var j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
          var token = arr[j2 + 1];
          arr[j2 + 1] = arr[j2];
          arr[j2] = token;
          procs[j2 + 1] = procs[j2];
          procs[j2] = procNew;
        }
      }
    }
    exports.default = sortByProcedure;
    function getProcedure(token) {
      var proc = procedure_1.procedure[token.type];
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = 0;
          for (var i2 = 0; i2 < token.data.length; i2++) {
            if (token.data[i2].length !== 1)
              continue;
            var cur = getProcedure(token.data[i2][0]);
            if (cur === 0) {
              proc = 0;
              break;
            }
            if (cur > proc)
              proc = cur;
          }
          if (token.data.length > 1 && proc > 0)
            proc -= 1;
        } else {
          proc = 1;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = require_boolbase();
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse4(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a2 = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a2 = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a2, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports.parse = parse4;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = exports.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a2 = parsed[0];
      var b2 = parsed[1] - 1;
      if (b2 < 0 && a2 <= 0)
        return boolbase_1.default.falseFunc;
      if (a2 === -1)
        return function(index) {
          return index <= b2;
        };
      if (a2 === 0)
        return function(index) {
          return index === b2;
        };
      if (a2 === 1)
        return b2 < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b2;
        };
      var absA = Math.abs(a2);
      var bMod = (b2 % absA + absA) % absA;
      return a2 > 1 ? function(index) {
        return index >= b2 && index % absA === bMod;
      } : function(index) {
        return index <= b2 && index % absA === bMod;
      };
    }
    exports.compile = compile;
    function generate(parsed) {
      var a2 = parsed[0];
      var b2 = parsed[1] - 1;
      var n2 = 0;
      if (a2 < 0) {
        var aPos_1 = -a2;
        var minValue_1 = (b2 % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n2++;
          return val > b2 ? null : val;
        };
      }
      if (a2 === 0)
        return b2 < 0 ? function() {
          return null;
        } : function() {
          return n2++ === 0 ? b2 : null;
        };
      if (b2 < 0) {
        b2 += a2 * Math.ceil(-b2 / a2);
      }
      return function() {
        return a2 * n2++ + b2;
      };
    }
    exports.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib7());
    var boolbase_1 = require_boolbase();
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          if (equals(elem, siblings[i2]))
            return true;
          if (adapter.isTag(siblings[i2]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = 0; i2 < siblings.length; i2++) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect) {
      if (subselect === null) {
        if (func.length > 2) {
          throw new Error("pseudo-selector :".concat(name, " requires an argument"));
        }
      } else if (func.length === 2) {
        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = require_boolbase();
    var procedure_1 = require_procedure();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports.getNextSiblings = getNextSiblings;
    var is = function(next, token, options, context, compileToken) {
      var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals
      };
      var func = compileToken(token, opts, context);
      return function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports.subselects = {
      is,
      matches: is,
      where: is,
      not: function(next, token, options, context, compileToken) {
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter: options.adapter,
          equals: options.equals
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
          return next;
        if (func === boolbase_1.trueFunc)
          return boolbase_1.falseFunc;
        return function not(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter,
          equals: options.equals
        };
        var context = subselect.some(function(s2) {
          return s2.some(procedure_1.isTraversal);
        }) ? [exports.PLACEHOLDER_ELEMENT] : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
          return function(elem) {
            return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
          };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        if (context) {
          return function(elem) {
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return next(elem) && adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
    var boolbase_1 = require_boolbase();
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var filters_1 = require_filters();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return filters_1.filters;
    } });
    var pseudos_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudos_1.pseudos;
    } });
    var aliases_1 = require_aliases();
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return aliases_1.aliases;
    } });
    var subselects_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context, compileToken) {
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
      }
      if (name in aliases_1.aliases) {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
      }
      if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
      }
      if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function(elem) {
          return pseudo_1(elem, options, data);
        } : function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("unmatched pseudo-class :".concat(name));
    }
    exports.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_1 = require_attributes();
    var pseudo_selectors_1 = require_pseudo_selectors();
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    function compileGeneralSelector(next, selector, options, context, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = adapter.getParent(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = adapter.getParent(current)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (adapter.isTag(current) && next(current))
                return true;
            } while (current = adapter.getParent(current));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var boolbase_1 = require_boolbase();
    var sort_1 = __importDefault(require_sort());
    var procedure_1 = require_procedure();
    var general_1 = require_general();
    var subselects_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_1.ensureIsTag)(next, options.adapter);
    }
    exports.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context);
    }
    exports.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t2) {
      return t2.type === "pseudo" && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context) {
      var adapter = _a.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e2) {
        var parent = adapter.isTag(e2) && adapter.getParent(e2);
        return e2 === subselects_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t2 = token_1[_i];
        if (t2.length > 0 && (0, procedure_1.isTraversal)(t2[0]) && t2[0].type !== "descendant") {
        } else if (hasContext && !t2.some(includesScopePseudo)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t2.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a;
      token = token.filter(function(t2) {
        return t2.length > 0;
      });
      token.forEach(sort_1.default);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      absolutize(token, options, finalContext);
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== "pseudo" || first.name !== "scope") {
          } else if (isArrayContext && second.type === "descendant") {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === "adjacent" || second.type === "sibling") {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.falseFunc ? boolbase_1.falseFunc : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
    }
    function reduceRules(a2, b2) {
      if (b2 === boolbase_1.falseFunc || a2 === boolbase_1.trueFunc) {
        return a2;
      }
      if (a2 === boolbase_1.falseFunc || b2 === boolbase_1.trueFunc) {
        return b2;
      }
      return function combine(elem) {
        return a2(elem) || b2(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
    var DomUtils = __importStar(require_lib6());
    var boolbase_1 = require_boolbase();
    var compile_1 = require_compile2();
    var subselects_1 = require_subselects();
    var defaultEquals = function(a2, b2) {
      return a2 === b2;
    };
    var defaultOptions2 = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions2;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports.compile = wrapCompile(compile_1.compile);
    exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
    exports._compileToken = wrapCompile(compile_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i2 = 0; i2 < elemsLength; i2++) {
        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i2], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
    }
    exports.is = is;
    exports.default = exports.selectAll;
    var pseudo_selectors_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return pseudo_selectors_1.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudo_selectors_1.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return pseudo_selectors_1.aliases;
    } });
  }
});

// node_modules/svgo/lib/svgo/css-select-adapter.js
var require_css_select_adapter = __commonJS({
  "node_modules/svgo/lib/svgo/css-select-adapter.js"(exports, module) {
    "use strict";
    var isTag = (node) => {
      return node.type === "element";
    };
    var existsOne = (test, elems) => {
      return elems.some((elem) => {
        if (isTag(elem)) {
          return test(elem) || existsOne(test, getChildren(elem));
        } else {
          return false;
        }
      });
    };
    var getAttributeValue = (elem, name) => {
      return elem.attributes[name];
    };
    var getChildren = (node) => {
      return node.children || [];
    };
    var getName = (elemAst) => {
      return elemAst.name;
    };
    var getParent = (node) => {
      return node.parentNode || null;
    };
    var getSiblings = (elem) => {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [];
    };
    var getText = (node) => {
      if (node.children[0].type === "text" && node.children[0].type === "cdata") {
        return node.children[0].value;
      }
      return "";
    };
    var hasAttrib = (elem, name) => {
      return elem.attributes[name] !== void 0;
    };
    var removeSubsets = (nodes) => {
      let idx = nodes.length;
      let node;
      let ancestor;
      let replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.includes(ancestor)) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    };
    var findAll = (test, elems) => {
      const result = [];
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            result.push(elem);
          }
          result.push(...findAll(test, getChildren(elem)));
        }
      }
      return result;
    };
    var findOne = (test, elems) => {
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            return elem;
          }
          const result = findOne(test, getChildren(elem));
          if (result) {
            return result;
          }
        }
      }
      return null;
    };
    var svgoCssSelectAdapter = {
      isTag,
      existsOne,
      getAttributeValue,
      getChildren,
      getName,
      getParent,
      getSiblings,
      getText,
      hasAttrib,
      removeSubsets,
      findAll,
      findOne
    };
    module.exports = svgoCssSelectAdapter;
  }
});

// node_modules/svgo/lib/xast.js
var require_xast = __commonJS({
  "node_modules/svgo/lib/xast.js"(exports) {
    "use strict";
    var { selectAll, selectOne, is } = require_lib8();
    var xastAdaptor = require_css_select_adapter();
    var cssSelectOptions = {
      xmlMode: true,
      adapter: xastAdaptor
    };
    var querySelectorAll = (node, selector) => {
      return selectAll(selector, node, cssSelectOptions);
    };
    exports.querySelectorAll = querySelectorAll;
    var querySelector = (node, selector) => {
      return selectOne(selector, node, cssSelectOptions);
    };
    exports.querySelector = querySelector;
    var matches = (node, selector) => {
      return is(node, selector, cssSelectOptions);
    };
    exports.matches = matches;
    var closestByName = (node, name) => {
      let currentNode = node;
      while (currentNode) {
        if (currentNode.type === "element" && currentNode.name === name) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    exports.closestByName = closestByName;
    var visitSkip = Symbol();
    exports.visitSkip = visitSkip;
    var visit3 = (node, visitor, parentNode) => {
      const callbacks = visitor[node.type];
      if (callbacks && callbacks.enter) {
        const symbol = callbacks.enter(node, parentNode);
        if (symbol === visitSkip) {
          return;
        }
      }
      if (node.type === "root") {
        for (const child of node.children) {
          visit3(child, visitor, node);
        }
      }
      if (node.type === "element") {
        if (parentNode.children.includes(node)) {
          for (const child of node.children) {
            visit3(child, visitor, node);
          }
        }
      }
      if (callbacks && callbacks.exit) {
        callbacks.exit(node, parentNode);
      }
    };
    exports.visit = visit3;
    var detachNodeFromParent = (node, parentNode) => {
      parentNode.children = parentNode.children.filter((child) => child !== node);
    };
    exports.detachNodeFromParent = detachNodeFromParent;
  }
});

// node_modules/svgo/lib/svgo/plugins.js
var require_plugins = __commonJS({
  "node_modules/svgo/lib/svgo/plugins.js"(exports) {
    "use strict";
    var { visit: visit3 } = require_xast();
    var invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
      for (const plugin of plugins) {
        const override = overrides == null ? null : overrides[plugin.name];
        if (override === false) {
          continue;
        }
        const params = { ...plugin.params, ...globalOverrides, ...override };
        if (plugin.type === "perItem") {
          ast = perItem(ast, info, plugin, params);
        }
        if (plugin.type === "perItemReverse") {
          ast = perItem(ast, info, plugin, params, true);
        }
        if (plugin.type === "full") {
          if (plugin.active) {
            ast = plugin.fn(ast, params, info);
          }
        }
        if (plugin.type === "visitor") {
          if (plugin.active) {
            const visitor = plugin.fn(ast, params, info);
            if (visitor != null) {
              visit3(ast, visitor);
            }
          }
        }
      }
      return ast;
    };
    exports.invokePlugins = invokePlugins;
    function perItem(data, info, plugin, params, reverse) {
      function monkeys(items) {
        items.children = items.children.filter(function(item) {
          if (reverse && item.children) {
            monkeys(item);
          }
          let kept = true;
          if (plugin.active) {
            kept = plugin.fn(item, params, info) !== false;
          }
          if (!reverse && item.children) {
            monkeys(item);
          }
          return kept;
        });
        return items;
      }
      return monkeys(data);
    }
    var createPreset = ({ name, plugins }) => {
      return {
        name,
        type: "full",
        fn: (ast, params, info) => {
          const { floatPrecision, overrides } = params;
          const globalOverrides = {};
          if (floatPrecision != null) {
            globalOverrides.floatPrecision = floatPrecision;
          }
          if (overrides) {
            for (const [pluginName, override] of Object.entries(overrides)) {
              if (override === true) {
                console.warn(
                  `You are trying to enable ${pluginName} which is not part of preset.
Try to put it before or after preset, for example

plugins: [
  {
    name: 'preset-default',
  },
  'cleanupListOfValues'
]
`
                );
              }
            }
          }
          return invokePlugins(ast, info, plugins, overrides, globalOverrides);
        }
      };
    };
    exports.createPreset = createPreset;
  }
});

// node_modules/svgo/plugins/removeDoctype.js
var require_removeDoctype = __commonJS({
  "node_modules/svgo/plugins/removeDoctype.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeDoctype";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes doctype declaration";
    exports.fn = () => {
      return {
        doctype: {
          enter: (node, parentNode) => {
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLProcInst.js
var require_removeXMLProcInst = __commonJS({
  "node_modules/svgo/plugins/removeXMLProcInst.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeXMLProcInst";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes XML processing instructions";
    exports.fn = () => {
      return {
        instruction: {
          enter: (node, parentNode) => {
            if (node.name === "xml") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/svgo/plugins/removeComments.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeComments";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes comments";
    exports.fn = () => {
      return {
        comment: {
          enter: (node, parentNode) => {
            if (node.value.charAt(0) !== "!") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeMetadata.js
var require_removeMetadata = __commonJS({
  "node_modules/svgo/plugins/removeMetadata.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeMetadata";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes <metadata>";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "metadata") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/_collections.js
var require_collections = __commonJS({
  "node_modules/svgo/plugins/_collections.js"(exports) {
    "use strict";
    exports.elemsGroups = {
      animation: [
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "set"
      ],
      descriptive: ["desc", "metadata", "title"],
      shape: ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect"],
      structural: ["defs", "g", "svg", "symbol", "use"],
      paintServer: [
        "solidColor",
        "linearGradient",
        "radialGradient",
        "meshGradient",
        "pattern",
        "hatch"
      ],
      nonRendering: [
        "linearGradient",
        "radialGradient",
        "pattern",
        "clipPath",
        "mask",
        "marker",
        "symbol",
        "filter",
        "solidColor"
      ],
      container: [
        "a",
        "defs",
        "g",
        "marker",
        "mask",
        "missing-glyph",
        "pattern",
        "svg",
        "switch",
        "symbol",
        "foreignObject"
      ],
      textContent: [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "glyph",
        "glyphRef",
        "textPath",
        "text",
        "tref",
        "tspan"
      ],
      textContentChild: ["altGlyph", "textPath", "tref", "tspan"],
      lightSource: [
        "feDiffuseLighting",
        "feSpecularLighting",
        "feDistantLight",
        "fePointLight",
        "feSpotLight"
      ],
      filterPrimitive: [
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "feSpecularLighting",
        "feTile",
        "feTurbulence"
      ]
    };
    exports.textElems = exports.elemsGroups.textContent.concat("title");
    exports.pathElems = ["path", "glyph", "missing-glyph"];
    exports.attrsGroups = {
      animationAddition: ["additive", "accumulate"],
      animationAttributeTarget: ["attributeType", "attributeName"],
      animationEvent: ["onbegin", "onend", "onrepeat", "onload"],
      animationTiming: [
        "begin",
        "dur",
        "end",
        "min",
        "max",
        "restart",
        "repeatCount",
        "repeatDur",
        "fill"
      ],
      animationValue: [
        "calcMode",
        "values",
        "keyTimes",
        "keySplines",
        "from",
        "to",
        "by"
      ],
      conditionalProcessing: [
        "requiredFeatures",
        "requiredExtensions",
        "systemLanguage"
      ],
      core: ["id", "tabindex", "xml:base", "xml:lang", "xml:space"],
      graphicalEvent: [
        "onfocusin",
        "onfocusout",
        "onactivate",
        "onclick",
        "onmousedown",
        "onmouseup",
        "onmouseover",
        "onmousemove",
        "onmouseout",
        "onload"
      ],
      presentation: [
        "alignment-baseline",
        "baseline-shift",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "enable-background",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform",
        "transform-origin",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "word-spacing",
        "writing-mode"
      ],
      xlink: [
        "xlink:href",
        "xlink:show",
        "xlink:actuate",
        "xlink:type",
        "xlink:role",
        "xlink:arcrole",
        "xlink:title"
      ],
      documentEvent: [
        "onunload",
        "onabort",
        "onerror",
        "onresize",
        "onscroll",
        "onzoom"
      ],
      filterPrimitive: ["x", "y", "width", "height", "result"],
      transferFunction: [
        "type",
        "tableValues",
        "slope",
        "intercept",
        "amplitude",
        "exponent",
        "offset"
      ]
    };
    exports.attrsGroupsDefaults = {
      core: { "xml:space": "default" },
      presentation: {
        clip: "auto",
        "clip-path": "none",
        "clip-rule": "nonzero",
        mask: "none",
        opacity: "1",
        "stop-color": "#000",
        "stop-opacity": "1",
        "fill-opacity": "1",
        "fill-rule": "nonzero",
        fill: "#000",
        stroke: "none",
        "stroke-width": "1",
        "stroke-linecap": "butt",
        "stroke-linejoin": "miter",
        "stroke-miterlimit": "4",
        "stroke-dasharray": "none",
        "stroke-dashoffset": "0",
        "stroke-opacity": "1",
        "paint-order": "normal",
        "vector-effect": "none",
        display: "inline",
        visibility: "visible",
        "marker-start": "none",
        "marker-mid": "none",
        "marker-end": "none",
        "color-interpolation": "sRGB",
        "color-interpolation-filters": "linearRGB",
        "color-rendering": "auto",
        "shape-rendering": "auto",
        "text-rendering": "auto",
        "image-rendering": "auto",
        "font-style": "normal",
        "font-variant": "normal",
        "font-weight": "normal",
        "font-stretch": "normal",
        "font-size": "medium",
        "font-size-adjust": "none",
        kerning: "auto",
        "letter-spacing": "normal",
        "word-spacing": "normal",
        "text-decoration": "none",
        "text-anchor": "start",
        "text-overflow": "clip",
        "writing-mode": "lr-tb",
        "glyph-orientation-vertical": "auto",
        "glyph-orientation-horizontal": "0deg",
        direction: "ltr",
        "unicode-bidi": "normal",
        "dominant-baseline": "auto",
        "alignment-baseline": "baseline",
        "baseline-shift": "baseline"
      },
      transferFunction: {
        slope: "1",
        intercept: "0",
        amplitude: "1",
        exponent: "1",
        offset: "0"
      }
    };
    exports.elems = {
      a: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "target"
        ],
        defaults: {
          target: "_self"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view",
          "tspan"
        ]
      },
      altGlyph: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "dx",
          "dy",
          "glyphRef",
          "format",
          "rotate"
        ]
      },
      altGlyphDef: {
        attrsGroups: ["core"],
        content: ["glyphRef"]
      },
      altGlyphItem: {
        attrsGroups: ["core"],
        content: ["glyphRef", "altGlyphItem"]
      },
      animate: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationAddition",
          "animationAttributeTarget",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "presentation",
          "xlink"
        ],
        attrs: ["externalResourcesRequired"],
        contentGroups: ["descriptive"]
      },
      animateColor: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationAttributeTarget",
          "animationTiming",
          "animationValue",
          "animationAddition",
          "presentation"
        ],
        attrs: ["externalResourcesRequired"],
        contentGroups: ["descriptive"]
      },
      animateMotion: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationTiming",
          "animationValue",
          "animationAddition"
        ],
        attrs: [
          "externalResourcesRequired",
          "path",
          "keyPoints",
          "rotate",
          "origin"
        ],
        defaults: {
          rotate: "0"
        },
        contentGroups: ["descriptive"],
        content: ["mpath"]
      },
      animateTransform: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationAttributeTarget",
          "animationTiming",
          "animationValue",
          "animationAddition"
        ],
        attrs: ["externalResourcesRequired", "type"],
        contentGroups: ["descriptive"]
      },
      circle: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "cx",
          "cy",
          "r"
        ],
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      clipPath: {
        attrsGroups: ["conditionalProcessing", "core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "clipPathUnits"
        ],
        defaults: {
          clipPathUnits: "userSpaceOnUse"
        },
        contentGroups: ["animation", "descriptive", "shape"],
        content: ["text", "use"]
      },
      "color-profile": {
        attrsGroups: ["core", "xlink"],
        attrs: ["local", "name", "rendering-intent"],
        defaults: {
          name: "sRGB",
          "rendering-intent": "auto"
        },
        contentGroups: ["descriptive"]
      },
      cursor: {
        attrsGroups: ["core", "conditionalProcessing", "xlink"],
        attrs: ["externalResourcesRequired", "x", "y"],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["descriptive"]
      },
      defs: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      desc: {
        attrsGroups: ["core"],
        attrs: ["class", "style"]
      },
      ellipse: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "cx",
          "cy",
          "rx",
          "ry"
        ],
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      feBlend: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "in2",
          "mode"
        ],
        defaults: {
          mode: "normal"
        },
        content: ["animate", "set"]
      },
      feColorMatrix: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "type", "values"],
        defaults: {
          type: "matrix"
        },
        content: ["animate", "set"]
      },
      feComponentTransfer: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in"],
        content: ["feFuncA", "feFuncB", "feFuncG", "feFuncR"]
      },
      feComposite: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "in2", "operator", "k1", "k2", "k3", "k4"],
        defaults: {
          operator: "over",
          k1: "0",
          k2: "0",
          k3: "0",
          k4: "0"
        },
        content: ["animate", "set"]
      },
      feConvolveMatrix: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "order",
          "kernelMatrix",
          "divisor",
          "bias",
          "targetX",
          "targetY",
          "edgeMode",
          "kernelUnitLength",
          "preserveAlpha"
        ],
        defaults: {
          order: "3",
          bias: "0",
          edgeMode: "duplicate",
          preserveAlpha: "false"
        },
        content: ["animate", "set"]
      },
      feDiffuseLighting: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "surfaceScale",
          "diffuseConstant",
          "kernelUnitLength"
        ],
        defaults: {
          surfaceScale: "1",
          diffuseConstant: "1"
        },
        contentGroups: ["descriptive"],
        content: [
          "feDistantLight",
          "fePointLight",
          "feSpotLight"
        ]
      },
      feDisplacementMap: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "in2",
          "scale",
          "xChannelSelector",
          "yChannelSelector"
        ],
        defaults: {
          scale: "0",
          xChannelSelector: "A",
          yChannelSelector: "A"
        },
        content: ["animate", "set"]
      },
      feDistantLight: {
        attrsGroups: ["core"],
        attrs: ["azimuth", "elevation"],
        defaults: {
          azimuth: "0",
          elevation: "0"
        },
        content: ["animate", "set"]
      },
      feFlood: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style"],
        content: ["animate", "animateColor", "set"]
      },
      feFuncA: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncB: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncG: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncR: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feGaussianBlur: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "stdDeviation"],
        defaults: {
          stdDeviation: "0"
        },
        content: ["set", "animate"]
      },
      feImage: {
        attrsGroups: ["core", "presentation", "filterPrimitive", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "href",
          "xlink:href"
        ],
        defaults: {
          preserveAspectRatio: "xMidYMid meet"
        },
        content: ["animate", "animateTransform", "set"]
      },
      feMerge: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style"],
        content: ["feMergeNode"]
      },
      feMergeNode: {
        attrsGroups: ["core"],
        attrs: ["in"],
        content: ["animate", "set"]
      },
      feMorphology: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "operator", "radius"],
        defaults: {
          operator: "erode",
          radius: "0"
        },
        content: ["animate", "set"]
      },
      feOffset: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "dx", "dy"],
        defaults: {
          dx: "0",
          dy: "0"
        },
        content: ["animate", "set"]
      },
      fePointLight: {
        attrsGroups: ["core"],
        attrs: ["x", "y", "z"],
        defaults: {
          x: "0",
          y: "0",
          z: "0"
        },
        content: ["animate", "set"]
      },
      feSpecularLighting: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "surfaceScale",
          "specularConstant",
          "specularExponent",
          "kernelUnitLength"
        ],
        defaults: {
          surfaceScale: "1",
          specularConstant: "1",
          specularExponent: "1"
        },
        contentGroups: [
          "descriptive",
          "lightSource"
        ]
      },
      feSpotLight: {
        attrsGroups: ["core"],
        attrs: [
          "x",
          "y",
          "z",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "specularExponent",
          "limitingConeAngle"
        ],
        defaults: {
          x: "0",
          y: "0",
          z: "0",
          pointsAtX: "0",
          pointsAtY: "0",
          pointsAtZ: "0",
          specularExponent: "1"
        },
        content: ["animate", "set"]
      },
      feTile: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in"],
        content: ["animate", "set"]
      },
      feTurbulence: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "baseFrequency",
          "numOctaves",
          "seed",
          "stitchTiles",
          "type"
        ],
        defaults: {
          baseFrequency: "0",
          numOctaves: "1",
          seed: "0",
          stitchTiles: "noStitch",
          type: "turbulence"
        },
        content: ["animate", "set"]
      },
      filter: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "width",
          "height",
          "filterRes",
          "filterUnits",
          "primitiveUnits",
          "href",
          "xlink:href"
        ],
        defaults: {
          primitiveUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: ["descriptive", "filterPrimitive"],
        content: ["animate", "set"]
      },
      font: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "horiz-origin-x",
          "horiz-origin-y",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        defaults: {
          "horiz-origin-x": "0",
          "horiz-origin-y": "0"
        },
        contentGroups: ["descriptive"],
        content: ["font-face", "glyph", "hkern", "missing-glyph", "vkern"]
      },
      "font-face": {
        attrsGroups: ["core"],
        attrs: [
          "font-family",
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "unicode-range",
          "units-per-em",
          "panose-1",
          "stemv",
          "stemh",
          "slope",
          "cap-height",
          "x-height",
          "accent-height",
          "ascent",
          "descent",
          "widths",
          "bbox",
          "ideographic",
          "alphabetic",
          "mathematical",
          "hanging",
          "v-ideographic",
          "v-alphabetic",
          "v-mathematical",
          "v-hanging",
          "underline-position",
          "underline-thickness",
          "strikethrough-position",
          "strikethrough-thickness",
          "overline-position",
          "overline-thickness"
        ],
        defaults: {
          "font-style": "all",
          "font-variant": "normal",
          "font-weight": "all",
          "font-stretch": "normal",
          "unicode-range": "U+0-10FFFF",
          "units-per-em": "1000",
          "panose-1": "0 0 0 0 0 0 0 0 0 0",
          slope: "0"
        },
        contentGroups: ["descriptive"],
        content: [
          "font-face-src"
        ]
      },
      "font-face-format": {
        attrsGroups: ["core"],
        attrs: ["string"]
      },
      "font-face-name": {
        attrsGroups: ["core"],
        attrs: ["name"]
      },
      "font-face-src": {
        attrsGroups: ["core"],
        content: ["font-face-name", "font-face-uri"]
      },
      "font-face-uri": {
        attrsGroups: ["core", "xlink"],
        attrs: ["href", "xlink:href"],
        content: ["font-face-format"]
      },
      foreignObject: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height"
        ],
        defaults: {
          x: "0",
          y: "0"
        }
      },
      g: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      glyph: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y",
          "unicode",
          "glyph-name",
          "orientation",
          "arabic-form",
          "lang"
        ],
        defaults: {
          "arabic-form": "initial"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      glyphRef: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      hatch: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "x",
          "y",
          "pitch",
          "rotate",
          "hatchUnits",
          "hatchContentUnits",
          "transform"
        ],
        defaults: {
          hatchUnits: "objectBoundingBox",
          hatchContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          pitch: "0",
          rotate: "0"
        },
        contentGroups: ["animation", "descriptive"],
        content: ["hatchPath"]
      },
      hatchPath: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: ["class", "style", "d", "offset"],
        defaults: {
          offset: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      hkern: {
        attrsGroups: ["core"],
        attrs: ["u1", "g1", "u2", "g2", "k"]
      },
      image: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "xlink",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "href",
          "xlink:href"
        ],
        defaults: {
          x: "0",
          y: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: ["animation", "descriptive"]
      },
      line: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x1",
          "y1",
          "x2",
          "y2"
        ],
        defaults: {
          x1: "0",
          y1: "0",
          x2: "0",
          y2: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      linearGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x1",
          "y1",
          "x2",
          "y2",
          "gradientUnits",
          "gradientTransform",
          "spreadMethod",
          "href",
          "xlink:href"
        ],
        defaults: {
          x1: "0",
          y1: "0",
          x2: "100%",
          y2: "0",
          spreadMethod: "pad"
        },
        contentGroups: ["descriptive"],
        content: ["animate", "animateTransform", "set", "stop"]
      },
      marker: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "refX",
          "refY",
          "markerUnits",
          "markerWidth",
          "markerHeight",
          "orient"
        ],
        defaults: {
          markerUnits: "strokeWidth",
          refX: "0",
          refY: "0",
          markerWidth: "3",
          markerHeight: "3"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      mask: {
        attrsGroups: ["conditionalProcessing", "core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "width",
          "height",
          "mask-type",
          "maskUnits",
          "maskContentUnits"
        ],
        defaults: {
          maskUnits: "objectBoundingBox",
          maskContentUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      metadata: {
        attrsGroups: ["core"]
      },
      "missing-glyph": {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      mpath: {
        attrsGroups: ["core", "xlink"],
        attrs: ["externalResourcesRequired", "href", "xlink:href"],
        contentGroups: ["descriptive"]
      },
      path: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "d",
          "pathLength"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      pattern: {
        attrsGroups: ["conditionalProcessing", "core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "x",
          "y",
          "width",
          "height",
          "patternUnits",
          "patternContentUnits",
          "patternTransform",
          "href",
          "xlink:href"
        ],
        defaults: {
          patternUnits: "objectBoundingBox",
          patternContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          width: "0",
          height: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      polygon: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "points"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      polyline: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "points"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      radialGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "cx",
          "cy",
          "r",
          "fx",
          "fy",
          "fr",
          "gradientUnits",
          "gradientTransform",
          "spreadMethod",
          "href",
          "xlink:href"
        ],
        defaults: {
          gradientUnits: "objectBoundingBox",
          cx: "50%",
          cy: "50%",
          r: "50%"
        },
        contentGroups: ["descriptive"],
        content: ["animate", "animateTransform", "set", "stop"]
      },
      meshGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: ["class", "style", "x", "y", "gradientUnits", "transform"],
        contentGroups: ["descriptive", "paintServer", "animation"],
        content: ["meshRow"]
      },
      meshRow: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["descriptive"],
        content: ["meshPatch"]
      },
      meshPatch: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["descriptive"],
        content: ["stop"]
      },
      rect: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "rx",
          "ry"
        ],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      script: {
        attrsGroups: ["core", "xlink"],
        attrs: ["externalResourcesRequired", "type", "href", "xlink:href"]
      },
      set: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animation",
          "xlink",
          "animationAttributeTarget",
          "animationTiming"
        ],
        attrs: ["externalResourcesRequired", "to"],
        contentGroups: ["descriptive"]
      },
      solidColor: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["paintServer"]
      },
      stop: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style", "offset", "path"],
        content: ["animate", "animateColor", "set"]
      },
      style: {
        attrsGroups: ["core"],
        attrs: ["type", "media", "title"],
        defaults: {
          type: "text/css"
        }
      },
      svg: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "documentEvent",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "x",
          "y",
          "width",
          "height",
          "viewBox",
          "preserveAspectRatio",
          "zoomAndPan",
          "version",
          "baseProfile",
          "contentScriptType",
          "contentStyleType"
        ],
        defaults: {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid meet",
          zoomAndPan: "magnify",
          version: "1.1",
          baseProfile: "none",
          contentScriptType: "application/ecmascript",
          contentStyleType: "text/css"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      switch: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: ["animation", "descriptive", "shape"],
        content: [
          "a",
          "foreignObject",
          "g",
          "image",
          "svg",
          "switch",
          "text",
          "use"
        ]
      },
      symbol: {
        attrsGroups: ["core", "graphicalEvent", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "viewBox",
          "refX",
          "refY"
        ],
        defaults: {
          refX: "0",
          refY: "0"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      text: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "lengthAdjust",
          "x",
          "y",
          "dx",
          "dy",
          "rotate",
          "textLength"
        ],
        defaults: {
          x: "0",
          y: "0",
          lengthAdjust: "spacing"
        },
        contentGroups: ["animation", "descriptive", "textContentChild"],
        content: ["a"]
      },
      textPath: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "href",
          "xlink:href",
          "startOffset",
          "method",
          "spacing",
          "d"
        ],
        defaults: {
          startOffset: "0",
          method: "align",
          spacing: "exact"
        },
        contentGroups: ["descriptive"],
        content: [
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ]
      },
      title: {
        attrsGroups: ["core"],
        attrs: ["class", "style"]
      },
      tref: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "href",
          "xlink:href"
        ],
        contentGroups: ["descriptive"],
        content: ["animate", "animateColor", "set"]
      },
      tspan: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "dx",
          "dy",
          "rotate",
          "textLength",
          "lengthAdjust"
        ],
        contentGroups: ["descriptive"],
        content: [
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ]
      },
      use: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "href",
          "xlink:href"
        ],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      view: {
        attrsGroups: ["core"],
        attrs: [
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "zoomAndPan",
          "viewTarget"
        ],
        contentGroups: ["descriptive"]
      },
      vkern: {
        attrsGroups: ["core"],
        attrs: ["u1", "g1", "u2", "g2", "k"]
      }
    };
    exports.editorNamespaces = [
      "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://www.inkscape.org/namespaces/inkscape",
      "http://www.bohemiancoding.com/sketch/ns",
      "http://ns.adobe.com/AdobeIllustrator/10.0/",
      "http://ns.adobe.com/Graphs/1.0/",
      "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
      "http://ns.adobe.com/Variables/1.0/",
      "http://ns.adobe.com/SaveForWeb/1.0/",
      "http://ns.adobe.com/Extensibility/1.0/",
      "http://ns.adobe.com/Flows/1.0/",
      "http://ns.adobe.com/ImageReplacement/1.0/",
      "http://ns.adobe.com/GenericCustomNamespace/1.0/",
      "http://ns.adobe.com/XPath/1.0/",
      "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
      "http://taptrix.com/vectorillustrator/svg_extensions",
      "http://www.figma.com/figma/ns",
      "http://purl.org/dc/elements/1.1/",
      "http://creativecommons.org/ns#",
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      "http://www.serif.com/",
      "http://www.vector.evaxdesign.sk"
    ];
    exports.referencesProps = [
      "clip-path",
      "color-profile",
      "fill",
      "filter",
      "marker-start",
      "marker-mid",
      "marker-end",
      "mask",
      "stroke",
      "style"
    ];
    exports.inheritableAttrs = [
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cursor",
      "direction",
      "dominant-baseline",
      "fill",
      "fill-opacity",
      "fill-rule",
      "font",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "image-rendering",
      "letter-spacing",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-rendering",
      "transform",
      "visibility",
      "word-spacing",
      "writing-mode"
    ];
    exports.presentationNonInheritableGroupAttrs = [
      "display",
      "clip-path",
      "filter",
      "mask",
      "opacity",
      "text-decoration",
      "transform",
      "unicode-bidi"
    ];
    exports.colorsNames = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#0ff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000",
      blanchedalmond: "#ffebcd",
      blue: "#00f",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#0ff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#f0f",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#789",
      lightslategrey: "#789",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#0f0",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#f0f",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#639",
      red: "#f00",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#fff",
      whitesmoke: "#f5f5f5",
      yellow: "#ff0",
      yellowgreen: "#9acd32"
    };
    exports.colorsShortNames = {
      "#f0ffff": "azure",
      "#f5f5dc": "beige",
      "#ffe4c4": "bisque",
      "#a52a2a": "brown",
      "#ff7f50": "coral",
      "#ffd700": "gold",
      "#808080": "gray",
      "#008000": "green",
      "#4b0082": "indigo",
      "#fffff0": "ivory",
      "#f0e68c": "khaki",
      "#faf0e6": "linen",
      "#800000": "maroon",
      "#000080": "navy",
      "#808000": "olive",
      "#ffa500": "orange",
      "#da70d6": "orchid",
      "#cd853f": "peru",
      "#ffc0cb": "pink",
      "#dda0dd": "plum",
      "#800080": "purple",
      "#f00": "red",
      "#ff0000": "red",
      "#fa8072": "salmon",
      "#a0522d": "sienna",
      "#c0c0c0": "silver",
      "#fffafa": "snow",
      "#d2b48c": "tan",
      "#008080": "teal",
      "#ff6347": "tomato",
      "#ee82ee": "violet",
      "#f5deb3": "wheat"
    };
    exports.colorsProps = [
      "color",
      "fill",
      "stroke",
      "stop-color",
      "flood-color",
      "lighting-color"
    ];
  }
});

// node_modules/svgo/plugins/removeEditorsNSData.js
var require_removeEditorsNSData = __commonJS({
  "node_modules/svgo/plugins/removeEditorsNSData.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { editorNamespaces } = require_collections();
    exports.type = "visitor";
    exports.name = "removeEditorsNSData";
    exports.active = true;
    exports.description = "removes editors namespaces, elements and attributes";
    exports.fn = (_root, params) => {
      let namespaces = editorNamespaces;
      if (Array.isArray(params.additionalNamespaces)) {
        namespaces = [...editorNamespaces, ...params.additionalNamespaces];
      }
      const prefixes = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg") {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                  prefixes.push(name.slice("xmlns:".length));
                  delete node.attributes[name];
                }
              }
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefixes.includes(prefix)) {
                  delete node.attributes[name];
                }
              }
            }
            if (node.name.includes(":")) {
              const [prefix] = node.name.split(":");
              if (prefixes.includes(prefix)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupAttrs.js
var require_cleanupAttrs = __commonJS({
  "node_modules/svgo/plugins/cleanupAttrs.js"(exports) {
    "use strict";
    exports.name = "cleanupAttrs";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "cleanups attributes from newlines, trailing and repeating spaces";
    var regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
    var regNewlines = /\r?\n/g;
    var regSpaces = /\s{2,}/g;
    exports.fn = (root, params) => {
      const { newlines = true, trim = true, spaces = true } = params;
      return {
        element: {
          enter: (node) => {
            for (const name of Object.keys(node.attributes)) {
              if (newlines) {
                node.attributes[name] = node.attributes[name].replace(
                  regNewlinesNeedSpace,
                  (match, p1, p2) => p1 + " " + p2
                );
                node.attributes[name] = node.attributes[name].replace(
                  regNewlines,
                  ""
                );
              }
              if (trim) {
                node.attributes[name] = node.attributes[name].trim();
              }
              if (spaces) {
                node.attributes[name] = node.attributes[name].replace(
                  regSpaces,
                  " "
                );
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/svgo/css-class-list.js
var require_css_class_list = __commonJS({
  "node_modules/svgo/lib/svgo/css-class-list.js"(exports, module) {
    "use strict";
    var CSSClassList = function(node) {
      this.parentNode = node;
      this.classNames = /* @__PURE__ */ new Set();
      const value = node.attributes.class;
      if (value != null) {
        this.addClassValueHandler();
        this.setClassValue(value);
      }
    };
    CSSClassList.prototype.addClassValueHandler = function() {
      Object.defineProperty(this.parentNode.attributes, "class", {
        get: this.getClassValue.bind(this),
        set: this.setClassValue.bind(this),
        enumerable: true,
        configurable: true
      });
    };
    CSSClassList.prototype.getClassValue = function() {
      var arrClassNames = Array.from(this.classNames);
      return arrClassNames.join(" ");
    };
    CSSClassList.prototype.setClassValue = function(newValue) {
      if (typeof newValue === "undefined") {
        this.classNames.clear();
        return;
      }
      var arrClassNames = newValue.split(" ");
      this.classNames = new Set(arrClassNames);
    };
    CSSClassList.prototype.add = function() {
      this.addClassValueHandler();
      Object.values(arguments).forEach(this._addSingle.bind(this));
    };
    CSSClassList.prototype._addSingle = function(className) {
      this.classNames.add(className);
    };
    CSSClassList.prototype.remove = function() {
      this.addClassValueHandler();
      Object.values(arguments).forEach(this._removeSingle.bind(this));
    };
    CSSClassList.prototype._removeSingle = function(className) {
      this.classNames.delete(className);
    };
    CSSClassList.prototype.item = function(index) {
      var arrClassNames = Array.from(this.classNames);
      return arrClassNames[index];
    };
    CSSClassList.prototype.toggle = function(className, force) {
      if (this.contains(className) || force === false) {
        this.classNames.delete(className);
      }
      this.classNames.add(className);
    };
    CSSClassList.prototype.contains = function(className) {
      return this.classNames.has(className);
    };
    module.exports = CSSClassList;
  }
});

// node_modules/css-tree/lib/common/List.js
var require_List = __commonJS({
  "node_modules/css-tree/lib/common/List.js"(exports, module) {
    function createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
    function allocateCursor(node, prev, next) {
      var cursor;
      if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: node.cursor
        };
      }
      node.cursor = cursor;
      return cursor;
    }
    function releaseCursor(node) {
      var cursor = node.cursor;
      node.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = cursors;
      cursors = cursor;
    }
    var cursors = null;
    var List = function() {
      this.cursor = null;
      this.head = null;
      this.tail = null;
    };
    List.createItem = createItem;
    List.prototype.createItem = createItem;
    List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
      var cursor = this.cursor;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    };
    List.prototype.getSize = function() {
      var size = 0;
      var cursor = this.head;
      while (cursor) {
        size++;
        cursor = cursor.next;
      }
      return size;
    };
    List.prototype.fromArray = function(array) {
      var cursor = null;
      this.head = null;
      for (var i2 = 0; i2 < array.length; i2++) {
        var item = createItem(array[i2]);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    };
    List.prototype.toArray = function() {
      var cursor = this.head;
      var result = [];
      while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.toJSON = List.prototype.toArray;
    List.prototype.isEmpty = function() {
      return this.head === null;
    };
    List.prototype.first = function() {
      return this.head && this.head.data;
    };
    List.prototype.last = function() {
      return this.tail && this.tail.data;
    };
    List.prototype.each = function(fn, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, this.head);
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        fn.call(context, item.data, item, this);
      }
      releaseCursor(this);
    };
    List.prototype.forEach = List.prototype.each;
    List.prototype.eachRight = function(fn, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, this.tail, null);
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(context, item.data, item, this);
      }
      releaseCursor(this);
    };
    List.prototype.forEachRight = List.prototype.eachRight;
    List.prototype.reduce = function(fn, initialValue, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, this.head);
      var acc = initialValue;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(context, acc, item.data, item, this);
      }
      releaseCursor(this);
      return acc;
    };
    List.prototype.reduceRight = function(fn, initialValue, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, this.tail, null);
      var acc = initialValue;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(context, acc, item.data, item, this);
      }
      releaseCursor(this);
      return acc;
    };
    List.prototype.nextUntil = function(start, fn, context) {
      if (start === null) {
        return;
      }
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, start);
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        if (fn.call(context, item.data, item, this)) {
          break;
        }
      }
      releaseCursor(this);
    };
    List.prototype.prevUntil = function(start, fn, context) {
      if (start === null) {
        return;
      }
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, start, null);
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(context, item.data, item, this)) {
          break;
        }
      }
      releaseCursor(this);
    };
    List.prototype.some = function(fn, context) {
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
          return true;
        }
        cursor = cursor.next;
      }
      return false;
    };
    List.prototype.map = function(fn, context) {
      var result = new List();
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.filter = function(fn, context) {
      var result = new List();
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.clear = function() {
      this.head = null;
      this.tail = null;
    };
    List.prototype.copy = function() {
      var result = new List();
      var cursor = this.head;
      while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.prepend = function(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    };
    List.prototype.prependData = function(data) {
      return this.prepend(createItem(data));
    };
    List.prototype.append = function(item) {
      return this.insert(item);
    };
    List.prototype.appendData = function(data) {
      return this.insert(createItem(data));
    };
    List.prototype.insert = function(item, before) {
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    };
    List.prototype.insertData = function(data, before) {
      return this.insert(createItem(data), before);
    };
    List.prototype.remove = function(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    };
    List.prototype.push = function(data) {
      this.insert(createItem(data));
    };
    List.prototype.pop = function() {
      if (this.tail !== null) {
        return this.remove(this.tail);
      }
    };
    List.prototype.unshift = function(data) {
      this.prepend(createItem(data));
    };
    List.prototype.shift = function() {
      if (this.head !== null) {
        return this.remove(this.head);
      }
    };
    List.prototype.prependList = function(list) {
      return this.insertList(list, this.head);
    };
    List.prototype.appendList = function(list) {
      return this.insertList(list);
    };
    List.prototype.insertList = function(list, before) {
      if (list.head === null) {
        return this;
      }
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);
        if (before.prev !== null) {
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }
        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head);
        if (this.tail !== null) {
          this.tail.next = list.head;
          list.head.prev = this.tail;
        } else {
          this.head = list.head;
        }
        this.tail = list.tail;
      }
      list.head = null;
      list.tail = null;
      return this;
    };
    List.prototype.replace = function(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    };
    module.exports = List;
  }
});

// node_modules/css-tree/lib/utils/createCustomError.js
var require_createCustomError = __commonJS({
  "node_modules/css-tree/lib/utils/createCustomError.js"(exports, module) {
    module.exports = function createCustomError(name, message) {
      var error = Object.create(SyntaxError.prototype);
      var errorStack = new Error();
      error.name = name;
      error.message = message;
      Object.defineProperty(error, "stack", {
        get: function() {
          return (errorStack.stack || "").replace(/^(.+\n){1,3}/, name + ": " + message + "\n");
        }
      });
      return error;
    };
  }
});

// node_modules/css-tree/lib/common/SyntaxError.js
var require_SyntaxError = __commonJS({
  "node_modules/css-tree/lib/common/SyntaxError.js"(exports, module) {
    var createCustomError = require_createCustomError();
    var MAX_LINE_LENGTH = 100;
    var OFFSET_CORRECTION = 60;
    var TAB_REPLACEMENT = "    ";
    function sourceFragment(error, extraLines) {
      function processLines(start, end) {
        return lines.slice(start, end).map(function(line2, idx) {
          var num = String(start + idx + 1);
          while (num.length < maxNumLength) {
            num = " " + num;
          }
          return num + " |" + line2;
        }).join("\n");
      }
      var lines = error.source.split(/\r\n?|\n|\f/);
      var line = error.line;
      var column = error.column;
      var startLine = Math.max(1, line - extraLines) - 1;
      var endLine = Math.min(line + extraLines, lines.length + 1);
      var maxNumLength = Math.max(4, String(endLine).length) + 1;
      var cutLeft = 0;
      column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
      if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
      }
      for (var i2 = startLine; i2 <= endLine; i2++) {
        if (i2 >= 0 && i2 < lines.length) {
          lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
          lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "\u2026" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
      }
      return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join("-") + "^",
        processLines(line, endLine)
      ].filter(Boolean).join("\n");
    }
    var SyntaxError2 = function(message, source, offset, line, column) {
      var error = createCustomError("SyntaxError", message);
      error.source = source;
      error.offset = offset;
      error.line = line;
      error.column = column;
      error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
      };
      Object.defineProperty(error, "formattedMessage", {
        get: function() {
          return "Parse error: " + error.message + "\n" + sourceFragment(error, 2);
        }
      });
      error.parseError = {
        offset,
        line,
        column
      };
      return error;
    };
    module.exports = SyntaxError2;
  }
});

// node_modules/css-tree/lib/tokenizer/const.js
var require_const = __commonJS({
  "node_modules/css-tree/lib/tokenizer/const.js"(exports, module) {
    var TYPE = {
      EOF: 0,
      Ident: 1,
      Function: 2,
      AtKeyword: 3,
      Hash: 4,
      String: 5,
      BadString: 6,
      Url: 7,
      BadUrl: 8,
      Delim: 9,
      Number: 10,
      Percentage: 11,
      Dimension: 12,
      WhiteSpace: 13,
      CDO: 14,
      CDC: 15,
      Colon: 16,
      Semicolon: 17,
      Comma: 18,
      LeftSquareBracket: 19,
      RightSquareBracket: 20,
      LeftParenthesis: 21,
      RightParenthesis: 22,
      LeftCurlyBracket: 23,
      RightCurlyBracket: 24,
      Comment: 25
    };
    var NAME = Object.keys(TYPE).reduce(function(result, key) {
      result[TYPE[key]] = key;
      return result;
    }, {});
    module.exports = {
      TYPE,
      NAME
    };
  }
});

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var require_char_code_definitions = __commonJS({
  "node_modules/css-tree/lib/tokenizer/char-code-definitions.js"(exports, module) {
    var EOF = 0;
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isHexDigit(code) {
      return isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
    }
    function isUppercaseLetter(code) {
      return code >= 65 && code <= 90;
    }
    function isLowercaseLetter(code) {
      return code >= 97 && code <= 122;
    }
    function isLetter(code) {
      return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    function isNonAscii(code) {
      return code >= 128;
    }
    function isNameStart(code) {
      return isLetter(code) || isNonAscii(code) || code === 95;
    }
    function isName(code) {
      return isNameStart(code) || isDigit(code) || code === 45;
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function isNewline(code) {
      return code === 10 || code === 13 || code === 12;
    }
    function isWhiteSpace(code) {
      return isNewline(code) || code === 32 || code === 9;
    }
    function isValidEscape(first, second) {
      if (first !== 92) {
        return false;
      }
      if (isNewline(second) || second === EOF) {
        return false;
      }
      return true;
    }
    function isIdentifierStart(first, second, third) {
      if (first === 45) {
        return isNameStart(second) || second === 45 || isValidEscape(second, third);
      }
      if (isNameStart(first)) {
        return true;
      }
      if (first === 92) {
        return isValidEscape(first, second);
      }
      return false;
    }
    function isNumberStart(first, second, third) {
      if (first === 43 || first === 45) {
        if (isDigit(second)) {
          return 2;
        }
        return second === 46 && isDigit(third) ? 3 : 0;
      }
      if (first === 46) {
        return isDigit(second) ? 2 : 0;
      }
      if (isDigit(first)) {
        return 1;
      }
      return 0;
    }
    function isBOM(code) {
      if (code === 65279) {
        return 1;
      }
      if (code === 65534) {
        return 1;
      }
      return 0;
    }
    var CATEGORY = new Array(128);
    charCodeCategory.Eof = 128;
    charCodeCategory.WhiteSpace = 130;
    charCodeCategory.Digit = 131;
    charCodeCategory.NameStart = 132;
    charCodeCategory.NonPrintable = 133;
    for (i2 = 0; i2 < CATEGORY.length; i2++) {
      switch (true) {
        case isWhiteSpace(i2):
          CATEGORY[i2] = charCodeCategory.WhiteSpace;
          break;
        case isDigit(i2):
          CATEGORY[i2] = charCodeCategory.Digit;
          break;
        case isNameStart(i2):
          CATEGORY[i2] = charCodeCategory.NameStart;
          break;
        case isNonPrintable(i2):
          CATEGORY[i2] = charCodeCategory.NonPrintable;
          break;
        default:
          CATEGORY[i2] = i2 || charCodeCategory.Eof;
      }
    }
    var i2;
    function charCodeCategory(code) {
      return code < 128 ? CATEGORY[code] : charCodeCategory.NameStart;
    }
    module.exports = {
      isDigit,
      isHexDigit,
      isUppercaseLetter,
      isLowercaseLetter,
      isLetter,
      isNonAscii,
      isNameStart,
      isName,
      isNonPrintable,
      isNewline,
      isWhiteSpace,
      isValidEscape,
      isIdentifierStart,
      isNumberStart,
      isBOM,
      charCodeCategory
    };
  }
});

// node_modules/css-tree/lib/tokenizer/utils.js
var require_utils2 = __commonJS({
  "node_modules/css-tree/lib/tokenizer/utils.js"(exports, module) {
    var charCodeDef = require_char_code_definitions();
    var isDigit = charCodeDef.isDigit;
    var isHexDigit = charCodeDef.isHexDigit;
    var isUppercaseLetter = charCodeDef.isUppercaseLetter;
    var isName = charCodeDef.isName;
    var isWhiteSpace = charCodeDef.isWhiteSpace;
    var isValidEscape = charCodeDef.isValidEscape;
    function getCharCode(source, offset) {
      return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
      if (code === 13 && getCharCode(source, offset + 1) === 10) {
        return 2;
      }
      return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
      var code = testStr.charCodeAt(offset);
      if (isUppercaseLetter(code)) {
        code = code | 32;
      }
      return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
      if (end - start !== referenceStr.length) {
        return false;
      }
      if (start < 0 || end > testStr.length) {
        return false;
      }
      for (var i2 = start; i2 < end; i2++) {
        var testCode = testStr.charCodeAt(i2);
        var referenceCode = referenceStr.charCodeAt(i2 - start);
        if (isUppercaseLetter(testCode)) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function findWhiteSpaceStart(source, offset) {
      for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function findDecimalNumberEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function consumeEscaped(source, offset) {
      offset += 2;
      if (isHexDigit(getCharCode(source, offset - 1))) {
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
          if (!isHexDigit(getCharCode(source, offset))) {
            break;
          }
        }
        var code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
          offset += getNewlineLength(source, offset, code);
        }
      }
      return offset;
    }
    function consumeName(source, offset) {
      for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);
        if (isName(code)) {
          continue;
        }
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset) - 1;
          continue;
        }
        break;
      }
      return offset;
    }
    function consumeNumber(source, offset) {
      var code = source.charCodeAt(offset);
      if (code === 43 || code === 45) {
        code = source.charCodeAt(offset += 1);
      }
      if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
      }
      if (code === 46 && isDigit(source.charCodeAt(offset + 1))) {
        code = source.charCodeAt(offset += 2);
        offset = findDecimalNumberEnd(source, offset);
      }
      if (cmpChar(source, offset, 101)) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);
        if (code === 45 || code === 43) {
          sign = 1;
          code = source.charCodeAt(offset + 2);
        }
        if (isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
      }
      return offset;
    }
    function consumeBadUrlRemnants(source, offset) {
      for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);
        if (code === 41) {
          offset++;
          break;
        }
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset);
        }
      }
      return offset;
    }
    module.exports = {
      consumeEscaped,
      consumeName,
      consumeNumber,
      consumeBadUrlRemnants,
      cmpChar,
      cmpStr,
      getNewlineLength,
      findWhiteSpaceStart,
      findWhiteSpaceEnd
    };
  }
});

// node_modules/css-tree/lib/common/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/css-tree/lib/common/TokenStream.js"(exports, module) {
    var constants = require_const();
    var TYPE = constants.TYPE;
    var NAME = constants.NAME;
    var utils = require_utils2();
    var cmpStr = utils.cmpStr;
    var EOF = TYPE.EOF;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    var TokenStream = function() {
      this.offsetAndType = null;
      this.balance = null;
      this.reset();
    };
    TokenStream.prototype = {
      reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
      },
      lookupType: function(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset] >> TYPE_SHIFT;
        }
        return EOF;
      },
      lookupOffset: function(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }
        return this.source.length;
      },
      lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return cmpStr(
            this.source,
            this.offsetAndType[offset - 1] & OFFSET_MASK,
            this.offsetAndType[offset] & OFFSET_MASK,
            referenceStr
          );
        }
        return false;
      },
      getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
          return this.tokenStart;
        }
        if (tokenIndex > 0) {
          return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }
        return this.firstCharOffset;
      },
      getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
        var type;
        loop:
          for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            type = this.offsetAndType[cursor] >> TYPE_SHIFT;
            switch (mode(type, this.source, offset)) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
                offset = this.offsetAndType[cursor] & OFFSET_MASK;
            }
          }
        return cursor - this.tokenIndex;
      },
      isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
      },
      isDelim: function(code, offset) {
        if (offset) {
          return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
        }
        return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;
      },
      getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
      },
      getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
      },
      substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
      },
      skipWS: function() {
        for (var i2 = this.tokenIndex, skipTokenCount = 0; i2 < this.tokenCount; i2++, skipTokenCount++) {
          if (this.offsetAndType[i2] >> TYPE_SHIFT !== WHITESPACE) {
            break;
          }
        }
        if (skipTokenCount > 0) {
          this.skip(skipTokenCount);
        }
      },
      skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
          this.next();
        }
      },
      skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.next();
        }
      },
      next: function() {
        var next = this.tokenIndex + 1;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.tokenEnd;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.eof = true;
          this.tokenType = EOF;
          this.tokenStart = this.tokenEnd = this.source.length;
        }
      },
      forEachToken(fn) {
        for (var i2 = 0, offset = this.firstCharOffset; i2 < this.tokenCount; i2++) {
          var start = offset;
          var item = this.offsetAndType[i2];
          var end = item & OFFSET_MASK;
          var type = item >> TYPE_SHIFT;
          offset = end;
          fn(type, start, end, i2);
        }
      },
      dump() {
        var tokens = new Array(this.tokenCount);
        this.forEachToken((type, start, end, index) => {
          tokens[index] = {
            idx: index,
            type: NAME[type],
            chunk: this.source.substring(start, end),
            balance: this.balance[index]
          };
        });
        return tokens;
      }
    };
    module.exports = TokenStream;
  }
});

// node_modules/css-tree/lib/definition-syntax/generate.js
var require_generate = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/generate.js"(exports, module) {
    function noop(value) {
      return value;
    }
    function generateMultiplier(multiplier) {
      if (multiplier.min === 0 && multiplier.max === 0) {
        return "*";
      }
      if (multiplier.min === 0 && multiplier.max === 1) {
        return "?";
      }
      if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? "#" : "+";
      }
      if (multiplier.min === 1 && multiplier.max === 1) {
        return "";
      }
      return (multiplier.comma ? "#" : "") + (multiplier.min === multiplier.max ? "{" + multiplier.min + "}" : "{" + multiplier.min + "," + (multiplier.max !== 0 ? multiplier.max : "") + "}");
    }
    function generateTypeOpts(node) {
      switch (node.type) {
        case "Range":
          return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
    }
    function generateSequence(node, decorate, forceBraces, compact) {
      var combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
      var result = node.terms.map(function(term) {
        return generate(term, decorate, forceBraces, compact);
      }).join(combinator);
      if (node.explicit || forceBraces) {
        result = (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
      }
      return result;
    }
    function generate(node, decorate, forceBraces, compact) {
      var result;
      switch (node.type) {
        case "Group":
          result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
        case "Type":
          result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
          break;
        case "Property":
          result = "<'" + node.name + "'>";
          break;
        case "Keyword":
          result = node.name;
          break;
        case "AtKeyword":
          result = "@" + node.name;
          break;
        case "Function":
          result = node.name + "(";
          break;
        case "String":
        case "Token":
          result = node.value;
          break;
        case "Comma":
          result = ",";
          break;
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
      return decorate(result, node);
    }
    module.exports = function(node, options) {
      var decorate = noop;
      var forceBraces = false;
      var compact = false;
      if (typeof options === "function") {
        decorate = options;
      } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === "function") {
          decorate = options.decorate;
        }
      }
      return generate(node, decorate, forceBraces, compact);
    };
  }
});

// node_modules/css-tree/lib/lexer/error.js
var require_error = __commonJS({
  "node_modules/css-tree/lib/lexer/error.js"(exports, module) {
    var createCustomError = require_createCustomError();
    var generate = require_generate();
    var defaultLoc = { offset: 0, line: 1, column: 1 };
    function locateMismatch(matchResult, node) {
      const tokens = matchResult.tokens;
      const longestMatch = matchResult.longestMatch;
      const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
      const badNode = mismatchNode !== node ? mismatchNode : null;
      let mismatchOffset = 0;
      let mismatchLength = 0;
      let entries = 0;
      let css = "";
      let start;
      let end;
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token = tokens[i2].value;
        if (i2 === longestMatch) {
          mismatchLength = token.length;
          mismatchOffset = css.length;
        }
        if (badNode !== null && tokens[i2].node === badNode) {
          if (i2 <= longestMatch) {
            entries++;
          } else {
            entries = 0;
          }
        }
        css += token;
      }
      if (longestMatch === tokens.length || entries > 1) {
        start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
        end = buildLoc(start);
      } else {
        start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
      }
      return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      };
    }
    function fromLoc(node, point) {
      const value = node && node.loc && node.loc[point];
      if (value) {
        return "line" in value ? buildLoc(value) : value;
      }
      return null;
    }
    function buildLoc({ offset, line, column }, extra) {
      const loc = {
        offset,
        line,
        column
      };
      if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);
        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
      }
      return loc;
    }
    var SyntaxReferenceError = function(type, referenceName) {
      const error = createCustomError(
        "SyntaxReferenceError",
        type + (referenceName ? " `" + referenceName + "`" : "")
      );
      error.reference = referenceName;
      return error;
    };
    var SyntaxMatchError = function(message, syntax, node, matchResult) {
      const error = createCustomError("SyntaxMatchError", message);
      const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      } = locateMismatch(matchResult, node);
      error.rawMessage = message;
      error.syntax = syntax ? generate(syntax) : "<generic>";
      error.css = css;
      error.mismatchOffset = mismatchOffset;
      error.mismatchLength = mismatchLength;
      error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
      Object.assign(error, start);
      error.loc = {
        source: node && node.loc && node.loc.source || "<unknown>",
        start,
        end
      };
      return error;
    };
    module.exports = {
      SyntaxReferenceError,
      SyntaxMatchError
    };
  }
});

// node_modules/css-tree/lib/utils/names.js
var require_names = __commonJS({
  "node_modules/css-tree/lib/utils/names.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var keywords = /* @__PURE__ */ Object.create(null);
    var properties = /* @__PURE__ */ Object.create(null);
    var HYPHENMINUS = 45;
    function isCustomProperty(str, offset) {
      offset = offset || 0;
      return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
    }
    function getVendorPrefix(str, offset) {
      offset = offset || 0;
      if (str.length - offset >= 3) {
        if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
          var secondDashIndex = str.indexOf("-", offset + 2);
          if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
          }
        }
      }
      return "";
    }
    function getKeywordDescriptor(keyword) {
      if (hasOwnProperty2.call(keywords, keyword)) {
        return keywords[keyword];
      }
      var name = keyword.toLowerCase();
      if (hasOwnProperty2.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
      }
      var custom = isCustomProperty(name, 0);
      var vendor = !custom ? getVendorPrefix(name, 0) : "";
      return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name,
        vendor,
        prefix: vendor,
        custom
      });
    }
    function getPropertyDescriptor(property) {
      if (hasOwnProperty2.call(properties, property)) {
        return properties[property];
      }
      var name = property;
      var hack = property[0];
      if (hack === "/") {
        hack = property[1] === "/" ? "//" : "/";
      } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
        hack = "";
      }
      var custom = isCustomProperty(name, hack.length);
      if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty2.call(properties, name)) {
          return properties[property] = properties[name];
        }
      }
      var vendor = !custom ? getVendorPrefix(name, hack.length) : "";
      var prefix = name.substr(0, hack.length + vendor.length);
      return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
      });
    }
    module.exports = {
      keyword: getKeywordDescriptor,
      property: getPropertyDescriptor,
      isCustomProperty,
      vendorPrefix: getVendorPrefix
    };
  }
});

// node_modules/css-tree/lib/common/adopt-buffer.js
var require_adopt_buffer = __commonJS({
  "node_modules/css-tree/lib/common/adopt-buffer.js"(exports, module) {
    var MIN_SIZE = 16 * 1024;
    var SafeUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : Array;
    module.exports = function adoptBuffer(buffer, size) {
      if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
      }
      return buffer;
    };
  }
});

// node_modules/css-tree/lib/tokenizer/index.js
var require_tokenizer = __commonJS({
  "node_modules/css-tree/lib/tokenizer/index.js"(exports, module) {
    var TokenStream = require_TokenStream();
    var adoptBuffer = require_adopt_buffer();
    var constants = require_const();
    var TYPE = constants.TYPE;
    var charCodeDefinitions = require_char_code_definitions();
    var isNewline = charCodeDefinitions.isNewline;
    var isName = charCodeDefinitions.isName;
    var isValidEscape = charCodeDefinitions.isValidEscape;
    var isNumberStart = charCodeDefinitions.isNumberStart;
    var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    var charCodeCategory = charCodeDefinitions.charCodeCategory;
    var isBOM = charCodeDefinitions.isBOM;
    var utils = require_utils2();
    var cmpStr = utils.cmpStr;
    var getNewlineLength = utils.getNewlineLength;
    var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    var consumeEscaped = utils.consumeEscaped;
    var consumeName = utils.consumeName;
    var consumeNumber = utils.consumeNumber;
    var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    function tokenize(source, stream) {
      function getCharCode(offset2) {
        return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
      }
      function consumeNumericToken() {
        offset = consumeNumber(source, offset);
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
          type = TYPE.Dimension;
          offset = consumeName(source, offset);
          return;
        }
        if (getCharCode(offset) === 37) {
          type = TYPE.Percentage;
          offset++;
          return;
        }
        type = TYPE.Number;
      }
      function consumeIdentLikeToken() {
        const nameStartOffset = offset;
        offset = consumeName(source, offset);
        if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
          offset = findWhiteSpaceEnd(source, offset + 1);
          if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
            type = TYPE.Function;
            offset = nameStartOffset + 4;
            return;
          }
          consumeUrlToken();
          return;
        }
        if (getCharCode(offset) === 40) {
          type = TYPE.Function;
          offset++;
          return;
        }
        type = TYPE.Ident;
      }
      function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
          endingCodePoint = getCharCode(offset++);
        }
        type = TYPE.String;
        for (; offset < source.length; offset++) {
          var code2 = source.charCodeAt(offset);
          switch (charCodeCategory(code2)) {
            case endingCodePoint:
              offset++;
              return;
            case charCodeCategory.Eof:
              return;
            case charCodeCategory.WhiteSpace:
              if (isNewline(code2)) {
                offset += getNewlineLength(source, offset, code2);
                type = TYPE.BadString;
                return;
              }
              break;
            case 92:
              if (offset === source.length - 1) {
                break;
              }
              var nextCode = getCharCode(offset + 1);
              if (isNewline(nextCode)) {
                offset += getNewlineLength(source, offset + 1, nextCode);
              } else if (isValidEscape(code2, nextCode)) {
                offset = consumeEscaped(source, offset) - 1;
              }
              break;
          }
        }
      }
      function consumeUrlToken() {
        type = TYPE.Url;
        offset = findWhiteSpaceEnd(source, offset);
        for (; offset < source.length; offset++) {
          var code2 = source.charCodeAt(offset);
          switch (charCodeCategory(code2)) {
            case 41:
              offset++;
              return;
            case charCodeCategory.Eof:
              return;
            case charCodeCategory.WhiteSpace:
              offset = findWhiteSpaceEnd(source, offset);
              if (getCharCode(offset) === 41 || offset >= source.length) {
                if (offset < source.length) {
                  offset++;
                }
                return;
              }
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
            case 34:
            case 39:
            case 40:
            case charCodeCategory.NonPrintable:
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
            case 92:
              if (isValidEscape(code2, getCharCode(offset + 1))) {
                offset = consumeEscaped(source, offset) - 1;
                break;
              }
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
          }
        }
      }
      if (!stream) {
        stream = new TokenStream();
      }
      source = String(source || "");
      var sourceLength = source.length;
      var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
      var balance = adoptBuffer(stream.balance, sourceLength + 1);
      var tokenCount = 0;
      var start = isBOM(getCharCode(0));
      var offset = start;
      var balanceCloseType = 0;
      var balanceStart = 0;
      var balancePrev = 0;
      while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;
        balance[tokenCount] = sourceLength;
        switch (charCodeCategory(code)) {
          case charCodeCategory.WhiteSpace:
            type = TYPE.WhiteSpace;
            offset = findWhiteSpaceEnd(source, offset + 1);
            break;
          case 34:
            consumeStringToken();
            break;
          case 35:
            if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
              type = TYPE.Hash;
              offset = consumeName(source, offset + 1);
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 39:
            consumeStringToken();
            break;
          case 40:
            type = TYPE.LeftParenthesis;
            offset++;
            break;
          case 41:
            type = TYPE.RightParenthesis;
            offset++;
            break;
          case 43:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 44:
            type = TYPE.Comma;
            offset++;
            break;
          case 45:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                type = TYPE.CDC;
                offset = offset + 3;
              } else {
                if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                  consumeIdentLikeToken();
                } else {
                  type = TYPE.Delim;
                  offset++;
                }
              }
            }
            break;
          case 46:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 47:
            if (getCharCode(offset + 1) === 42) {
              type = TYPE.Comment;
              offset = source.indexOf("*/", offset + 2) + 2;
              if (offset === 1) {
                offset = source.length;
              }
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 58:
            type = TYPE.Colon;
            offset++;
            break;
          case 59:
            type = TYPE.Semicolon;
            offset++;
            break;
          case 60:
            if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
              type = TYPE.CDO;
              offset = offset + 4;
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 64:
            if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
              type = TYPE.AtKeyword;
              offset = consumeName(source, offset + 1);
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 91:
            type = TYPE.LeftSquareBracket;
            offset++;
            break;
          case 92:
            if (isValidEscape(code, getCharCode(offset + 1))) {
              consumeIdentLikeToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 93:
            type = TYPE.RightSquareBracket;
            offset++;
            break;
          case 123:
            type = TYPE.LeftCurlyBracket;
            offset++;
            break;
          case 125:
            type = TYPE.RightCurlyBracket;
            offset++;
            break;
          case charCodeCategory.Digit:
            consumeNumericToken();
            break;
          case charCodeCategory.NameStart:
            consumeIdentLikeToken();
            break;
          case charCodeCategory.Eof:
            break;
          default:
            type = TYPE.Delim;
            offset++;
        }
        switch (type) {
          case balanceCloseType:
            balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (; balancePrev < tokenCount; balancePrev++) {
              if (balance[balancePrev] === sourceLength) {
                balance[balancePrev] = tokenCount;
              }
            }
            break;
          case TYPE.LeftParenthesis:
          case TYPE.Function:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightParenthesis;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
          case TYPE.LeftSquareBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightSquareBracket;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
          case TYPE.LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightCurlyBracket;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | offset;
      }
      offsetAndType[tokenCount] = TYPE.EOF << TYPE_SHIFT | offset;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      stream.source = source;
      stream.firstCharOffset = start;
      stream.offsetAndType = offsetAndType;
      stream.tokenCount = tokenCount;
      stream.balance = balance;
      stream.reset();
      stream.next();
      return stream;
    }
    Object.keys(constants).forEach(function(key) {
      tokenize[key] = constants[key];
    });
    Object.keys(charCodeDefinitions).forEach(function(key) {
      tokenize[key] = charCodeDefinitions[key];
    });
    Object.keys(utils).forEach(function(key) {
      tokenize[key] = utils[key];
    });
    module.exports = tokenize;
  }
});

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var require_generic_an_plus_b = __commonJS({
  "node_modules/css-tree/lib/lexer/generic-an-plus-b.js"(exports, module) {
    var isDigit = require_tokenizer().isDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var DELIM = TYPE.Delim;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N2 = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function isDelim(token, code) {
      return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    }
    function skipSC(token, offset, getNextToken) {
      while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
        token = getNextToken(++offset);
      }
      return offset;
    }
    function checkInteger(token, valueOffset, disallowSign, offset) {
      if (!token) {
        return 0;
      }
      var code = token.value.charCodeAt(valueOffset);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          return 0;
        }
        valueOffset++;
      }
      for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
          return 0;
        }
      }
      return offset + 1;
    }
    function consumeB(token, offset_, getNextToken) {
      var sign = false;
      var offset = skipSC(token, offset_, getNextToken);
      token = getNextToken(offset);
      if (token === null) {
        return offset_;
      }
      if (token.type !== NUMBER) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
          sign = true;
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          if (token === null && token.type !== NUMBER) {
            return 0;
          }
        } else {
          return offset_;
        }
      }
      if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
          return 0;
        }
      }
      return checkInteger(token, sign ? 0 : 1, sign, offset);
    }
    module.exports = function anPlusB(token, getNextToken) {
      var offset = 0;
      if (!token) {
        return 0;
      }
      if (token.type === NUMBER) {
        return checkInteger(token, 0, ALLOW_SIGN, offset);
      } else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
        if (!cmpChar(token.value, 1, N2)) {
          return 0;
        }
        switch (token.value.length) {
          case 2:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
      } else if (token.type === IDENT || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT) {
        if (token.type !== IDENT) {
          token = getNextToken(++offset);
        }
        if (token === null || !cmpChar(token.value, 0, N2)) {
          return 0;
        }
        switch (token.value.length) {
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } else if (token.type === DIMENSION) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
        for (var i2 = sign; i2 < token.value.length; i2++) {
          if (!isDigit(token.value.charCodeAt(i2))) {
            break;
          }
        }
        if (i2 === sign) {
          return 0;
        }
        if (!cmpChar(token.value, i2, N2)) {
          return 0;
        }
        if (i2 + 1 === token.value.length) {
          return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
          if (token.value.charCodeAt(i2 + 1) !== HYPHENMINUS) {
            return 0;
          }
          if (i2 + 2 === token.value.length) {
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          } else {
            return checkInteger(token, i2 + 2, DISALLOW_SIGN, offset);
          }
        }
      }
      return 0;
    };
  }
});

// node_modules/css-tree/lib/lexer/generic-urange.js
var require_generic_urange = __commonJS({
  "node_modules/css-tree/lib/lexer/generic-urange.js"(exports, module) {
    var isHexDigit = require_tokenizer().isHexDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var DELIM = TYPE.Delim;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function isDelim(token, code) {
      return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    }
    function startsWith(token, code) {
      return token.value.charCodeAt(0) === code;
    }
    function hexSequence(token, offset, allowDash) {
      for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
          if (hexSequence(token, offset + hexlen + 1, false) > 0) {
            return 6;
          }
          return 0;
        }
        if (!isHexDigit(code)) {
          return 0;
        }
        if (++hexlen > 6) {
          return 0;
        }
        ;
      }
      return hexlen;
    }
    function withQuestionMarkSequence(consumed, length, getNextToken) {
      if (!consumed) {
        return 0;
      }
      while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
          return 0;
        }
        length++;
      }
      return length;
    }
    module.exports = function urange(token, getNextToken) {
      var length = 0;
      if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (token.type === IDENT) {
          return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }
        if (isDelim(token, QUESTIONMARK)) {
          return withQuestionMarkSequence(1, ++length, getNextToken);
        }
        return 0;
      }
      if (token.type === NUMBER) {
        if (!startsWith(token, PLUSSIGN)) {
          return 0;
        }
        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return length;
        }
        if (token.type === DIMENSION || token.type === NUMBER) {
          if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
            return 0;
          }
          return length + 1;
        }
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
      }
      if (token.type === DIMENSION) {
        if (!startsWith(token, PLUSSIGN)) {
          return 0;
        }
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
      }
      return 0;
    };
  }
});

// node_modules/css-tree/lib/lexer/generic.js
var require_generic = __commonJS({
  "node_modules/css-tree/lib/lexer/generic.js"(exports, module) {
    var tokenizer = require_tokenizer();
    var isIdentifierStart = tokenizer.isIdentifierStart;
    var isHexDigit = tokenizer.isHexDigit;
    var isDigit = tokenizer.isDigit;
    var cmpStr = tokenizer.cmpStr;
    var consumeNumber = tokenizer.consumeNumber;
    var TYPE = tokenizer.TYPE;
    var anPlusB = require_generic_an_plus_b();
    var urange = require_generic_urange();
    var cssWideKeywords = ["unset", "initial", "inherit"];
    var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
    var LENGTH = {
      "px": true,
      "mm": true,
      "cm": true,
      "in": true,
      "pt": true,
      "pc": true,
      "q": true,
      "em": true,
      "ex": true,
      "ch": true,
      "rem": true,
      "vh": true,
      "vw": true,
      "vmin": true,
      "vmax": true,
      "vm": true
    };
    var ANGLE = {
      "deg": true,
      "grad": true,
      "rad": true,
      "turn": true
    };
    var TIME = {
      "s": true,
      "ms": true
    };
    var FREQUENCY = {
      "hz": true,
      "khz": true
    };
    var RESOLUTION = {
      "dpi": true,
      "dpcm": true,
      "dppx": true,
      "x": true
    };
    var FLEX = {
      "fr": true
    };
    var DECIBEL = {
      "db": true
    };
    var SEMITONES = {
      "st": true
    };
    function charCode(str, index) {
      return index < str.length ? str.charCodeAt(index) : 0;
    }
    function eqStr(actual, expected) {
      return cmpStr(actual, 0, actual.length, expected);
    }
    function eqStrAny(actual, expected) {
      for (var i2 = 0; i2 < expected.length; i2++) {
        if (eqStr(actual, expected[i2])) {
          return true;
        }
      }
      return false;
    }
    function isPostfixIeHack(str, offset) {
      if (offset !== str.length - 2) {
        return false;
      }
      return str.charCodeAt(offset) === 92 && isDigit(str.charCodeAt(offset + 1));
    }
    function outOfRange(opts, value, numEnd) {
      if (opts && opts.type === "Range") {
        var num = Number(
          numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
        );
        if (isNaN(num)) {
          return true;
        }
        if (opts.min !== null && num < opts.min) {
          return true;
        }
        if (opts.max !== null && num > opts.max) {
          return true;
        }
      }
      return false;
    }
    function consumeFunction(token, getNextToken) {
      var startIdx = token.index;
      var length = 0;
      do {
        length++;
        if (token.balance <= startIdx) {
          break;
        }
      } while (token = getNextToken(length));
      return length;
    }
    function calc(next) {
      return function(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
          return consumeFunction(token, getNextToken);
        }
        return next(token, getNextToken, opts);
      };
    }
    function tokenType(expectedTokenType) {
      return function(token) {
        if (token === null || token.type !== expectedTokenType) {
          return 0;
        }
        return 1;
      };
    }
    function func(name) {
      name = name + "(";
      return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
          return consumeFunction(token, getNextToken);
        }
        return 0;
      };
    }
    function customIdent(token) {
      if (token === null || token.type !== TYPE.Ident) {
        return 0;
      }
      var name = token.value.toLowerCase();
      if (eqStrAny(name, cssWideKeywords)) {
        return 0;
      }
      if (eqStr(name, "default")) {
        return 0;
      }
      return 1;
    }
    function customPropertyName(token) {
      if (token === null || token.type !== TYPE.Ident) {
        return 0;
      }
      if (charCode(token.value, 0) !== 45 || charCode(token.value, 1) !== 45) {
        return 0;
      }
      return 1;
    }
    function hexColor(token) {
      if (token === null || token.type !== TYPE.Hash) {
        return 0;
      }
      var length = token.value.length;
      if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
      }
      for (var i2 = 1; i2 < length; i2++) {
        if (!isHexDigit(token.value.charCodeAt(i2))) {
          return 0;
        }
      }
      return 1;
    }
    function idSelector(token) {
      if (token === null || token.type !== TYPE.Hash) {
        return 0;
      }
      if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
      }
      return 1;
    }
    function declarationValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      var length = 0;
      var level = 0;
      var startIdx = token.index;
      scan:
        do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              level--;
              break;
            case TYPE.Semicolon:
              if (level === 0) {
                break scan;
              }
              break;
            case TYPE.Delim:
              if (token.value === "!" && level === 0) {
                break scan;
              }
              break;
            case TYPE.Function:
            case TYPE.LeftParenthesis:
            case TYPE.LeftSquareBracket:
            case TYPE.LeftCurlyBracket:
              level++;
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while (token = getNextToken(length));
      return length;
    }
    function anyValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      var startIdx = token.index;
      var length = 0;
      scan:
        do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while (token = getNextToken(length));
      return length;
    }
    function dimension(type) {
      return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Dimension) {
          return 0;
        }
        var numberEnd = consumeNumber(token.value, 0);
        if (type !== null) {
          var reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
          var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
          if (type.hasOwnProperty(unit.toLowerCase()) === false) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      };
    }
    function percentage(token, getNextToken, opts) {
      if (token === null || token.type !== TYPE.Percentage) {
        return 0;
      }
      if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
      }
      return 1;
    }
    function zero(next) {
      if (typeof next !== "function") {
        next = function() {
          return 0;
        };
      }
      return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE.Number) {
          if (Number(token.value) === 0) {
            return 1;
          }
        }
        return next(token, getNextToken, opts);
      };
    }
    function number(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      var numberEnd = consumeNumber(token.value, 0);
      var isNumber = numberEnd === token.value.length;
      if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    }
    function integer(token, getNextToken, opts) {
      if (token === null || token.type !== TYPE.Number) {
        return 0;
      }
      var i2 = token.value.charCodeAt(0) === 43 || token.value.charCodeAt(0) === 45 ? 1 : 0;
      for (; i2 < token.value.length; i2++) {
        if (!isDigit(token.value.charCodeAt(i2))) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, i2)) {
        return 0;
      }
      return 1;
    }
    module.exports = {
      "ident-token": tokenType(TYPE.Ident),
      "function-token": tokenType(TYPE.Function),
      "at-keyword-token": tokenType(TYPE.AtKeyword),
      "hash-token": tokenType(TYPE.Hash),
      "string-token": tokenType(TYPE.String),
      "bad-string-token": tokenType(TYPE.BadString),
      "url-token": tokenType(TYPE.Url),
      "bad-url-token": tokenType(TYPE.BadUrl),
      "delim-token": tokenType(TYPE.Delim),
      "number-token": tokenType(TYPE.Number),
      "percentage-token": tokenType(TYPE.Percentage),
      "dimension-token": tokenType(TYPE.Dimension),
      "whitespace-token": tokenType(TYPE.WhiteSpace),
      "CDO-token": tokenType(TYPE.CDO),
      "CDC-token": tokenType(TYPE.CDC),
      "colon-token": tokenType(TYPE.Colon),
      "semicolon-token": tokenType(TYPE.Semicolon),
      "comma-token": tokenType(TYPE.Comma),
      "[-token": tokenType(TYPE.LeftSquareBracket),
      "]-token": tokenType(TYPE.RightSquareBracket),
      "(-token": tokenType(TYPE.LeftParenthesis),
      ")-token": tokenType(TYPE.RightParenthesis),
      "{-token": tokenType(TYPE.LeftCurlyBracket),
      "}-token": tokenType(TYPE.RightCurlyBracket),
      "string": tokenType(TYPE.String),
      "ident": tokenType(TYPE.Ident),
      "custom-ident": customIdent,
      "custom-property-name": customPropertyName,
      "hex-color": hexColor,
      "id-selector": idSelector,
      "an-plus-b": anPlusB,
      "urange": urange,
      "declaration-value": declarationValue,
      "any-value": anyValue,
      "dimension": calc(dimension(null)),
      "angle": calc(dimension(ANGLE)),
      "decibel": calc(dimension(DECIBEL)),
      "frequency": calc(dimension(FREQUENCY)),
      "flex": calc(dimension(FLEX)),
      "length": calc(zero(dimension(LENGTH))),
      "resolution": calc(dimension(RESOLUTION)),
      "semitones": calc(dimension(SEMITONES)),
      "time": calc(dimension(TIME)),
      "percentage": calc(percentage),
      "zero": zero(),
      "number": calc(number),
      "integer": calc(integer),
      "-ms-legacy-expression": func("expression")
    };
  }
});

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
var require_SyntaxError2 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/SyntaxError.js"(exports, module) {
    var createCustomError = require_createCustomError();
    module.exports = function SyntaxError2(message, input, offset) {
      var error = createCustomError("SyntaxError", message);
      error.input = input;
      error.offset = offset;
      error.rawMessage = message;
      error.message = error.rawMessage + "\n  " + error.input + "\n--" + new Array((error.offset || error.input.length) + 1).join("-") + "^";
      return error;
    };
  }
});

// node_modules/css-tree/lib/definition-syntax/tokenizer.js
var require_tokenizer2 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/tokenizer.js"(exports, module) {
    var SyntaxError2 = require_SyntaxError2();
    var TAB = 9;
    var N2 = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var Tokenizer = function(str) {
      this.str = str;
      this.pos = 0;
    };
    Tokenizer.prototype = {
      charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
      },
      charCode: function() {
        return this.charCodeAt(this.pos);
      },
      nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
      },
      nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
      },
      findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
          var code = this.str.charCodeAt(pos);
          if (code !== R && code !== N2 && code !== F && code !== SPACE && code !== TAB) {
            break;
          }
        }
        return pos;
      },
      substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
      },
      eat: function(code) {
        if (this.charCode() !== code) {
          this.error("Expect `" + String.fromCharCode(code) + "`");
        }
        this.pos++;
      },
      peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      },
      error: function(message) {
        throw new SyntaxError2(message, this.str, this.pos);
      }
    };
    module.exports = Tokenizer;
  }
});

// node_modules/css-tree/lib/definition-syntax/parse.js
var require_parse2 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/parse.js"(exports, module) {
    var Tokenizer = require_tokenizer2();
    var TAB = 9;
    var N2 = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var COMMA = 44;
    var HYPERMINUS = 45;
    var LESSTHANSIGN = 60;
    var GREATERTHANSIGN = 62;
    var QUESTIONMARK = 63;
    var COMMERCIALAT = 64;
    var LEFTSQUAREBRACKET = 91;
    var RIGHTSQUAREBRACKET = 93;
    var LEFTCURLYBRACKET = 123;
    var VERTICALLINE = 124;
    var RIGHTCURLYBRACKET = 125;
    var INFINITY = 8734;
    var NAME_CHAR = createCharMap(function(ch) {
      return /[a-zA-Z0-9\-]/.test(ch);
    });
    var COMBINATOR_PRECEDENCE = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function createCharMap(fn) {
      var array = typeof Uint32Array === "function" ? new Uint32Array(128) : new Array(128);
      for (var i2 = 0; i2 < 128; i2++) {
        array[i2] = fn(String.fromCharCode(i2)) ? 1 : 0;
      }
      return array;
    }
    function scanSpaces(tokenizer) {
      return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
      );
    }
    function scanWord(tokenizer) {
      var end = tokenizer.pos;
      for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
          break;
        }
      }
      if (tokenizer.pos === end) {
        tokenizer.error("Expect a keyword");
      }
      return tokenizer.substringToPos(end);
    }
    function scanNumber(tokenizer) {
      var end = tokenizer.pos;
      for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
          break;
        }
      }
      if (tokenizer.pos === end) {
        tokenizer.error("Expect a number");
      }
      return tokenizer.substringToPos(end);
    }
    function scanString(tokenizer) {
      var end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
      if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error("Expect an apostrophe");
      }
      return tokenizer.substringToPos(end + 1);
    }
    function readMultiplierRange(tokenizer) {
      var min = null;
      var max = null;
      tokenizer.eat(LEFTCURLYBRACKET);
      min = scanNumber(tokenizer);
      if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
          max = scanNumber(tokenizer);
        }
      } else {
        max = min;
      }
      tokenizer.eat(RIGHTCURLYBRACKET);
      return {
        min: Number(min),
        max: max ? Number(max) : 0
      };
    }
    function readMultiplier(tokenizer) {
      var range = null;
      var comma = false;
      switch (tokenizer.charCode()) {
        case ASTERISK:
          tokenizer.pos++;
          range = {
            min: 0,
            max: 0
          };
          break;
        case PLUSSIGN:
          tokenizer.pos++;
          range = {
            min: 1,
            max: 0
          };
          break;
        case QUESTIONMARK:
          tokenizer.pos++;
          range = {
            min: 0,
            max: 1
          };
          break;
        case NUMBERSIGN:
          tokenizer.pos++;
          comma = true;
          if (tokenizer.charCode() === LEFTCURLYBRACKET) {
            range = readMultiplierRange(tokenizer);
          } else {
            range = {
              min: 1,
              max: 0
            };
          }
          break;
        case LEFTCURLYBRACKET:
          range = readMultiplierRange(tokenizer);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma,
        min: range.min,
        max: range.max,
        term: null
      };
    }
    function maybeMultiplied(tokenizer, node) {
      var multiplier = readMultiplier(tokenizer);
      if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
      }
      return node;
    }
    function maybeToken(tokenizer) {
      var ch = tokenizer.peek();
      if (ch === "") {
        return null;
      }
      return {
        type: "Token",
        value: ch
      };
    }
    function readProperty(tokenizer) {
      var name;
      tokenizer.eat(LESSTHANSIGN);
      tokenizer.eat(APOSTROPHE);
      name = scanWord(tokenizer);
      tokenizer.eat(APOSTROPHE);
      tokenizer.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer, {
        type: "Property",
        name
      });
    }
    function readTypeRange(tokenizer) {
      var min = null;
      var max = null;
      var sign = 1;
      tokenizer.eat(LEFTSQUAREBRACKET);
      if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
      }
      if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
      } else {
        min = sign * Number(scanNumber(tokenizer));
      }
      scanSpaces(tokenizer);
      tokenizer.eat(COMMA);
      scanSpaces(tokenizer);
      if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
      } else {
        sign = 1;
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        max = sign * Number(scanNumber(tokenizer));
      }
      tokenizer.eat(RIGHTSQUAREBRACKET);
      if (min === null && max === null) {
        return null;
      }
      return {
        type: "Range",
        min,
        max
      };
    }
    function readType(tokenizer) {
      var name;
      var opts = null;
      tokenizer.eat(LESSTHANSIGN);
      name = scanWord(tokenizer);
      if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += "()";
      }
      if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
      }
      tokenizer.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer, {
        type: "Type",
        name,
        opts
      });
    }
    function readKeywordOrFunction(tokenizer) {
      var name;
      name = scanWord(tokenizer);
      if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;
        return {
          type: "Function",
          name
        };
      }
      return maybeMultiplied(tokenizer, {
        type: "Keyword",
        name
      });
    }
    function regroupTerms(terms, combinators) {
      function createGroup(terms2, combinator2) {
        return {
          type: "Group",
          terms: terms2,
          combinator: combinator2,
          disallowEmpty: false,
          explicit: false
        };
      }
      combinators = Object.keys(combinators).sort(function(a2, b2) {
        return COMBINATOR_PRECEDENCE[a2] - COMBINATOR_PRECEDENCE[b2];
      });
      while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i2 = 0, subgroupStart = 0; i2 < terms.length; i2++) {
          var term = terms[i2];
          if (term.type === "Combinator") {
            if (term.value === combinator) {
              if (subgroupStart === -1) {
                subgroupStart = i2 - 1;
              }
              terms.splice(i2, 1);
              i2--;
            } else {
              if (subgroupStart !== -1 && i2 - subgroupStart > 1) {
                terms.splice(
                  subgroupStart,
                  i2 - subgroupStart,
                  createGroup(terms.slice(subgroupStart, i2), combinator)
                );
                i2 = subgroupStart + 1;
              }
              subgroupStart = -1;
            }
          }
        }
        if (subgroupStart !== -1 && combinators.length) {
          terms.splice(
            subgroupStart,
            i2 - subgroupStart,
            createGroup(terms.slice(subgroupStart, i2), combinator)
          );
        }
      }
      return combinator;
    }
    function readImplicitGroup(tokenizer) {
      var terms = [];
      var combinators = {};
      var token;
      var prevToken = null;
      var prevTokenPos = tokenizer.pos;
      while (token = peek(tokenizer)) {
        if (token.type !== "Spaces") {
          if (token.type === "Combinator") {
            if (prevToken === null || prevToken.type === "Combinator") {
              tokenizer.pos = prevTokenPos;
              tokenizer.error("Unexpected combinator");
            }
            combinators[token.value] = true;
          } else if (prevToken !== null && prevToken.type !== "Combinator") {
            combinators[" "] = true;
            terms.push({
              type: "Combinator",
              value: " "
            });
          }
          terms.push(token);
          prevToken = token;
          prevTokenPos = tokenizer.pos;
        }
      }
      if (prevToken !== null && prevToken.type === "Combinator") {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error("Unexpected combinator");
      }
      return {
        type: "Group",
        terms,
        combinator: regroupTerms(terms, combinators) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function readGroup(tokenizer) {
      var result;
      tokenizer.eat(LEFTSQUAREBRACKET);
      result = readImplicitGroup(tokenizer);
      tokenizer.eat(RIGHTSQUAREBRACKET);
      result.explicit = true;
      if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
      }
      return result;
    }
    function peek(tokenizer) {
      var code = tokenizer.charCode();
      if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
      }
      switch (code) {
        case RIGHTSQUAREBRACKET:
          break;
        case LEFTSQUAREBRACKET:
          return maybeMultiplied(tokenizer, readGroup(tokenizer));
        case LESSTHANSIGN:
          return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);
        case VERTICALLINE:
          return {
            type: "Combinator",
            value: tokenizer.substringToPos(
              tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1
            )
          };
        case AMPERSAND:
          tokenizer.pos++;
          tokenizer.eat(AMPERSAND);
          return {
            type: "Combinator",
            value: "&&"
          };
        case COMMA:
          tokenizer.pos++;
          return {
            type: "Comma"
          };
        case APOSTROPHE:
          return maybeMultiplied(tokenizer, {
            type: "String",
            value: scanString(tokenizer)
          });
        case SPACE:
        case TAB:
        case N2:
        case R:
        case F:
          return {
            type: "Spaces",
            value: scanSpaces(tokenizer)
          };
        case COMMERCIALAT:
          code = tokenizer.nextCharCode();
          if (code < 128 && NAME_CHAR[code] === 1) {
            tokenizer.pos++;
            return {
              type: "AtKeyword",
              name: scanWord(tokenizer)
            };
          }
          return maybeToken(tokenizer);
        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
          break;
        case LEFTCURLYBRACKET:
          code = tokenizer.nextCharCode();
          if (code < 48 || code > 57) {
            return maybeToken(tokenizer);
          }
          break;
        default:
          return maybeToken(tokenizer);
      }
    }
    function parse4(source) {
      var tokenizer = new Tokenizer(source);
      var result = readImplicitGroup(tokenizer);
      if (tokenizer.pos !== source.length) {
        tokenizer.error("Unexpected input");
      }
      if (result.terms.length === 1 && result.terms[0].type === "Group") {
        result = result.terms[0];
      }
      return result;
    }
    parse4("[a&&<b>#|<'c'>*||e() f{2} /,(% g#{1,2} h{2,})]!");
    module.exports = parse4;
  }
});

// node_modules/css-tree/lib/definition-syntax/walk.js
var require_walk = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/walk.js"(exports, module) {
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    module.exports = function(node, options, context) {
      function walk(node2) {
        enter.call(context, node2);
        switch (node2.type) {
          case "Group":
            node2.terms.forEach(walk);
            break;
          case "Multiplier":
            walk(node2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + node2.type);
        }
        leave.call(context, node2);
      }
      var enter = noop;
      var leave = noop;
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walk(node, context);
    };
  }
});

// node_modules/css-tree/lib/lexer/prepare-tokens.js
var require_prepare_tokens = __commonJS({
  "node_modules/css-tree/lib/lexer/prepare-tokens.js"(exports, module) {
    var tokenize = require_tokenizer();
    var TokenStream = require_TokenStream();
    var tokenStream = new TokenStream();
    var astToTokens = {
      decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = "";
        return {
          children: handlers.children,
          node: function(node) {
            var tmp = curNode;
            curNode = node;
            handlers.node.call(this, node);
            curNode = tmp;
          },
          chunk: function(chunk) {
            buffer += chunk;
            if (prev.node !== curNode) {
              nodes.push({
                len: chunk.length,
                node: curNode
              });
            } else {
              prev.len += chunk.length;
            }
          },
          result: function() {
            return prepareTokens(buffer, nodes);
          }
        };
      }
    };
    function prepareTokens(str, nodes) {
      var tokens = [];
      var nodesOffset = 0;
      var nodesIndex = 0;
      var currentNode = nodes ? nodes[nodesIndex].node : null;
      tokenize(str, tokenStream);
      while (!tokenStream.eof) {
        if (nodes) {
          while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
            nodesOffset += nodes[nodesIndex++].len;
            currentNode = nodes[nodesIndex].node;
          }
        }
        tokens.push({
          type: tokenStream.tokenType,
          value: tokenStream.getTokenValue(),
          index: tokenStream.tokenIndex,
          balance: tokenStream.balance[tokenStream.tokenIndex],
          node: currentNode
        });
        tokenStream.next();
      }
      return tokens;
    }
    module.exports = function(value, syntax) {
      if (typeof value === "string") {
        return prepareTokens(value, null);
      }
      return syntax.generate(value, astToTokens);
    };
  }
});

// node_modules/css-tree/lib/lexer/match-graph.js
var require_match_graph = __commonJS({
  "node_modules/css-tree/lib/lexer/match-graph.js"(exports, module) {
    var parse4 = require_parse2();
    var MATCH = { type: "Match" };
    var MISMATCH = { type: "Mismatch" };
    var DISALLOW_EMPTY = { type: "DisallowEmpty" };
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function createCondition(match, thenBranch, elseBranch) {
      if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
      }
      if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
      }
      if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
      }
      return {
        type: "If",
        match,
        then: thenBranch,
        else: elseBranch
      };
    }
    function isFunctionType(name) {
      return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
    }
    function isEnumCapatible(term) {
      return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
    }
    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
      switch (combinator) {
        case " ":
          var result = MATCH;
          for (var i2 = terms.length - 1; i2 >= 0; i2--) {
            var term = terms[i2];
            result = createCondition(
              term,
              result,
              MISMATCH
            );
          }
          ;
          return result;
        case "|":
          var result = MISMATCH;
          var map2 = null;
          for (var i2 = terms.length - 1; i2 >= 0; i2--) {
            var term = terms[i2];
            if (isEnumCapatible(term)) {
              if (map2 === null && i2 > 0 && isEnumCapatible(terms[i2 - 1])) {
                map2 = /* @__PURE__ */ Object.create(null);
                result = createCondition(
                  {
                    type: "Enum",
                    map: map2
                  },
                  MATCH,
                  result
                );
              }
              if (map2 !== null) {
                var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                if (key in map2 === false) {
                  map2[key] = term;
                  continue;
                }
              }
            }
            map2 = null;
            result = createCondition(
              term,
              MATCH,
              result
            );
          }
          ;
          return result;
        case "&&":
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: true
            };
          }
          var result = MISMATCH;
          for (var i2 = terms.length - 1; i2 >= 0; i2--) {
            var term = terms[i2];
            var thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                false
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          ;
          return result;
        case "||":
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: false
            };
          }
          var result = atLeastOneTermMatched ? MATCH : MISMATCH;
          for (var i2 = terms.length - 1; i2 >= 0; i2--) {
            var term = terms[i2];
            var thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                true
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          ;
          return result;
      }
    }
    function buildMultiplierMatchGraph(node) {
      var result = MATCH;
      var matchTerm = buildMatchGraph(node.term);
      if (node.max === 0) {
        matchTerm = createCondition(
          matchTerm,
          DISALLOW_EMPTY,
          MISMATCH
        );
        result = createCondition(
          matchTerm,
          null,
          MISMATCH
        );
        result.then = createCondition(
          MATCH,
          MATCH,
          result
        );
        if (node.comma) {
          result.then.else = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
      } else {
        for (var i2 = node.min || 1; i2 <= node.max; i2++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            createCondition(
              MATCH,
              MATCH,
              result
            ),
            MISMATCH
          );
        }
      }
      if (node.min === 0) {
        result = createCondition(
          MATCH,
          MATCH,
          result
        );
      } else {
        for (var i2 = 0; i2 < node.min - 1; i2++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            result,
            MISMATCH
          );
        }
      }
      return result;
    }
    function buildMatchGraph(node) {
      if (typeof node === "function") {
        return {
          type: "Generic",
          fn: node
        };
      }
      switch (node.type) {
        case "Group":
          var result = buildGroupMatchGraph(
            node.combinator,
            node.terms.map(buildMatchGraph),
            false
          );
          if (node.disallowEmpty) {
            result = createCondition(
              result,
              DISALLOW_EMPTY,
              MISMATCH
            );
          }
          return result;
        case "Multiplier":
          return buildMultiplierMatchGraph(node);
        case "Type":
        case "Property":
          return {
            type: node.type,
            name: node.name,
            syntax: node
          };
        case "Keyword":
          return {
            type: node.type,
            name: node.name.toLowerCase(),
            syntax: node
          };
        case "AtKeyword":
          return {
            type: node.type,
            name: "@" + node.name.toLowerCase(),
            syntax: node
          };
        case "Function":
          return {
            type: node.type,
            name: node.name.toLowerCase() + "(",
            syntax: node
          };
        case "String":
          if (node.value.length === 3) {
            return {
              type: "Token",
              value: node.value.charAt(1),
              syntax: node
            };
          }
          return {
            type: node.type,
            value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
            syntax: node
          };
        case "Token":
          return {
            type: node.type,
            value: node.value,
            syntax: node
          };
        case "Comma":
          return {
            type: node.type,
            syntax: node
          };
        default:
          throw new Error("Unknown node type:", node.type);
      }
    }
    module.exports = {
      MATCH,
      MISMATCH,
      DISALLOW_EMPTY,
      buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === "string") {
          syntaxTree = parse4(syntaxTree);
        }
        return {
          type: "MatchGraph",
          match: buildMatchGraph(syntaxTree),
          syntax: ref || null,
          source: syntaxTree
        };
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/match.js
var require_match = __commonJS({
  "node_modules/css-tree/lib/lexer/match.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var matchGraph = require_match_graph();
    var MATCH = matchGraph.MATCH;
    var MISMATCH = matchGraph.MISMATCH;
    var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
    var TYPE = require_const().TYPE;
    var STUB = 0;
    var TOKEN = 1;
    var OPEN_SYNTAX = 2;
    var CLOSE_SYNTAX = 3;
    var EXIT_REASON_MATCH = "Match";
    var EXIT_REASON_MISMATCH = "Mismatch";
    var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
    var ITERATION_LIMIT = 15e3;
    var totalIterationCount = 0;
    function reverseList(list) {
      var prev = null;
      var next = null;
      var item = list;
      while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
      }
      return prev;
    }
    function areStringsEqualCaseInsensitive(testStr, referenceStr) {
      if (testStr.length !== referenceStr.length) {
        return false;
      }
      for (var i2 = 0; i2 < testStr.length; i2++) {
        var testCode = testStr.charCodeAt(i2);
        var referenceCode = referenceStr.charCodeAt(i2);
        if (testCode >= 65 && testCode <= 90) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function isContextEdgeDelim(token) {
      if (token.type !== TYPE.Delim) {
        return false;
      }
      return token.value !== "?";
    }
    function isCommaContextStart(token) {
      if (token === null) {
        return true;
      }
      return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || isContextEdgeDelim(token);
    }
    function isCommaContextEnd(token) {
      if (token === null) {
        return true;
      }
      return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;
    }
    function internalMatch(tokens, state, syntaxes) {
      function moveToNextToken() {
        do {
          tokenIndex++;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
      }
      function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;
        return nextIndex < tokens.length ? tokens[nextIndex] : null;
      }
      function stateSnapshotFromSyntax(nextState, prev) {
        return {
          nextState,
          matchStack,
          syntaxStack,
          thenStack,
          tokenIndex,
          prev
        };
      }
      function pushThenStack(nextState) {
        thenStack = {
          nextState,
          matchStack,
          syntaxStack,
          prev: thenStack
        };
      }
      function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
      }
      function addTokenToMatch() {
        matchStack = {
          type: TOKEN,
          syntax: state.syntax,
          token,
          prev: matchStack
        };
        moveToNextToken();
        syntaxStash = null;
        if (tokenIndex > longestMatch) {
          longestMatch = tokenIndex;
        }
      }
      function openSyntax() {
        syntaxStack = {
          syntax: state.syntax,
          opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
          prev: syntaxStack
        };
        matchStack = {
          type: OPEN_SYNTAX,
          syntax: state.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
          matchStack = matchStack.prev;
        } else {
          matchStack = {
            type: CLOSE_SYNTAX,
            syntax: syntaxStack.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        syntaxStack = syntaxStack.prev;
      }
      var syntaxStack = null;
      var thenStack = null;
      var elseStack = null;
      var syntaxStash = null;
      var iterationCount = 0;
      var exitReason = null;
      var token = null;
      var tokenIndex = -1;
      var longestMatch = 0;
      var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
      };
      moveToNextToken();
      while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        switch (state.type) {
          case "Match":
            if (thenStack === null) {
              if (token !== null) {
                if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                  state = MISMATCH;
                  break;
                }
              }
              exitReason = EXIT_REASON_MATCH;
              break;
            }
            state = thenStack.nextState;
            if (state === DISALLOW_EMPTY) {
              if (thenStack.matchStack === matchStack) {
                state = MISMATCH;
                break;
              } else {
                state = MATCH;
              }
            }
            while (thenStack.syntaxStack !== syntaxStack) {
              closeSyntax();
            }
            thenStack = thenStack.prev;
            break;
          case "Mismatch":
            if (syntaxStash !== null && syntaxStash !== false) {
              if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                elseStack = syntaxStash;
                syntaxStash = false;
              }
            } else if (elseStack === null) {
              exitReason = EXIT_REASON_MISMATCH;
              break;
            }
            state = elseStack.nextState;
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenIndex = elseStack.tokenIndex;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
            elseStack = elseStack.prev;
            break;
          case "MatchGraph":
            state = state.match;
            break;
          case "If":
            if (state.else !== MISMATCH) {
              pushElseStack(state.else);
            }
            if (state.then !== MATCH) {
              pushThenStack(state.then);
            }
            state = state.match;
            break;
          case "MatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer":
            var terms = state.syntax.terms;
            if (state.index === terms.length) {
              if (state.mask === 0 || state.syntax.all) {
                state = MISMATCH;
                break;
              }
              state = MATCH;
              break;
            }
            if (state.mask === (1 << terms.length) - 1) {
              state = MATCH;
              break;
            }
            for (; state.index < terms.length; state.index++) {
              var matchFlag = 1 << state.index;
              if ((state.mask & matchFlag) === 0) {
                pushElseStack(state);
                pushThenStack({
                  type: "AddMatchOnce",
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                });
                state = terms[state.index++];
                break;
              }
            }
            break;
          case "AddMatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state.syntax,
              index: 0,
              mask: state.mask
            };
            break;
          case "Enum":
            if (token !== null) {
              var name = token.value.toLowerCase();
              if (name.indexOf("\\") !== -1) {
                name = name.replace(/\\[09].*$/, "");
              }
              if (hasOwnProperty2.call(state.map, name)) {
                state = state.map[name];
                break;
              }
            }
            state = MISMATCH;
            break;
          case "Generic":
            var opts = syntaxStack !== null ? syntaxStack.opts : null;
            var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
            if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = MATCH;
            } else {
              state = MISMATCH;
            }
            break;
          case "Type":
          case "Property":
            var syntaxDict = state.type === "Type" ? "types" : "properties";
            var dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
            if (!dictSyntax || !dictSyntax.match) {
              throw new Error(
                "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
              );
            }
            if (syntaxStash !== false && token !== null && state.type === "Type") {
              var lowPriorityMatching = state.name === "custom-ident" && token.type === TYPE.Ident || state.name === "length" && token.value === "0";
              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }
                state = MISMATCH;
                break;
              }
            }
            openSyntax();
            state = dictSyntax.match;
            break;
          case "Keyword":
            var name = state.name;
            if (token !== null) {
              var keywordName = token.value;
              if (keywordName.indexOf("\\") !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, "");
              }
              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = MATCH;
                break;
              }
            }
            state = MISMATCH;
            break;
          case "AtKeyword":
          case "Function":
            if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
            state = MISMATCH;
            break;
          case "Token":
            if (token !== null && token.value === state.value) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
            state = MISMATCH;
            break;
          case "Comma":
            if (token !== null && token.type === TYPE.Comma) {
              if (isCommaContextStart(matchStack.token)) {
                state = MISMATCH;
              } else {
                addTokenToMatch();
                state = isCommaContextEnd(token) ? MISMATCH : MATCH;
              }
            } else {
              state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
            }
            break;
          case "String":
            var string2 = "";
            for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string2.length < state.value.length; lastTokenIndex++) {
              string2 += tokens[lastTokenIndex].value;
            }
            if (areStringsEqualCaseInsensitive(string2, state.value)) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = MATCH;
            } else {
              state = MISMATCH;
            }
            break;
          default:
            throw new Error("Unknown node type: " + state.type);
        }
      }
      totalIterationCount += iterationCount;
      switch (exitReason) {
        case null:
          console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
          exitReason = EXIT_REASON_ITERATION_LIMIT;
          matchStack = null;
          break;
        case EXIT_REASON_MATCH:
          while (syntaxStack !== null) {
            closeSyntax();
          }
          break;
        default:
          matchStack = null;
      }
      return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
      };
    }
    function matchAsList(tokens, matchGraph2, syntaxes) {
      var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;
        matchResult.match = [];
        while (item !== null) {
          switch (item.type) {
            case STUB:
              break;
            case OPEN_SYNTAX:
            case CLOSE_SYNTAX:
              matchResult.match.push({
                type: item.type,
                syntax: item.syntax
              });
              break;
            default:
              matchResult.match.push({
                token: item.token.value,
                node: item.token.node
              });
              break;
          }
          item = item.prev;
        }
      }
      return matchResult;
    }
    function matchAsTree(tokens, matchGraph2, syntaxes) {
      var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match === null) {
        return matchResult;
      }
      var item = matchResult.match;
      var host = matchResult.match = {
        syntax: matchGraph2.syntax || null,
        match: []
      };
      var hostStack = [host];
      item = reverseList(item).prev;
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
            host.match.push(host = {
              syntax: item.syntax,
              match: []
            });
            hostStack.push(host);
            break;
          case CLOSE_SYNTAX:
            hostStack.pop();
            host = hostStack[hostStack.length - 1];
            break;
          default:
            host.match.push({
              syntax: item.syntax || null,
              token: item.token.value,
              node: item.token.node
            });
        }
        item = item.prev;
      }
      return matchResult;
    }
    module.exports = {
      matchAsList,
      matchAsTree,
      getTotalIterationCount: function() {
        return totalIterationCount;
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/trace.js
var require_trace = __commonJS({
  "node_modules/css-tree/lib/lexer/trace.js"(exports, module) {
    function getTrace(node) {
      function shouldPutToTrace(syntax) {
        if (syntax === null) {
          return false;
        }
        return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
      }
      function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
          for (var i2 = 0; i2 < matchNode.match.length; i2++) {
            if (hasMatch(matchNode.match[i2])) {
              if (shouldPutToTrace(matchNode.syntax)) {
                result.unshift(matchNode.syntax);
              }
              return true;
            }
          }
        } else if (matchNode.node === node) {
          result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
          return true;
        }
        return false;
      }
      var result = null;
      if (this.matched !== null) {
        hasMatch(this.matched);
      }
      return result;
    }
    function testNode(match, node, fn) {
      var trace = getTrace.call(match, node);
      if (trace === null) {
        return false;
      }
      return trace.some(fn);
    }
    function isType(node, type) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Type" && matchNode.name === type;
      });
    }
    function isProperty(node, property) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Property" && matchNode.name === property;
      });
    }
    function isKeyword(node) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Keyword";
      });
    }
    module.exports = {
      getTrace,
      isType,
      isProperty,
      isKeyword
    };
  }
});

// node_modules/css-tree/lib/lexer/search.js
var require_search = __commonJS({
  "node_modules/css-tree/lib/lexer/search.js"(exports, module) {
    var List = require_List();
    function getFirstMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getFirstMatchNode(matchNode.match[0]);
    }
    function getLastMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    }
    function matchFragments(lexer, ast, match, type, name) {
      function findFragments(matchNode) {
        if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
          var start = getFirstMatchNode(matchNode);
          var end = getLastMatchNode(matchNode);
          lexer.syntax.walk(ast, function(node, item, list) {
            if (node === start) {
              var nodes = new List();
              do {
                nodes.appendData(item.data);
                if (item.data === end) {
                  break;
                }
                item = item.next;
              } while (item !== null);
              fragments.push({
                parent: list,
                nodes
              });
            }
          });
        }
        if (Array.isArray(matchNode.match)) {
          matchNode.match.forEach(findFragments);
        }
      }
      var fragments = [];
      if (match.matched !== null) {
        findFragments(match.matched);
      }
      return fragments;
    }
    module.exports = {
      matchFragments
    };
  }
});

// node_modules/css-tree/lib/lexer/structure.js
var require_structure = __commonJS({
  "node_modules/css-tree/lib/lexer/structure.js"(exports, module) {
    var List = require_List();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isValidNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
    function isValidLocation(loc) {
      return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
    }
    function createNodeStructureChecker(type, fields) {
      return function checkNode(node, warn2) {
        if (!node || node.constructor !== Object) {
          return warn2(node, "Type of node should be an Object");
        }
        for (var key in node) {
          var valid = true;
          if (hasOwnProperty2.call(node, key) === false) {
            continue;
          }
          if (key === "type") {
            if (node.type !== type) {
              warn2(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
            }
          } else if (key === "loc") {
            if (node.loc === null) {
              continue;
            } else if (node.loc && node.loc.constructor === Object) {
              if (typeof node.loc.source !== "string") {
                key += ".source";
              } else if (!isValidLocation(node.loc.start)) {
                key += ".start";
              } else if (!isValidLocation(node.loc.end)) {
                key += ".end";
              } else {
                continue;
              }
            }
            valid = false;
          } else if (fields.hasOwnProperty(key)) {
            for (var i2 = 0, valid = false; !valid && i2 < fields[key].length; i2++) {
              var fieldType = fields[key][i2];
              switch (fieldType) {
                case String:
                  valid = typeof node[key] === "string";
                  break;
                case Boolean:
                  valid = typeof node[key] === "boolean";
                  break;
                case null:
                  valid = node[key] === null;
                  break;
                default:
                  if (typeof fieldType === "string") {
                    valid = node[key] && node[key].type === fieldType;
                  } else if (Array.isArray(fieldType)) {
                    valid = node[key] instanceof List;
                  }
              }
            }
          } else {
            warn2(node, "Unknown field `" + key + "` for " + type + " node type");
          }
          if (!valid) {
            warn2(node, "Bad value for `" + type + "." + key + "`");
          }
        }
        for (var key in fields) {
          if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
            warn2(node, "Field `" + type + "." + key + "` is missed");
          }
        }
      };
    }
    function processStructure(name, nodeType) {
      var structure = nodeType.structure;
      var fields = {
        type: String,
        loc: true
      };
      var docs = {
        type: '"' + name + '"'
      };
      for (var key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
        for (var i2 = 0; i2 < fieldTypes.length; i2++) {
          var fieldType = fieldTypes[i2];
          if (fieldType === String || fieldType === Boolean) {
            docsTypes.push(fieldType.name);
          } else if (fieldType === null) {
            docsTypes.push("null");
          } else if (typeof fieldType === "string") {
            docsTypes.push("<" + fieldType + ">");
          } else if (Array.isArray(fieldType)) {
            docsTypes.push("List");
          } else {
            throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
          }
        }
        docs[key] = docsTypes.join(" | ");
      }
      return {
        docs,
        check: createNodeStructureChecker(name, fields)
      };
    }
    module.exports = {
      getStructureFromConfig: function(config) {
        var structure = {};
        if (config.node) {
          for (var name in config.node) {
            if (hasOwnProperty2.call(config.node, name)) {
              var nodeType = config.node[name];
              if (nodeType.structure) {
                structure[name] = processStructure(name, nodeType);
              } else {
                throw new Error("Missed `structure` field in `" + name + "` node type definition");
              }
            }
          }
        }
        return structure;
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/css-tree/lib/lexer/Lexer.js"(exports, module) {
    var SyntaxReferenceError = require_error().SyntaxReferenceError;
    var SyntaxMatchError = require_error().SyntaxMatchError;
    var names = require_names();
    var generic = require_generic();
    var parse4 = require_parse2();
    var generate = require_generate();
    var walk = require_walk();
    var prepareTokens = require_prepare_tokens();
    var buildMatchGraph = require_match_graph().buildMatchGraph;
    var matchAsTree = require_match().matchAsTree;
    var trace = require_trace();
    var search = require_search();
    var getStructureFromConfig = require_structure().getStructureFromConfig;
    var cssWideKeywords = buildMatchGraph("inherit | initial | unset");
    var cssWideKeywordsWithExpression = buildMatchGraph("inherit | initial | unset | <-ms-legacy-expression>");
    function dumpMapSyntax(map2, compact, syntaxAsAst) {
      var result = {};
      for (var name in map2) {
        if (map2[name].syntax) {
          result[name] = syntaxAsAst ? map2[name].syntax : generate(map2[name].syntax, { compact });
        }
      }
      return result;
    }
    function dumpAtruleMapSyntax(map2, compact, syntaxAsAst) {
      const result = {};
      for (const [name, atrule] of Object.entries(map2)) {
        result[name] = {
          prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
          descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
      }
      return result;
    }
    function valueHasVar(tokens) {
      for (var i2 = 0; i2 < tokens.length; i2++) {
        if (tokens[i2].value.toLowerCase() === "var(") {
          return true;
        }
      }
      return false;
    }
    function buildMatchResult(match, error, iterations) {
      return {
        matched: match,
        iterations,
        error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
      };
    }
    function matchSyntax(lexer, syntax, value, useCommon) {
      var tokens = prepareTokens(value, lexer.syntax);
      var result;
      if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
      }
      if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
      }
      if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
          return buildMatchResult(
            null,
            new SyntaxMatchError(result.reason, syntax.syntax, value, result),
            result.iterations
          );
        }
      }
      return buildMatchResult(result.match, null, result.iterations);
    }
    var Lexer = function(config, syntax, structure) {
      this.valueCommonSyntax = cssWideKeywords;
      this.syntax = syntax;
      this.generic = false;
      this.atrules = {};
      this.properties = {};
      this.types = {};
      this.structure = structure || getStructureFromConfig(config);
      if (config) {
        if (config.types) {
          for (var name in config.types) {
            this.addType_(name, config.types[name]);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (var name in generic) {
            this.addType_(name, generic[name]);
          }
        }
        if (config.atrules) {
          for (var name in config.atrules) {
            this.addAtrule_(name, config.atrules[name]);
          }
        }
        if (config.properties) {
          for (var name in config.properties) {
            this.addProperty_(name, config.properties[name]);
          }
        }
      }
    };
    Lexer.prototype = {
      structure: {},
      checkStructure: function(ast) {
        function collectWarning(node, message) {
          warns.push({
            node,
            message
          });
        }
        var structure = this.structure;
        var warns = [];
        this.syntax.walk(ast, function(node) {
          if (structure.hasOwnProperty(node.type)) {
            structure[node.type].check(node, collectWarning);
          } else {
            collectWarning(node, "Unknown node type `" + node.type + "`");
          }
        });
        return warns.length ? warns : false;
      },
      createDescriptor: function(syntax, type, name, parent = null) {
        var ref = {
          type,
          name
        };
        var descriptor = {
          type,
          name,
          parent,
          syntax: null,
          match: null
        };
        if (typeof syntax === "function") {
          descriptor.match = buildMatchGraph(syntax, ref);
        } else {
          if (typeof syntax === "string") {
            Object.defineProperty(descriptor, "syntax", {
              get: function() {
                Object.defineProperty(descriptor, "syntax", {
                  value: parse4(syntax)
                });
                return descriptor.syntax;
              }
            });
          } else {
            descriptor.syntax = syntax;
          }
          Object.defineProperty(descriptor, "match", {
            get: function() {
              Object.defineProperty(descriptor, "match", {
                value: buildMatchGraph(descriptor.syntax, ref)
              });
              return descriptor.match;
            }
          });
        }
        return descriptor;
      },
      addAtrule_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.atrules[name] = {
          type: "Atrule",
          name,
          prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
          descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, descName) => {
            res[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
            return res;
          }, {}) : null
        };
      },
      addProperty_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.properties[name] = this.createDescriptor(syntax, "Property", name);
      },
      addType_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.types[name] = this.createDescriptor(syntax, "Type", name);
        if (syntax === generic["-ms-legacy-expression"]) {
          this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
      },
      checkAtruleName: function(atruleName) {
        if (!this.getAtrule(atruleName)) {
          return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
        }
      },
      checkAtrulePrelude: function(atruleName, prelude) {
        let error = this.checkAtruleName(atruleName);
        if (error) {
          return error;
        }
        var atrule = this.getAtrule(atruleName);
        if (!atrule.prelude && prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
        }
        if (atrule.prelude && !prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      },
      checkAtruleDescriptorName: function(atruleName, descriptorName) {
        let error = this.checkAtruleName(atruleName);
        if (error) {
          return error;
        }
        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);
        if (!atrule.descriptors) {
          return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
        }
        if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
          return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
        }
      },
      checkPropertyName: function(propertyName) {
        var property = names.property(propertyName);
        if (property.custom) {
          return new Error("Lexer matching doesn't applicable for custom properties");
        }
        if (!this.getProperty(propertyName)) {
          return new SyntaxReferenceError("Unknown property", propertyName);
        }
      },
      matchAtrulePrelude: function(atruleName, prelude) {
        var error = this.checkAtrulePrelude(atruleName, prelude);
        if (error) {
          return buildMatchResult(null, error);
        }
        if (!prelude) {
          return buildMatchResult(null, null);
        }
        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
      },
      matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);
        if (error) {
          return buildMatchResult(null, error);
        }
        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);
        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
      },
      matchDeclaration: function(node) {
        if (node.type !== "Declaration") {
          return buildMatchResult(null, new Error("Not a Declaration node"));
        }
        return this.matchProperty(node.property, node.value);
      },
      matchProperty: function(propertyName, value) {
        var error = this.checkPropertyName(propertyName);
        if (error) {
          return buildMatchResult(null, error);
        }
        return matchSyntax(this, this.getProperty(propertyName), value, true);
      },
      matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);
        if (!typeSyntax) {
          return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
        }
        return matchSyntax(this, typeSyntax, value, false);
      },
      match: function(syntax, value) {
        if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
          return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
        }
        if (typeof syntax === "string" || !syntax.match) {
          syntax = this.createDescriptor(syntax, "Type", "anonymous");
        }
        return matchSyntax(this, syntax, value, false);
      },
      findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
      },
      findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
      },
      findAllFragments: function(ast, type, name) {
        var result = [];
        this.syntax.walk(ast, {
          visit: "Declaration",
          enter: function(declaration) {
            result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
          }.bind(this)
        });
        return result;
      },
      getAtrule: function(atruleName, fallbackBasename = true) {
        var atrule = names.keyword(atruleName);
        var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
        return atruleEntry || null;
      },
      getAtrulePrelude: function(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);
        return atrule && atrule.prelude || null;
      },
      getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
      },
      getProperty: function(propertyName, fallbackBasename = true) {
        var property = names.property(propertyName);
        var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
        return propertyEntry || null;
      },
      getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
      },
      validate: function() {
        function validate(syntax, name, broken, descriptor) {
          if (broken.hasOwnProperty(name)) {
            return broken[name];
          }
          broken[name] = false;
          if (descriptor.syntax !== null) {
            walk(descriptor.syntax, function(node) {
              if (node.type !== "Type" && node.type !== "Property") {
                return;
              }
              var map2 = node.type === "Type" ? syntax.types : syntax.properties;
              var brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
              if (!map2.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map2[node.name])) {
                broken[name] = true;
              }
            }, this);
          }
        }
        var brokenTypes = {};
        var brokenProperties = {};
        for (var key in this.types) {
          validate(this, key, brokenTypes, this.types[key]);
        }
        for (var key in this.properties) {
          validate(this, key, brokenProperties, this.properties[key]);
        }
        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
          return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
          return brokenProperties[name];
        });
        if (brokenTypes.length || brokenProperties.length) {
          return {
            types: brokenTypes,
            properties: brokenProperties
          };
        }
        return null;
      },
      dump: function(syntaxAsAst, pretty) {
        return {
          generic: this.generic,
          types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
          properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
          atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
      },
      toString: function() {
        return JSON.stringify(this.dump());
      }
    };
    module.exports = Lexer;
  }
});

// node_modules/css-tree/lib/definition-syntax/index.js
var require_definition_syntax = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/index.js"(exports, module) {
    module.exports = {
      SyntaxError: require_SyntaxError2(),
      parse: require_parse2(),
      generate: require_generate(),
      walk: require_walk()
    };
  }
});

// node_modules/css-tree/lib/common/OffsetToLocation.js
var require_OffsetToLocation = __commonJS({
  "node_modules/css-tree/lib/common/OffsetToLocation.js"(exports, module) {
    var adoptBuffer = require_adopt_buffer();
    var isBOM = require_tokenizer().isBOM;
    var N2 = 10;
    var F = 12;
    var R = 13;
    function computeLinesAndColumns(host, source) {
      var sourceLength = source.length;
      var lines = adoptBuffer(host.lines, sourceLength);
      var line = host.startLine;
      var columns = adoptBuffer(host.columns, sourceLength);
      var column = host.startColumn;
      var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
      for (var i2 = startOffset; i2 < sourceLength; i2++) {
        var code = source.charCodeAt(i2);
        lines[i2] = line;
        columns[i2] = column++;
        if (code === N2 || code === R || code === F) {
          if (code === R && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N2) {
            i2++;
            lines[i2] = line;
            columns[i2] = column;
          }
          line++;
          column = 1;
        }
      }
      lines[i2] = line;
      columns[i2] = column;
      host.lines = lines;
      host.columns = columns;
    }
    var OffsetToLocation = function() {
      this.lines = null;
      this.columns = null;
      this.linesAndColumnsComputed = false;
    };
    OffsetToLocation.prototype = {
      setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === "undefined" ? 0 : startOffset;
        this.startLine = typeof startLine === "undefined" ? 1 : startLine;
        this.startColumn = typeof startColumn === "undefined" ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
      },
      ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
          computeLinesAndColumns(this, this.source);
          this.linesAndColumnsComputed = true;
        }
      },
      getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();
        return {
          source: filename,
          offset: this.startOffset + offset,
          line: this.lines[offset],
          column: this.columns[offset]
        };
      },
      getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();
        return {
          source: filename,
          start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
          },
          end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
          }
        };
      }
    };
    module.exports = OffsetToLocation;
  }
});

// node_modules/css-tree/lib/parser/sequence.js
var require_sequence = __commonJS({
  "node_modules/css-tree/lib/parser/sequence.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    module.exports = function readSequence(recognizer) {
      var children = this.createList();
      var child = null;
      var context = {
        recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
      };
      this.scanner.skipSC();
      while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case COMMENT:
            this.scanner.next();
            continue;
          case WHITESPACE:
            if (context.ignoreWS) {
              this.scanner.next();
            } else {
              context.space = this.WhiteSpace();
            }
            continue;
        }
        child = recognizer.getNode.call(this, context);
        if (child === void 0) {
          break;
        }
        if (context.space !== null) {
          children.push(context.space);
          context.space = null;
        }
        children.push(child);
        if (context.ignoreWSAfter) {
          context.ignoreWSAfter = false;
          context.ignoreWS = true;
        } else {
          context.ignoreWS = false;
        }
      }
      return children;
    };
  }
});

// node_modules/css-tree/lib/parser/create.js
var require_create = __commonJS({
  "node_modules/css-tree/lib/parser/create.js"(exports, module) {
    var OffsetToLocation = require_OffsetToLocation();
    var SyntaxError2 = require_SyntaxError();
    var TokenStream = require_TokenStream();
    var List = require_List();
    var tokenize = require_tokenizer();
    var constants = require_const();
    var { findWhiteSpaceStart, cmpStr } = require_utils2();
    var sequence = require_sequence();
    var noop = function() {
    };
    var TYPE = constants.TYPE;
    var NAME = constants.NAME;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var URL2 = TYPE.Url;
    var HASH = TYPE.Hash;
    var PERCENTAGE = TYPE.Percentage;
    var NUMBER = TYPE.Number;
    var NUMBERSIGN = 35;
    var NULL = 0;
    function createParseContext(name) {
      return function() {
        return this[name]();
      };
    }
    function processConfig(config) {
      var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
      };
      if (config.parseContext) {
        for (var name in config.parseContext) {
          switch (typeof config.parseContext[name]) {
            case "function":
              parserConfig.context[name] = config.parseContext[name];
              break;
            case "string":
              parserConfig.context[name] = createParseContext(config.parseContext[name]);
              break;
          }
        }
      }
      if (config.scope) {
        for (var name in config.scope) {
          parserConfig.scope[name] = config.scope[name];
        }
      }
      if (config.atrule) {
        for (var name in config.atrule) {
          var atrule = config.atrule[name];
          if (atrule.parse) {
            parserConfig.atrule[name] = atrule.parse;
          }
        }
      }
      if (config.pseudo) {
        for (var name in config.pseudo) {
          var pseudo = config.pseudo[name];
          if (pseudo.parse) {
            parserConfig.pseudo[name] = pseudo.parse;
          }
        }
      }
      if (config.node) {
        for (var name in config.node) {
          parserConfig[name] = config.node[name].parse;
        }
      }
      return parserConfig;
    }
    module.exports = function createParser(config) {
      var parser = {
        scanner: new TokenStream(),
        locationMap: new OffsetToLocation(),
        filename: "<unknown>",
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: sequence,
        createList: function() {
          return new List();
        },
        createSingleNodeList: function(node) {
          return new List().appendData(node);
        },
        getFirstListNode: function(list) {
          return list && list.first();
        },
        getLastListNode: function(list) {
          return list.last();
        },
        parseWithFallback: function(consumer, fallback) {
          var startToken = this.scanner.tokenIndex;
          try {
            return consumer.call(this);
          } catch (e2) {
            if (this.onParseErrorThrow) {
              throw e2;
            }
            var fallbackNode = fallback.call(this, startToken);
            this.onParseErrorThrow = true;
            this.onParseError(e2, fallbackNode);
            this.onParseErrorThrow = false;
            return fallbackNode;
          }
        },
        lookupNonWSType: function(offset) {
          do {
            var type = this.scanner.lookupType(offset++);
            if (type !== WHITESPACE) {
              return type;
            }
          } while (type !== NULL);
          return NULL;
        },
        eat: function(tokenType) {
          if (this.scanner.tokenType !== tokenType) {
            var offset = this.scanner.tokenStart;
            var message = NAME[tokenType] + " is expected";
            switch (tokenType) {
              case IDENT:
                if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL2) {
                  offset = this.scanner.tokenEnd - 1;
                  message = "Identifier is expected but function found";
                } else {
                  message = "Identifier is expected";
                }
                break;
              case HASH:
                if (this.scanner.isDelim(NUMBERSIGN)) {
                  this.scanner.next();
                  offset++;
                  message = "Name is expected";
                }
                break;
              case PERCENTAGE:
                if (this.scanner.tokenType === NUMBER) {
                  offset = this.scanner.tokenEnd;
                  message = "Percent sign is expected";
                }
                break;
              default:
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                  offset = offset + 1;
                }
            }
            this.error(message, offset);
          }
          this.scanner.next();
        },
        consume: function(tokenType) {
          var value = this.scanner.getTokenValue();
          this.eat(tokenType);
          return value;
        },
        consumeFunctionName: function() {
          var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
          this.eat(FUNCTION);
          return name;
        },
        getLocation: function(start, end) {
          if (this.needPositions) {
            return this.locationMap.getLocationRange(
              start,
              end,
              this.filename
            );
          }
          return null;
        },
        getLocationFromList: function(list) {
          if (this.needPositions) {
            var head = this.getFirstListNode(list);
            var tail = this.getLastListNode(list);
            return this.locationMap.getLocationRange(
              head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
              tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
              this.filename
            );
          }
          return null;
        },
        error: function(message, offset) {
          var location = typeof offset !== "undefined" && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
          throw new SyntaxError2(
            message || "Unexpected input",
            this.scanner.source,
            location.offset,
            location.line,
            location.column
          );
        }
      };
      config = processConfig(config || {});
      for (var key in config) {
        parser[key] = config[key];
      }
      return function(source, options) {
        options = options || {};
        var context = options.context || "default";
        var onComment = options.onComment;
        var ast;
        tokenize(source, parser.scanner);
        parser.locationMap.setSource(
          source,
          options.offset,
          options.line,
          options.column
        );
        parser.filename = options.filename || "<unknown>";
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === "function" ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
        if (!parser.context.hasOwnProperty(context)) {
          throw new Error("Unknown context `" + context + "`");
        }
        if (typeof onComment === "function") {
          parser.scanner.forEachToken((type, start, end) => {
            if (type === COMMENT) {
              const loc = parser.getLocation(start, end);
              const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
              onComment(value, loc);
            }
          });
        }
        ast = parser.context[context].call(parser, options);
        if (!parser.scanner.eof) {
          parser.error();
        }
        return ast;
      };
    };
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set2 = new ArraySet();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set2.add(aArray[i2], aAllowDuplicates);
      }
      return set2;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map2 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map2.file = this._file;
      }
      if (this._sourceRoot != null) {
        map2.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
      }
      return map2;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/css-tree/lib/generator/sourceMap.js
var require_sourceMap = __commonJS({
  "node_modules/css-tree/lib/generator/sourceMap.js"(exports, module) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var trackNodes = {
      Atrule: true,
      Selector: true,
      Declaration: true
    };
    module.exports = function generateSourceMap(handlers) {
      var map2 = new SourceMapGenerator();
      var line = 1;
      var column = 0;
      var generated = {
        line: 1,
        column: 0
      };
      var original = {
        line: 0,
        column: 0
      };
      var sourceMappingActive = false;
      var activatedGenerated = {
        line: 1,
        column: 0
      };
      var activatedMapping = {
        generated: activatedGenerated
      };
      var handlersNode = handlers.node;
      handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
          var nodeLine = node.loc.start.line;
          var nodeColumn = node.loc.start.column - 1;
          if (original.line !== nodeLine || original.column !== nodeColumn) {
            original.line = nodeLine;
            original.column = nodeColumn;
            generated.line = line;
            generated.column = column;
            if (sourceMappingActive) {
              sourceMappingActive = false;
              if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                map2.addMapping(activatedMapping);
              }
            }
            sourceMappingActive = true;
            map2.addMapping({
              source: node.loc.source,
              original,
              generated
            });
          }
        }
        handlersNode.call(this, node);
        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
          activatedGenerated.line = line;
          activatedGenerated.column = column;
        }
      };
      var handlersChunk = handlers.chunk;
      handlers.chunk = function(chunk) {
        for (var i2 = 0; i2 < chunk.length; i2++) {
          if (chunk.charCodeAt(i2) === 10) {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        handlersChunk(chunk);
      };
      var handlersResult = handlers.result;
      handlers.result = function() {
        if (sourceMappingActive) {
          map2.addMapping(activatedMapping);
        }
        return {
          css: handlersResult(),
          map: map2
        };
      };
      return handlers;
    };
  }
});

// node_modules/css-tree/lib/generator/create.js
var require_create2 = __commonJS({
  "node_modules/css-tree/lib/generator/create.js"(exports, module) {
    var sourceMap = require_sourceMap();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function processChildren(node, delimeter) {
      var list = node.children;
      var prev = null;
      if (typeof delimeter !== "function") {
        list.forEach(this.node, this);
      } else {
        list.forEach(function(node2) {
          if (prev !== null) {
            delimeter.call(this, prev);
          }
          this.node(node2);
          prev = node2;
        }, this);
      }
    }
    module.exports = function createGenerator(config) {
      function processNode(node) {
        if (hasOwnProperty2.call(types, node.type)) {
          types[node.type].call(this, node);
        } else {
          throw new Error("Unknown node type: " + node.type);
        }
      }
      var types = {};
      if (config.node) {
        for (var name in config.node) {
          types[name] = config.node[name].generate;
        }
      }
      return function(node, options) {
        var buffer = "";
        var handlers = {
          children: processChildren,
          node: processNode,
          chunk: function(chunk) {
            buffer += chunk;
          },
          result: function() {
            return buffer;
          }
        };
        if (options) {
          if (typeof options.decorator === "function") {
            handlers = options.decorator(handlers);
          }
          if (options.sourceMap) {
            handlers = sourceMap(handlers);
          }
        }
        handlers.node(node);
        return handlers.result();
      };
    };
  }
});

// node_modules/css-tree/lib/convertor/create.js
var require_create3 = __commonJS({
  "node_modules/css-tree/lib/convertor/create.js"(exports, module) {
    var List = require_List();
    module.exports = function createConvertors(walk) {
      return {
        fromPlainObject: function(ast) {
          walk(ast, {
            enter: function(node) {
              if (node.children && node.children instanceof List === false) {
                node.children = new List().fromArray(node.children);
              }
            }
          });
          return ast;
        },
        toPlainObject: function(ast) {
          walk(ast, {
            leave: function(node) {
              if (node.children && node.children instanceof List) {
                node.children = node.children.toArray();
              }
            }
          });
          return ast;
        }
      };
    };
  }
});

// node_modules/css-tree/lib/walker/create.js
var require_create4 = __commonJS({
  "node_modules/css-tree/lib/walker/create.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function invokeForType(fn, type) {
      return function(node, item, list) {
        if (node.type === type) {
          fn.call(this, node, item, list);
        }
      };
    }
    function getWalkersFromStructure(name, nodeType) {
      var structure = nodeType.structure;
      var walkers = [];
      for (var key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        var fieldTypes = structure[key];
        var walker = {
          name: key,
          type: false,
          nullable: false
        };
        if (!Array.isArray(structure[key])) {
          fieldTypes = [structure[key]];
        }
        for (var i2 = 0; i2 < fieldTypes.length; i2++) {
          var fieldType = fieldTypes[i2];
          if (fieldType === null) {
            walker.nullable = true;
          } else if (typeof fieldType === "string") {
            walker.type = "node";
          } else if (Array.isArray(fieldType)) {
            walker.type = "list";
          }
        }
        if (walker.type) {
          walkers.push(walker);
        }
      }
      if (walkers.length) {
        return {
          context: nodeType.walkContext,
          fields: walkers
        };
      }
      return null;
    }
    function getTypesFromConfig(config) {
      var types = {};
      for (var name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          var nodeType = config.node[name];
          if (!nodeType.structure) {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
          types[name] = getWalkersFromStructure(name, nodeType);
        }
      }
      return types;
    }
    function createTypeIterator(config, reverse) {
      var fields = config.fields.slice();
      var contextName = config.context;
      var useContext = typeof contextName === "string";
      if (reverse) {
        fields.reverse();
      }
      return function(node, context, walk, walkReducer) {
        var prevContextValue;
        if (useContext) {
          prevContextValue = context[contextName];
          context[contextName] = node;
        }
        for (var i2 = 0; i2 < fields.length; i2++) {
          var field = fields[i2];
          var ref = node[field.name];
          if (!field.nullable || ref) {
            if (field.type === "list") {
              var breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
              if (breakWalk) {
                return true;
              }
            } else if (walk(ref)) {
              return true;
            }
          }
        }
        if (useContext) {
          context[contextName] = prevContextValue;
        }
      };
    }
    function createFastTraveralMap(iterators) {
      return {
        Atrule: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block
        },
        Rule: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block
        },
        Declaration: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block,
          DeclarationList: iterators.DeclarationList
        }
      };
    }
    module.exports = function createWalker(config) {
      var types = getTypesFromConfig(config);
      var iteratorsNatural = {};
      var iteratorsReverse = {};
      var breakWalk = Symbol("break-walk");
      var skipNode = Symbol("skip-node");
      for (var name in types) {
        if (hasOwnProperty2.call(types, name) && types[name] !== null) {
          iteratorsNatural[name] = createTypeIterator(types[name], false);
          iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
      }
      var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
      var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
      var walk = function(root, options) {
        function walkNode(node, item, list) {
          var enterRet = enter.call(context, node, item, list);
          if (enterRet === breakWalk) {
            debugger;
            return true;
          }
          if (enterRet === skipNode) {
            return false;
          }
          if (iterators.hasOwnProperty(node.type)) {
            if (iterators[node.type](node, context, walkNode, walkReducer)) {
              return true;
            }
          }
          if (leave.call(context, node, item, list) === breakWalk) {
            return true;
          }
          return false;
        }
        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
          break: breakWalk,
          skip: skipNode,
          root,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
          if (options.reverse) {
            iterators = iteratorsReverse;
          }
          if (options.visit) {
            if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
              iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
            } else if (!types.hasOwnProperty(options.visit)) {
              throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).join(", ") + ")");
            }
            enter = invokeForType(enter, options.visit);
            leave = invokeForType(leave, options.visit);
          }
        }
        if (enter === noop && leave === noop) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walkNode(root);
      };
      walk.break = breakWalk;
      walk.skip = skipNode;
      walk.find = function(ast, fn) {
        var found = null;
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        });
        return found;
      };
      walk.findLast = function(ast, fn) {
        var found = null;
        walk(ast, {
          reverse: true,
          enter: function(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          }
        });
        return found;
      };
      walk.findAll = function(ast, fn) {
        var found = [];
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found.push(node);
          }
        });
        return found;
      };
      return walk;
    };
  }
});

// node_modules/css-tree/lib/utils/clone.js
var require_clone = __commonJS({
  "node_modules/css-tree/lib/utils/clone.js"(exports, module) {
    var List = require_List();
    module.exports = function clone(node) {
      var result = {};
      for (var key in node) {
        var value = node[key];
        if (value) {
          if (Array.isArray(value) || value instanceof List) {
            value = value.map(clone);
          } else if (value.constructor === Object) {
            value = clone(value);
          }
        }
        result[key] = value;
      }
      return result;
    };
  }
});

// node_modules/css-tree/lib/syntax/config/mix.js
var require_mix = __commonJS({
  "node_modules/css-tree/lib/syntax/config/mix.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var shape = {
      generic: true,
      types: appendOrAssign,
      atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
      },
      properties: appendOrAssign,
      parseContext: assign,
      scope: deepAssign,
      atrule: ["parse"],
      pseudo: ["parse"],
      node: ["name", "structure", "parse", "generate", "walkContext"]
    };
    function isObject(value) {
      return value && value.constructor === Object;
    }
    function copy(value) {
      return isObject(value) ? Object.assign({}, value) : value;
    }
    function assign(dest, src) {
      return Object.assign(dest, src);
    }
    function deepAssign(dest, src) {
      for (const key in src) {
        if (hasOwnProperty2.call(src, key)) {
          if (isObject(dest[key])) {
            deepAssign(dest[key], copy(src[key]));
          } else {
            dest[key] = copy(src[key]);
          }
        }
      }
      return dest;
    }
    function append(a2, b2) {
      if (typeof b2 === "string" && /^\s*\|/.test(b2)) {
        return typeof a2 === "string" ? a2 + b2 : b2.replace(/^\s*\|\s*/, "");
      }
      return b2 || null;
    }
    function appendOrAssign(a2, b2) {
      if (typeof b2 === "string") {
        return append(a2, b2);
      }
      const result = Object.assign({}, a2);
      for (let key in b2) {
        if (hasOwnProperty2.call(b2, key)) {
          result[key] = append(hasOwnProperty2.call(a2, key) ? a2[key] : void 0, b2[key]);
        }
      }
      return result;
    }
    function appendOrAssignOrNull(a2, b2) {
      const result = appendOrAssign(a2, b2);
      return !isObject(result) || Object.keys(result).length ? result : null;
    }
    function mix(dest, src, shape2) {
      for (const key in shape2) {
        if (hasOwnProperty2.call(shape2, key) === false) {
          continue;
        }
        if (shape2[key] === true) {
          if (key in src) {
            if (hasOwnProperty2.call(src, key)) {
              dest[key] = copy(src[key]);
            }
          }
        } else if (shape2[key]) {
          if (typeof shape2[key] === "function") {
            const fn = shape2[key];
            dest[key] = fn({}, dest[key]);
            dest[key] = fn(dest[key] || {}, src[key]);
          } else if (isObject(shape2[key])) {
            const result = {};
            for (let name in dest[key]) {
              result[name] = mix({}, dest[key][name], shape2[key]);
            }
            for (let name in src[key]) {
              result[name] = mix(result[name] || {}, src[key][name], shape2[key]);
            }
            dest[key] = result;
          } else if (Array.isArray(shape2[key])) {
            const res = {};
            const innerShape = shape2[key].reduce(function(s2, k2) {
              s2[k2] = true;
              return s2;
            }, {});
            for (const [name, value] of Object.entries(dest[key] || {})) {
              res[name] = {};
              if (value) {
                mix(res[name], value, innerShape);
              }
            }
            for (const name in src[key]) {
              if (hasOwnProperty2.call(src[key], name)) {
                if (!res[name]) {
                  res[name] = {};
                }
                if (src[key] && src[key][name]) {
                  mix(res[name], src[key][name], innerShape);
                }
              }
            }
            dest[key] = res;
          }
        }
      }
      return dest;
    }
    module.exports = (dest, src) => mix(dest, src, shape);
  }
});

// node_modules/css-tree/lib/syntax/create.js
var require_create5 = __commonJS({
  "node_modules/css-tree/lib/syntax/create.js"(exports) {
    var List = require_List();
    var SyntaxError2 = require_SyntaxError();
    var TokenStream = require_TokenStream();
    var Lexer = require_Lexer();
    var definitionSyntax = require_definition_syntax();
    var tokenize = require_tokenizer();
    var createParser = require_create();
    var createGenerator = require_create2();
    var createConvertor = require_create3();
    var createWalker = require_create4();
    var clone = require_clone();
    var names = require_names();
    var mix = require_mix();
    function createSyntax(config) {
      var parse4 = createParser(config);
      var walk = createWalker(config);
      var generate = createGenerator(config);
      var convert = createConvertor(walk);
      var syntax = {
        List,
        SyntaxError: SyntaxError2,
        TokenStream,
        Lexer,
        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,
        definitionSyntax,
        lexer: null,
        createLexer: function(config2) {
          return new Lexer(config2, syntax, syntax.lexer.structure);
        },
        tokenize,
        parse: parse4,
        walk,
        generate,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,
        clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,
        createSyntax: function(config2) {
          return createSyntax(mix({}, config2));
        },
        fork: function(extension) {
          var base = mix({}, config);
          return createSyntax(
            typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
          );
        }
      };
      syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
      }, syntax);
      return syntax;
    }
    exports.create = function(config) {
      return createSyntax(mix({}, config));
    };
  }
});

// node_modules/mdn-data/css/at-rules.json
var require_at_rules = __commonJS({
  "node_modules/mdn-data/css/at-rules.json"(exports, module) {
    module.exports = {
      "@charset": {
        syntax: '@charset "<charset>";',
        groups: [
          "CSS Charsets"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
      },
      "@counter-style": {
        syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
        interfaces: [
          "CSSCounterStyleRule"
        ],
        groups: [
          "CSS Counter Styles"
        ],
        descriptors: {
          "additive-symbols": {
            syntax: "[ <integer> && <symbol> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          fallback: {
            syntax: "<counter-style-name>",
            media: "all",
            initial: "decimal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          negative: {
            syntax: "<symbol> <symbol>?",
            media: "all",
            initial: '"-" hyphen-minus',
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          pad: {
            syntax: "<integer> && <symbol>",
            media: "all",
            initial: '0 ""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          prefix: {
            syntax: "<symbol>",
            media: "all",
            initial: '""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          range: {
            syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "speak-as": {
            syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          suffix: {
            syntax: "<symbol>",
            media: "all",
            initial: '". "',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          symbols: {
            syntax: "<symbol>+",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          system: {
            syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
            media: "all",
            initial: "symbolic",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
      },
      "@document": {
        syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
      },
      "@font-face": {
        syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
        interfaces: [
          "CSSFontFaceRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "font-display": {
            syntax: "[ auto | block | swap | fallback | optional ]",
            media: "visual",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "font-family": {
            syntax: "<family-name>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-feature-settings": {
            syntax: "normal | <feature-tag-value>#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-variation-settings": {
            syntax: "normal | [ <string> <number> ]#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-stretch": {
            syntax: "<font-stretch-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-style": {
            syntax: "normal | italic | oblique <angle>{0,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-weight": {
            syntax: "<font-weight-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-variant": {
            syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          src: {
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "unicode-range": {
            syntax: "<unicode-range>#",
            media: "all",
            initial: "U+0-10FFFF",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
      },
      "@font-feature-values": {
        syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
        interfaces: [
          "CSSFontFeatureValuesRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
      },
      "@import": {
        syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
        groups: [
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
      },
      "@keyframes": {
        syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
        interfaces: [
          "CSSKeyframeRule",
          "CSSKeyframesRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
      },
      "@media": {
        syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSMediaRule",
          "CSSCustomMediaRule"
        ],
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
      },
      "@namespace": {
        syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
        groups: [
          "CSS Namespaces"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
      },
      "@page": {
        syntax: "@page <page-selector-list> {\n  <page-body>\n}",
        interfaces: [
          "CSSPageRule"
        ],
        groups: [
          "CSS Pages"
        ],
        descriptors: {
          bleed: {
            syntax: "auto | <length>",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          marks: {
            syntax: "none | [ crop || cross ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "none",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          size: {
            syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecifiedRelativeToAbsoluteLengths",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
      },
      "@property": {
        syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
        interfaces: [
          "CSS",
          "CSSPropertyRule"
        ],
        groups: [
          "CSS Houdini"
        ],
        descriptors: {
          syntax: {
            syntax: "<string>",
            media: "all",
            percentages: "no",
            initial: "n/a (required)",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          inherits: {
            syntax: "true | false",
            media: "all",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "initial-value": {
            syntax: "<string>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          }
        },
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
      },
      "@supports": {
        syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSSupportsRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
      },
      "@viewport": {
        syntax: "@viewport {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSViewportRule"
        ],
        groups: [
          "CSS Device Adaptation"
        ],
        descriptors: {
          height: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-height",
              "max-height"
            ],
            percentages: [
              "min-height",
              "max-height"
            ],
            computed: [
              "min-height",
              "max-height"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          "max-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          orientation: {
            syntax: "auto | portrait | landscape",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "user-zoom": {
            syntax: "zoom | fixed",
            media: [
              "visual",
              "continuous"
            ],
            initial: "zoom",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "viewport-fit": {
            syntax: "auto | contain | cover",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          width: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-width",
              "max-width"
            ],
            percentages: [
              "min-width",
              "max-width"
            ],
            computed: [
              "min-width",
              "max-width"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          zoom: {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
      }
    };
  }
});

// node_modules/mdn-data/css/properties.json
var require_properties = __commonJS({
  "node_modules/mdn-data/css/properties.json"(exports, module) {
    module.exports = {
      "--*": {
        syntax: "<declaration-value>",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Variables"
        ],
        initial: "seeProse",
        appliesto: "allElements",
        computed: "asSpecifiedWithVarsSubstituted",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
      },
      "-ms-accelerator": {
        syntax: "false | true",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "false",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
      },
      "-ms-block-progression": {
        syntax: "tb | rl | bt | lr",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "tb",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
      },
      "-ms-content-zoom-chaining": {
        syntax: "none | chained",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
      },
      "-ms-content-zooming": {
        syntax: "none | zoom",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "zoomForTheTopLevelNoneForTheRest",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
      },
      "-ms-content-zoom-limit": {
        syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
      },
      "-ms-content-zoom-limit-max": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "maxZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "400%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
      },
      "-ms-content-zoom-limit-min": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "minZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "100%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
      },
      "-ms-content-zoom-snap": {
        syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
      },
      "-ms-content-zoom-snap-points": {
        syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0%, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
      },
      "-ms-content-zoom-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
      },
      "-ms-filter": {
        syntax: "<string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: '""',
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
      },
      "-ms-flow-from": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
      },
      "-ms-flow-into": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "iframeElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
      },
      "-ms-grid-columns": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
      },
      "-ms-grid-rows": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
      },
      "-ms-high-contrast-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
      },
      "-ms-hyphenate-limit-chars": {
        syntax: "auto | <integer>{1,3}",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
      },
      "-ms-hyphenate-limit-lines": {
        syntax: "no-limit | <integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "no-limit",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
      },
      "-ms-hyphenate-limit-zone": {
        syntax: "<percentage> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToLineBoxWidth",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
      },
      "-ms-ime-align": {
        syntax: "auto | after",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
      },
      "-ms-overflow-style": {
        syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
      },
      "-ms-scrollbar-3dlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
      },
      "-ms-scrollbar-arrow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ButtonText",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
      },
      "-ms-scrollbar-base-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
      },
      "-ms-scrollbar-darkshadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
      },
      "-ms-scrollbar-face-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDFace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
      },
      "-ms-scrollbar-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDHighlight",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
      },
      "-ms-scrollbar-shadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
      },
      "-ms-scrollbar-track-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "Scrollbar",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
      },
      "-ms-scroll-chaining": {
        syntax: "chained | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "chained",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
      },
      "-ms-scroll-limit": {
        syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
      },
      "-ms-scroll-limit-x-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
      },
      "-ms-scroll-limit-x-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
      },
      "-ms-scroll-limit-y-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
      },
      "-ms-scroll-limit-y-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
      },
      "-ms-scroll-rails": {
        syntax: "none | railed",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "railed",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
      },
      "-ms-scroll-snap-points-x": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
      },
      "-ms-scroll-snap-points-y": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
      },
      "-ms-scroll-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
      },
      "-ms-scroll-snap-x": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
      },
      "-ms-scroll-snap-y": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
      },
      "-ms-scroll-translation": {
        syntax: "none | vertical-to-horizontal",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
      },
      "-ms-text-autospace": {
        syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
      },
      "-ms-touch-select": {
        syntax: "grippers | none",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "grippers",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
      },
      "-ms-user-select": {
        syntax: "none | element | text",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "text",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
      },
      "-ms-wrap-flow": {
        syntax: "auto | both | start | end | maximum | clear",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
      },
      "-ms-wrap-margin": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "exclusionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
      },
      "-ms-wrap-through": {
        syntax: "wrap | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "wrap",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
      },
      "-moz-appearance": {
        syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-moz-binding": {
        syntax: "<url> | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
      },
      "-moz-border-bottom-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
      },
      "-moz-border-left-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
      },
      "-moz-border-right-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
      },
      "-moz-border-top-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
      },
      "-moz-context-properties": {
        syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsThatCanReferenceImages",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
      },
      "-moz-float-edge": {
        syntax: "border-box | content-box | margin-box | padding-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "content-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
      },
      "-moz-force-broken-image-icon": {
        syntax: "<integer [0,1]>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "images",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
      },
      "-moz-image-region": {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "xulImageElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
      },
      "-moz-orient": {
        syntax: "inline | block | horizontal | vertical",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "inline",
        appliesto: "anyElementEffectOnProgressAndMeter",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
      },
      "-moz-outline-radius": {
        syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        percentages: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        groups: [
          "Mozilla Extensions"
        ],
        initial: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        appliesto: "allElements",
        computed: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
      },
      "-moz-outline-radius-bottomleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
      },
      "-moz-outline-radius-bottomright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
      },
      "-moz-outline-radius-topleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
      },
      "-moz-outline-radius-topright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
      },
      "-moz-stack-sizing": {
        syntax: "ignore | stretch-to-fit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "stretch-to-fit",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
      },
      "-moz-text-blink": {
        syntax: "none | blink",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
      },
      "-moz-user-focus": {
        syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
      },
      "-moz-user-input": {
        syntax: "auto | none | enabled | disabled",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
      },
      "-moz-user-modify": {
        syntax: "read-only | read-write | write-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
      },
      "-moz-window-dragging": {
        syntax: "drag | no-drag",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "drag",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
      },
      "-moz-window-shadow": {
        syntax: "default | menu | tooltip | sheet | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "default",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
      },
      "-webkit-appearance": {
        syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-webkit-border-before": {
        syntax: "<'border-width'> || <'border-style'> || <'color'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: [
          "-webkit-border-before-width"
        ],
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "color"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
      },
      "-webkit-border-before-color": {
        syntax: "<'color'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "WebKit Extensions"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-box-reflect": {
        syntax: "[ above | below | right | left ]? <length>? <image>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
      },
      "-webkit-line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "WebKit Extensions",
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
      },
      "-webkit-mask": {
        syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "-webkit-mask-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
      },
      "-webkit-mask-clip": {
        syntax: "[ <box> | border | padding | content | text ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "border",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "-webkit-mask-composite": {
        syntax: "<composite-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "source-over",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
      },
      "-webkit-mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteURIOrNone",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "-webkit-mask-origin": {
        syntax: "[ <box> | border | padding | content ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "padding",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "-webkit-mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "-webkit-mask-position-x": {
        syntax: "[ <length-percentage> | left | center | right ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
      },
      "-webkit-mask-position-y": {
        syntax: "[ <length-percentage> | top | center | bottom ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
      },
      "-webkit-mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "-webkit-mask-repeat-x": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
      },
      "-webkit-mask-repeat-y": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
      },
      "-webkit-mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "-webkit-overflow-scrolling": {
        syntax: "auto | touch",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
      },
      "-webkit-tap-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "black",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
      },
      "-webkit-text-fill-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
      },
      "-webkit-text-stroke": {
        syntax: "<length> || <color>",
        media: "visual",
        inherited: true,
        animationType: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        order: "canonicalOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
      },
      "-webkit-text-stroke-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
      },
      "-webkit-text-stroke-width": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
      },
      "-webkit-touch-callout": {
        syntax: "default | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "default",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
      },
      "-webkit-user-modify": {
        syntax: "read-only | read-write | read-write-plaintext-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "align-content": {
        syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
      },
      "align-items": {
        syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
      },
      "align-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
        computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
      },
      "align-tracks": {
        syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
      },
      all: {
        syntax: "initial | inherit | unset | revert",
        media: "noPracticalMedia",
        inherited: false,
        animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "noPracticalInitialValue",
        appliesto: "allElements",
        computed: "asSpecifiedAppliesToEachProperty",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
      },
      animation: {
        syntax: "<single-animation>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-direction",
          "animation-iteration-count",
          "animation-fill-mode",
          "animation-play-state"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
      },
      "animation-delay": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
      },
      "animation-direction": {
        syntax: "<single-animation-direction>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
      },
      "animation-duration": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
      },
      "animation-fill-mode": {
        syntax: "<single-animation-fill-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
      },
      "animation-iteration-count": {
        syntax: "<single-animation-iteration-count>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "1",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
      },
      "animation-name": {
        syntax: "[ none | <keyframes-name> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
      },
      "animation-play-state": {
        syntax: "<single-animation-play-state>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "running",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
      },
      "animation-timing-function": {
        syntax: "<timing-function>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
      },
      appearance: {
        syntax: "none | auto | textfield | menulist-button | <compat-auto>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "aspect-ratio": {
        syntax: "auto | <ratio>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
      },
      azimuth: {
        syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
        media: "aural",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Speech"
        ],
        initial: "center",
        appliesto: "allElements",
        computed: "normalizedAngle",
        order: "orderOfAppearance",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
      },
      "backdrop-filter": {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
      },
      "backface-visibility": {
        syntax: "visible | hidden",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "visible",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
      },
      background: {
        syntax: "[ <bg-layer> , ]* <final-bg-layer>",
        media: "visual",
        inherited: false,
        animationType: [
          "background-color",
          "background-image",
          "background-clip",
          "background-position",
          "background-size",
          "background-repeat",
          "background-attachment"
        ],
        percentages: [
          "background-position",
          "background-size"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        appliesto: "allElements",
        computed: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
      },
      "background-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
      },
      "background-blend-mode": {
        syntax: "<blend-mode>#",
        media: "none",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
      },
      "background-clip": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "border-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
      },
      "background-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "transparent",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
      },
      "background-image": {
        syntax: "<bg-image>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
      },
      "background-origin": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
      },
      "background-position": {
        syntax: "<bg-position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "listEachItemTwoKeywordsOriginOffsets",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
      },
      "background-position-x": {
        syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "left",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
      },
      "background-position-y": {
        syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "top",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
      },
      "background-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "listEachItemHasTwoKeywordsOnePerDimension",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
      },
      "background-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
      },
      "block-overflow": {
        syntax: "clip | ellipsis | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "clip",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "block-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
      },
      border: {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-color",
          "border-style",
          "border-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-width",
          "border-style",
          "border-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
      },
      "border-block": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
      },
      "border-block-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
      },
      "border-block-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
      },
      "border-block-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
      },
      "border-block-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
      },
      "border-block-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
      },
      "border-block-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
      },
      "border-block-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
      },
      "border-block-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-block-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
      },
      "border-block-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
      },
      "border-block-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
      },
      "border-block-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
      },
      "border-bottom": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
      },
      "border-bottom-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
      },
      "border-bottom-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
      },
      "border-bottom-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
      },
      "border-bottom-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
      },
      "border-bottom-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
      },
      "border-collapse": {
        syntax: "collapse | separate",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "separate",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
      },
      "border-color": {
        syntax: "<color>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
      },
      "border-end-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
      },
      "border-end-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
      },
      "border-image": {
        syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "border-image-slice",
          "border-image-width"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ],
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
      },
      "border-image-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
      },
      "border-image-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "stretch",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
      },
      "border-image-slice": {
        syntax: "<number-percentage>{1,4} && fill?",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfBorderImage",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "100%",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
        order: "percentagesOrLengthsFollowedByFill",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
      },
      "border-image-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
      },
      "border-image-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToWidthOrHeightOfBorderImageArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "1",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
      },
      "border-inline": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
      },
      "border-inline-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-end-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
      },
      "border-inline-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
      },
      "border-inline-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
      },
      "border-inline-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
      },
      "border-inline-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
      },
      "border-inline-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
      },
      "border-inline-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
      },
      "border-inline-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
      },
      "border-inline-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
      },
      "border-inline-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
      },
      "border-inline-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
      },
      "border-left": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-left-color",
          "border-left-style",
          "border-left-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
      },
      "border-left-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
      },
      "border-left-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
      },
      "border-left-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
      },
      "border-radius": {
        syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: [
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-top-left-radius",
          "border-top-right-radius"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
      },
      "border-right": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-right-color",
          "border-right-style",
          "border-right-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
      },
      "border-right-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
      },
      "border-right-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
      },
      "border-right-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
      },
      "border-spacing": {
        syntax: "<length> <length>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "0",
        appliesto: "tableElements",
        computed: "twoAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
      },
      "border-start-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
      },
      "border-start-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
      },
      "border-style": {
        syntax: "<line-style>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-style",
          "border-left-style",
          "border-right-style",
          "border-top-style"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
      },
      "border-top": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-color",
          "border-top-style",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
      },
      "border-top-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
      },
      "border-top-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
      },
      "border-top-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
      },
      "border-top-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
      },
      "border-top-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
      },
      "border-width": {
        syntax: "<line-width>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
      },
      bottom: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
      },
      "box-align": {
        syntax: "start | center | end | baseline | stretch",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "stretch",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
      },
      "box-decoration-break": {
        syntax: "slice | clone",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "slice",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
      },
      "box-direction": {
        syntax: "normal | reverse | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "normal",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
      },
      "box-flex": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
      },
      "box-flex-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "inFlowChildrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
      },
      "box-lines": {
        syntax: "single | multiple",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "single",
        appliesto: "boxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
      },
      "box-ordinal-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "childrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
      },
      "box-orient": {
        syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "inlineAxisHorizontalInXUL",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
      },
      "box-pack": {
        syntax: "start | center | end | justify",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "start",
        appliesto: "elementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
      },
      "box-shadow": {
        syntax: "none | <shadow>#",
        media: "visual",
        inherited: false,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteLengthsSpecifiedColorAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
      },
      "box-sizing": {
        syntax: "content-box | border-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "content-box",
        appliesto: "allElementsAcceptingWidthOrHeight",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
      },
      "break-after": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
      },
      "break-before": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
      },
      "break-inside": {
        syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
      },
      "caption-side": {
        syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "top",
        appliesto: "tableCaptionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
      },
      "caret-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
      },
      clear: {
        syntax: "none | left | right | both | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
      },
      clip: {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: false,
        animationType: "rectangle",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "autoOrRectangle",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
      },
      "clip-path": {
        syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
      },
      color: {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "variesFromBrowserToBrowser",
        appliesto: "allElements",
        computed: "translucentValuesRGBAOtherwiseRGB",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
      },
      "color-adjust": {
        syntax: "economy | exact",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "economy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
      },
      "column-count": {
        syntax: "<integer> | auto",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
      },
      "column-fill": {
        syntax: "auto | balance | balance-all",
        media: "visualInContinuousMediaNoEffectInOverflowColumns",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "balance",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
      },
      "column-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "column-rule": {
        syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-rule-width",
          "column-rule-style",
          "column-rule-color"
        ],
        appliesto: "multicolElements",
        computed: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
      },
      "column-rule-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "currentcolor",
        appliesto: "multicolElements",
        computed: "computedColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
      },
      "column-rule-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
      },
      "column-rule-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "medium",
        appliesto: "multicolElements",
        computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
      },
      "column-span": {
        syntax: "none | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "inFlowBlockLevelElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
      },
      "column-width": {
        syntax: "<length> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "absoluteLengthZeroOrLarger",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
      },
      columns: {
        syntax: "<'column-width'> || <'column-count'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-width",
          "column-count"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-width",
          "column-count"
        ],
        appliesto: "blockContainersExceptTableWrappers",
        computed: [
          "column-width",
          "column-count"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
      },
      contain: {
        syntax: "none | strict | content | [ size || layout || style || paint ]",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
      },
      content: {
        syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "normal",
        appliesto: "beforeAndAfterPseudos",
        computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
      },
      "counter-increment": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
      },
      "counter-reset": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
      },
      "counter-set": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
      },
      cursor: {
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
      },
      direction: {
        syntax: "ltr | rtl",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "ltr",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
      },
      display: {
        syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Display"
        ],
        initial: "inline",
        appliesto: "allElements",
        computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
      },
      "empty-cells": {
        syntax: "show | hide",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "show",
        appliesto: "tableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
      },
      filter: {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
      },
      flex: {
        syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        appliesto: "flexItemsAndInFlowPseudos",
        computed: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
      },
      "flex-basis": {
        syntax: "content | <'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToFlexContainersInnerMainSize",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "auto",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
      },
      "flex-direction": {
        syntax: "row | row-reverse | column | column-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "row",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
      },
      "flex-flow": {
        syntax: "<'flex-direction'> || <'flex-wrap'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-direction",
          "flex-wrap"
        ],
        appliesto: "flexContainers",
        computed: [
          "flex-direction",
          "flex-wrap"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
      },
      "flex-grow": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
      },
      "flex-shrink": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "1",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
      },
      "flex-wrap": {
        syntax: "nowrap | wrap | wrap-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "nowrap",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
      },
      float: {
        syntax: "left | right | none | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsNoEffectIfDisplayNone",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
      },
      font: {
        syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
        media: "visual",
        inherited: true,
        animationType: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        percentages: [
          "font-size",
          "line-height"
        ],
        groups: [
          "CSS Fonts"
        ],
        initial: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        appliesto: "allElements",
        computed: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
      },
      "font-family": {
        syntax: "[ <family-name> | <generic-family> ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
      },
      "font-kerning": {
        syntax: "auto | normal | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
      },
      "font-language-override": {
        syntax: "normal | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
      },
      "font-optical-sizing": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "visual",
        inherited: true,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
      },
      "font-size": {
        syntax: "<absolute-size> | <relative-size> | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToParentElementsFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
      },
      "font-size-adjust": {
        syntax: "none | <number>",
        media: "visual",
        inherited: true,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
      },
      "font-smooth": {
        syntax: "auto | never | always | <absolute-size> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>",
        media: "visual",
        inherited: true,
        animationType: "fontStretch",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
      },
      "font-synthesis": {
        syntax: "none | [ weight || style ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "weight style",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
      },
      "font-variant": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
      },
      "font-variant-alternates": {
        syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
      },
      "font-variant-caps": {
        syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
      },
      "font-variant-east-asian": {
        syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
      },
      "font-variant-ligatures": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
      },
      "font-variant-numeric": {
        syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
      },
      "font-variant-position": {
        syntax: "normal | sub | super",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
      },
      "font-weight": {
        syntax: "<font-weight-absolute> | bolder | lighter",
        media: "visual",
        inherited: true,
        animationType: "fontWeight",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
      },
      gap: {
        syntax: "<'row-gap'> <'column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "row-gap",
          "column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "row-gap",
          "column-gap"
        ],
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: [
          "row-gap",
          "column-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      grid: {
        syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-auto-rows",
          "grid-auto-columns"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
      },
      "grid-area": {
        syntax: "<grid-line> [ / <grid-line> ]{0,3}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
      },
      "grid-auto-columns": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
      },
      "grid-auto-flow": {
        syntax: "[ row | column ] || dense",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "row",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
      },
      "grid-auto-rows": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
      },
      "grid-column": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-column-start",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-column-start",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
      },
      "grid-column-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
      },
      "grid-column-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "grid-column-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
      },
      "grid-gap": {
        syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      "grid-row": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-row-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-row-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
      },
      "grid-row-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
      },
      "grid-row-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "grid-row-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
      },
      "grid-template": {
        syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-columns",
          "grid-template-rows"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
      },
      "grid-template-areas": {
        syntax: "none | <string>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
      },
      "grid-template-columns": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
      },
      "grid-template-rows": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
      },
      "hanging-punctuation": {
        syntax: "none | [ first || [ force-end | allow-end ] || last ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
      },
      height: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAutoOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
      },
      hyphens: {
        syntax: "none | manual | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "manual",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
      },
      "image-orientation": {
        syntax: "from-image | <angle> | [ <angle>? flip ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "from-image",
        appliesto: "allElements",
        computed: "angleRoundedToNextQuarter",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
      },
      "image-rendering": {
        syntax: "auto | crisp-edges | pixelated",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
      },
      "image-resolution": {
        syntax: "[ from-image || <resolution> ] && snap?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "1dppx",
        appliesto: "allElements",
        computed: "asSpecifiedWithExceptionOfResolution",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ime-mode": {
        syntax: "auto | normal | active | inactive | disabled",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "textFields",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
      },
      "initial-letter": {
        syntax: "normal | [ <number> <integer>? ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "normal",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
      },
      "initial-letter-align": {
        syntax: "[ auto | alphabetic | hanging | ideographic ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "auto",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
      },
      "inline-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
      },
      inset: {
        syntax: "<'top'>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
      },
      "inset-block": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
      },
      "inset-block-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
      },
      "inset-block-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
      },
      "inset-inline": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
      },
      "inset-inline-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
      },
      "inset-inline-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
      },
      isolation: {
        syntax: "auto | isolate",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
      },
      "justify-content": {
        syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
      },
      "justify-items": {
        syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "legacy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
      },
      "justify-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
      },
      "justify-tracks": {
        syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
      },
      left: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
      },
      "letter-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumValueOfAbsoluteLengthOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
      },
      "line-break": {
        syntax: "auto | loose | normal | strict | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
      },
      "line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "line-height": {
        syntax: "normal | <number> | <length> | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "numberOrLength",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLengthOrAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
      },
      "line-height-step": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "absoluteLength",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
      },
      "list-style": {
        syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: [
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ],
        appliesto: "listItems",
        computed: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
      },
      "list-style-image": {
        syntax: "<url> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "none",
        appliesto: "listItems",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
      },
      "list-style-position": {
        syntax: "inside | outside",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "outside",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
      },
      "list-style-type": {
        syntax: "<counter-style> | <string> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "disc",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
      },
      margin: {
        syntax: "[ <length> | <percentage> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
      },
      "margin-block": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
      },
      "margin-block-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
      },
      "margin-block-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
      },
      "margin-bottom": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
      },
      "margin-inline": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
      },
      "margin-inline-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
      },
      "margin-inline-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
      },
      "margin-left": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
      },
      "margin-right": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
      },
      "margin-top": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
      },
      "margin-trim": {
        syntax: "none | in-flow | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "blockContainersAndMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
      },
      mask: {
        syntax: "<mask-layer>#",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        percentages: [
          "mask-position"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "mask-border": {
        syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        percentages: [
          "mask-border-slice",
          "mask-border-width"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
      },
      "mask-border-mode": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "alpha",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
      },
      "mask-border-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
      },
      "mask-border-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "stretch",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
      },
      "mask-border-slice": {
        syntax: "<number-percentage>{1,4} fill?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfMaskBorderImage",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
      },
      "mask-border-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
      },
      "mask-border-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToMaskBorderImageArea",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
      },
      "mask-clip": {
        syntax: "[ <geometry-box> | no-clip ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "mask-composite": {
        syntax: "<compositing-operator>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "add",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
      },
      "mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "mask-mode": {
        syntax: "<masking-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "match-source",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
      },
      "mask-origin": {
        syntax: "<geometry-box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfMaskPaintingArea",
        groups: [
          "CSS Masking"
        ],
        initial: "center",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoKeywordsForOriginAndOffsets",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "no-repeat",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoDimensionKeywords",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "mask-type": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "luminance",
        appliesto: "maskElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
      },
      "masonry-auto-flow": {
        syntax: "[ pack | next ] || [ definite-first | ordered ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "pack",
        appliesto: "gridContainersWithMasonryLayout",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
      },
      "math-style": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
      },
      "max-block-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
      },
      "max-height": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
      },
      "max-inline-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
      },
      "max-lines": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "max-width": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
      },
      "min-block-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
      },
      "min-height": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
      },
      "min-inline-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
      },
      "min-width": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
      },
      "mix-blend-mode": {
        syntax: "<blend-mode>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
      },
      "object-fit": {
        syntax: "fill | contain | cover | none | scale-down",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "fill",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
      },
      "object-position": {
        syntax: "<position>",
        media: "visual",
        inherited: true,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToWidthAndHeightOfElement",
        groups: [
          "CSS Images"
        ],
        initial: "50% 50%",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
      },
      offset: {
        syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        percentages: [
          "offset-position",
          "offset-distance",
          "offset-anchor"
        ],
        groups: [
          "CSS Motion Path"
        ],
        initial: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        appliesto: "transformableElements",
        computed: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
      },
      "offset-anchor": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "relativeToWidthAndHeight",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard"
      },
      "offset-distance": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToTotalPathLength",
        groups: [
          "CSS Motion Path"
        ],
        initial: "0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
      },
      "offset-path": {
        syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
      },
      "offset-position": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "referToSizeOfContainingBlock",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "experimental"
      },
      "offset-rotate": {
        syntax: "[ auto | reverse ] || <angle>",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
      },
      opacity: {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "1.0",
        appliesto: "allElements",
        computed: "specifiedValueClipped0To1",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
      },
      order: {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
      },
      orphans: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
      },
      outline: {
        syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "outline-color",
          "outline-style",
          "outline-width"
        ],
        appliesto: "allElements",
        computed: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
      },
      "outline-color": {
        syntax: "<color> | invert",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "invertOrCurrentColor",
        appliesto: "allElements",
        computed: "invertForTranslucentColorRGBAOtherwiseRGB",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
      },
      "outline-offset": {
        syntax: "<length>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
      },
      "outline-style": {
        syntax: "auto | <'border-style'>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
      },
      "outline-width": {
        syntax: "<line-width>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLength0ForNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
      },
      overflow: {
        syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: [
          "overflow-x",
          "overflow-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
      },
      "overflow-anchor": {
        syntax: "auto | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Anchoring"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-block": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-clip-box": {
        syntax: "padding-box | content-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
      },
      "overflow-inline": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-wrap": {
        syntax: "normal | break-word | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "overflow-x": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
      },
      "overflow-y": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
      },
      "overscroll-behavior": {
        syntax: "[ contain | none | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
      },
      "overscroll-behavior-block": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
      },
      "overscroll-behavior-inline": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
      },
      "overscroll-behavior-x": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
      },
      "overscroll-behavior-y": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
      },
      padding: {
        syntax: "[ <length> | <percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
      },
      "padding-block": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
      },
      "padding-block-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
      },
      "padding-block-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
      },
      "padding-bottom": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
      },
      "padding-inline": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
      },
      "padding-inline-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
      },
      "padding-inline-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
      },
      "padding-left": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
      },
      "padding-right": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
      },
      "padding-top": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
      },
      "page-break-after": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
      },
      "page-break-before": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
      },
      "page-break-inside": {
        syntax: "auto | avoid",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
      },
      "paint-order": {
        syntax: "normal | [ fill || stroke || markers ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
      },
      perspective: {
        syntax: "none | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "absoluteLengthOrNone",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
      },
      "perspective-origin": {
        syntax: "<position>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50%",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
      },
      "place-content": {
        syntax: "<'align-content'> <'justify-content'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
      },
      "place-items": {
        syntax: "<'align-items'> <'justify-items'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-items",
          "justify-items"
        ],
        appliesto: "allElements",
        computed: [
          "align-items",
          "justify-items"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
      },
      "place-self": {
        syntax: "<'align-self'> <'justify-self'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-self",
          "justify-self"
        ],
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: [
          "align-self",
          "justify-self"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
      },
      "pointer-events": {
        syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
      },
      position: {
        syntax: "static | relative | absolute | sticky | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "static",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
      },
      quotes: {
        syntax: "none | auto | [ <string> <string> ]+",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
      },
      resize: {
        syntax: "none | both | horizontal | vertical | block | inline",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
      },
      right: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
      },
      rotate: {
        syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
      },
      "row-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "ruby-align": {
        syntax: "start | center | space-between | space-around",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "space-around",
        appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
      },
      "ruby-merge": {
        syntax: "separate | collapse | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "separate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ruby-position": {
        syntax: "over | under | inter-character",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "over",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
      },
      scale: {
        syntax: "none | <number>{1,3}",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
      },
      "scrollbar-color": {
        syntax: "auto | dark | light | <color>{2}",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
      },
      "scrollbar-gutter": {
        syntax: "auto | [ stable | always ] && both? && force?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
      },
      "scrollbar-width": {
        syntax: "auto | thin | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
      },
      "scroll-behavior": {
        syntax: "auto | smooth",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSSOM View"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
      },
      "scroll-margin": {
        syntax: "<length>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
      },
      "scroll-margin-block": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
      },
      "scroll-margin-block-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
      },
      "scroll-margin-block-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
      },
      "scroll-margin-bottom": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
      },
      "scroll-margin-inline": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
      },
      "scroll-margin-inline-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
      },
      "scroll-margin-inline-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
      },
      "scroll-margin-left": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
      },
      "scroll-margin-right": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
      },
      "scroll-margin-top": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
      },
      "scroll-padding": {
        syntax: "[ auto | <length-percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
      },
      "scroll-padding-block": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
      },
      "scroll-padding-block-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
      },
      "scroll-padding-block-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
      },
      "scroll-padding-bottom": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
      },
      "scroll-padding-inline": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
      },
      "scroll-padding-inline-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
      },
      "scroll-padding-inline-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
      },
      "scroll-padding-left": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
      },
      "scroll-padding-right": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
      },
      "scroll-padding-top": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
      },
      "scroll-snap-align": {
        syntax: "[ none | start | end | center ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
      },
      "scroll-snap-coordinate": {
        syntax: "none | <position>#",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "referToBorderBox",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
      },
      "scroll-snap-destination": {
        syntax: "<position>",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0px 0px",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
      },
      "scroll-snap-points-x": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
      },
      "scroll-snap-points-y": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
      },
      "scroll-snap-stop": {
        syntax: "normal | always",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
      },
      "scroll-snap-type": {
        syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
      },
      "scroll-snap-type-x": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
      },
      "scroll-snap-type-y": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
      },
      "shape-image-threshold": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "0.0",
        appliesto: "floats",
        computed: "specifiedValueNumberClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
      },
      "shape-margin": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Shapes"
        ],
        initial: "0",
        appliesto: "floats",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
      },
      "shape-outside": {
        syntax: "none | <shape-box> || <basic-shape> | <image>",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "none",
        appliesto: "floats",
        computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
      },
      "tab-size": {
        syntax: "<integer> | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "8",
        appliesto: "blockContainers",
        computed: "specifiedIntegerOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
      },
      "table-layout": {
        syntax: "auto | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "auto",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
      },
      "text-align": {
        syntax: "start | end | left | right | center | justify | match-parent",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "startOrNamelessValueIfLTRRightIfRTL",
        appliesto: "blockContainers",
        computed: "asSpecifiedExceptMatchParent",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
      },
      "text-align-last": {
        syntax: "auto | start | end | left | right | center | justify",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
      },
      "text-combine-upright": {
        syntax: "none | all | [ digits <integer>? ]",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "none",
        appliesto: "nonReplacedInlineElements",
        computed: "keywordPlusIntegerIfDigits",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
      },
      "text-decoration": {
        syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line",
          "text-decoration-thickness"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line"
        ],
        appliesto: "allElements",
        computed: [
          "text-decoration-line",
          "text-decoration-style",
          "text-decoration-color",
          "text-decoration-thickness"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
      },
      "text-decoration-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
      },
      "text-decoration-line": {
        syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
      },
      "text-decoration-skip": {
        syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "objects",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
      },
      "text-decoration-skip-ink": {
        syntax: "auto | all | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
      },
      "text-decoration-style": {
        syntax: "solid | double | dotted | dashed | wavy",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "solid",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
      },
      "text-decoration-thickness": {
        syntax: "auto | from-font | <length> | <percentage> ",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
      },
      "text-emphasis": {
        syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-emphasis-color",
          "text-emphasis-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        appliesto: "allElements",
        computed: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
      },
      "text-emphasis-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
      },
      "text-emphasis-position": {
        syntax: "[ over | under ] && [ right | left ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "over right",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
      },
      "text-emphasis-style": {
        syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
      },
      "text-indent": {
        syntax: "<length-percentage> && hanging? && each-line?",
        media: "visual",
        inherited: true,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Text"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "percentageOrAbsoluteLengthPlusKeywords",
        order: "lengthOrPercentageBeforeKeywords",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
      },
      "text-justify": {
        syntax: "auto | inter-character | inter-word | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
      },
      "text-orientation": {
        syntax: "mixed | upright | sideways",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "mixed",
        appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
      },
      "text-overflow": {
        syntax: "[ clip | ellipsis | <string> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "clip",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
      },
      "text-rendering": {
        syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "auto",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
      },
      "text-shadow": {
        syntax: "none | <shadow-t>#",
        media: "visual",
        inherited: true,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "colorPlusThreeAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
      },
      "text-size-adjust": {
        syntax: "none | auto | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToSizeOfFont",
        groups: [
          "CSS Text"
        ],
        initial: "autoForSmartphoneBrowsersSupportingInflation",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
      },
      "text-transform": {
        syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
      },
      "text-underline-offset": {
        syntax: "auto | <length> | <percentage> ",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
      },
      "text-underline-position": {
        syntax: "auto | from-font | [ under || [ left | right ] ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
      },
      top: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
      },
      "touch-action": {
        syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
      },
      transform: {
        syntax: "none | <transform-list>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
      },
      "transform-box": {
        syntax: "content-box | border-box | fill-box | stroke-box | view-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "view-box",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
      },
      "transform-origin": {
        syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50% 0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
      },
      "transform-style": {
        syntax: "flat | preserve-3d",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "flat",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
      },
      transition: {
        syntax: "<single-transition>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
      },
      "transition-delay": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
      },
      "transition-duration": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
      },
      "transition-property": {
        syntax: "none | <single-transition-property>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "all",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
      },
      "transition-timing-function": {
        syntax: "<timing-function>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
      },
      translate: {
        syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
      },
      "unicode-bidi": {
        syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "normal",
        appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
      },
      "user-select": {
        syntax: "auto | text | none | contain | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
      },
      "vertical-align": {
        syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToLineHeight",
        groups: [
          "CSS Table"
        ],
        initial: "baseline",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "absoluteLengthOrKeyword",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
      },
      visibility: {
        syntax: "visible | hidden | collapse",
        media: "visual",
        inherited: true,
        animationType: "visibility",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "visible",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
      },
      "white-space": {
        syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
      },
      widows: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
      },
      width: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAutoOrAbsoluteLength",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
      },
      "will-change": {
        syntax: "auto | <animateable-feature>#",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Will Change"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
      },
      "word-break": {
        syntax: "normal | break-all | keep-all | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
      },
      "word-spacing": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToWidthOfAffectedGlyph",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
      },
      "word-wrap": {
        syntax: "normal | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "writing-mode": {
        syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "horizontal-tb",
        appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
      },
      "z-index": {
        syntax: "auto | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
      },
      zoom: {
        syntax: "normal | reset | <number> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
      }
    };
  }
});

// node_modules/mdn-data/css/syntaxes.json
var require_syntaxes = __commonJS({
  "node_modules/mdn-data/css/syntaxes.json"(exports, module) {
    module.exports = {
      "absolute-size": {
        syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
      },
      "alpha-value": {
        syntax: "<number> | <percentage>"
      },
      "angle-percentage": {
        syntax: "<angle> | <percentage>"
      },
      "angular-color-hint": {
        syntax: "<angle-percentage>"
      },
      "angular-color-stop": {
        syntax: "<color> && <color-stop-angle>?"
      },
      "angular-color-stop-list": {
        syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
      },
      "animateable-feature": {
        syntax: "scroll-position | contents | <custom-ident>"
      },
      attachment: {
        syntax: "scroll | fixed | local"
      },
      "attr()": {
        syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
      },
      "attr-matcher": {
        syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
      },
      "attr-modifier": {
        syntax: "i | s"
      },
      "attribute-selector": {
        syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
      },
      "auto-repeat": {
        syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "auto-track-list": {
        syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
      },
      "baseline-position": {
        syntax: "[ first | last ]? baseline"
      },
      "basic-shape": {
        syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
      },
      "bg-image": {
        syntax: "none | <image>"
      },
      "bg-layer": {
        syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "bg-position": {
        syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      "counter()": {
        syntax: "counter( <custom-ident>, <counter-style>? )"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fit-content()": {
        syntax: "fit-content( [ <length> | <percentage> ] )"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] <resolution>"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length> | <percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage>"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( <length> )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( <number> , <number>? )"
      },
      "scale3d()": {
        syntax: "scale3d( <number> , <number> , <number> )"
      },
      "scaleX()": {
        syntax: "scaleX( <number> )"
      },
      "scaleY()": {
        syntax: "scaleY( <number> )"
      },
      "scaleZ()": {
        syntax: "scaleZ( <number> )"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "single-animation": {
        syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/css-tree/data/patch.json
var require_patch = __commonJS({
  "node_modules/css-tree/data/patch.json"(exports, module) {
    module.exports = {
      atrules: {
        charset: {
          prelude: "<string>"
        },
        "font-face": {
          descriptors: {
            "unicode-range": {
              comment: "replaces <unicode-range>, an old production name",
              syntax: "<urange>#"
            }
          }
        }
      },
      properties: {
        "-moz-background-clip": {
          comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "padding | border"
        },
        "-moz-border-radius-bottomleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
          syntax: "<'border-bottom-left-radius'>"
        },
        "-moz-border-radius-bottomright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-border-radius-topleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
          syntax: "<'border-top-left-radius'>"
        },
        "-moz-border-radius-topright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-control-character-visibility": {
          comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
          syntax: "visible | hidden"
        },
        "-moz-osx-font-smoothing": {
          comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | grayscale"
        },
        "-moz-user-select": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "none | text | all | -moz-none"
        },
        "-ms-flex-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "start | end | center | baseline | stretch"
        },
        "-ms-flex-item-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "auto | start | end | center | baseline | stretch"
        },
        "-ms-flex-line-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
          syntax: "start | end | center | justify | distribute | stretch"
        },
        "-ms-flex-negative": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-shrink'>"
        },
        "-ms-flex-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
          syntax: "start | end | center | justify | distribute"
        },
        "-ms-flex-order": {
          comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
          syntax: "<integer>"
        },
        "-ms-flex-positive": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-grow'>"
        },
        "-ms-flex-preferred-size": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-basis'>"
        },
        "-ms-interpolation-mode": {
          comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
          syntax: "nearest-neighbor | bicubic"
        },
        "-ms-grid-column-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-grid-row-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-hyphenate-limit-last": {
          comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
          syntax: "none | always | column | page | spread"
        },
        "-webkit-appearance": {
          comment: "webkit specific keywords",
          references: [
            "http://css-infos.net/property/-webkit-appearance"
          ],
          syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
        },
        "-webkit-background-clip": {
          comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "[ <box> | border | padding | content | text ]#"
        },
        "-webkit-column-break-after": {
          comment: "added, http://help.dottoro.com/lcrthhhv.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-before": {
          comment: "added, http://help.dottoro.com/lcxquvkf.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-inside": {
          comment: "added, http://help.dottoro.com/lclhnthl.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-font-smoothing": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | none | antialiased | subpixel-antialiased"
        },
        "-webkit-mask-box-image": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
        },
        "-webkit-print-color-adjust": {
          comment: "missed",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
          ],
          syntax: "economy | exact"
        },
        "-webkit-text-security": {
          comment: "missed; http://help.dottoro.com/lcbkewgt.php",
          syntax: "none | circle | disc | square"
        },
        "-webkit-user-drag": {
          comment: "missed; http://help.dottoro.com/lcbixvwm.php",
          syntax: "none | element | auto"
        },
        "-webkit-user-select": {
          comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "auto | none | text | all"
        },
        "alignment-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
          ],
          syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
        },
        "baseline-shift": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
          ],
          syntax: "baseline | sub | super | <svg-length>"
        },
        behavior: {
          comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
          syntax: "<url>+"
        },
        "clip-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        cue: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'cue-before'> <'cue-after'>?"
        },
        "cue-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        "cue-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        cursor: {
          comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
          references: [
            "https://www.sitepoint.com/css3-cursor-styles/"
          ],
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
        },
        display: {
          comment: "extended with -ms-flexbox",
          syntax: "| <-non-standard-display>"
        },
        position: {
          comment: "extended with -webkit-sticky",
          syntax: "| -webkit-sticky"
        },
        "dominant-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
          ],
          syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
        },
        "image-rendering": {
          comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
            "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
          ],
          syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
        },
        fill: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<paint>"
        },
        "fill-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<number-zero-one>"
        },
        "fill-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        filter: {
          comment: "extend with IE legacy syntaxes",
          syntax: "| <-ms-filter-function-list>"
        },
        "glyph-orientation-horizontal": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
          ],
          syntax: "<angle>"
        },
        "glyph-orientation-vertical": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
          ],
          syntax: "<angle>"
        },
        kerning: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#KerningProperty"
          ],
          syntax: "auto | <svg-length>"
        },
        "letter-spacing": {
          comment: "fix syntax <length> -> <length-percentage>",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
          ],
          syntax: "normal | <length-percentage>"
        },
        marker: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-end": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-mid": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-start": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "max-width": {
          comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
          syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
        },
        width: {
          comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
          syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
        },
        "min-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
        },
        overflow: {
          comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "| <-non-standard-overflow>"
        },
        pause: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'pause-before'> <'pause-after'>?"
        },
        "pause-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "pause-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        rest: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'rest-before'> <'rest-after'>?"
        },
        "rest-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "rest-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "shape-rendering": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
          ],
          syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
        },
        src: {
          comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
        },
        speak: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | none | normal"
        },
        "speak-as": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
        },
        stroke: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<paint>"
        },
        "stroke-dasharray": {
          comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "none | [ <svg-length>+ ]#"
        },
        "stroke-dashoffset": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "stroke-linecap": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "butt | round | square"
        },
        "stroke-linejoin": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "miter | round | bevel"
        },
        "stroke-miterlimit": {
          comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-one-or-greater>"
        },
        "stroke-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-zero-one>"
        },
        "stroke-width": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "text-anchor": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
          ],
          syntax: "start | middle | end"
        },
        "unicode-bidi": {
          comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
          syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
        },
        "unicode-range": {
          comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
          syntax: "<urange>#"
        },
        "voice-balance": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<number> | left | center | right | leftwards | rightwards"
        },
        "voice-duration": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | <time>"
        },
        "voice-family": {
          comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
        },
        "voice-pitch": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-range": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-rate": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
        },
        "voice-stress": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | strong | moderate | none | reduced"
        },
        "voice-volume": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
        },
        "writing-mode": {
          comment: "extend with SVG keywords",
          syntax: "| <svg-writing-mode>"
        }
      },
      syntaxes: {
        "-legacy-gradient": {
          comment: "added collection of legacy gradient syntaxes",
          syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
        },
        "-legacy-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-repeating-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-linear-gradient-arguments": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
        },
        "-legacy-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-repeating-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-radial-gradient-arguments": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
        },
        "-legacy-radial-gradient-size": {
          comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
          syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
        },
        "-legacy-radial-gradient-shape": {
          comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
          syntax: "circle | ellipse"
        },
        "-non-standard-font": {
          comment: "non standard fonts",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
        },
        "-non-standard-color": {
          comment: "non standard colors",
          references: [
            "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
            "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
          ],
          syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
        },
        "-non-standard-image-rendering": {
          comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
          syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
        },
        "-non-standard-overflow": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
        },
        "-non-standard-width": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
        },
        "-webkit-gradient()": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
          syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
        },
        "-webkit-gradient-color-stop": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
        },
        "-webkit-gradient-point": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
        },
        "-webkit-gradient-radius": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "<length> | <percentage>"
        },
        "-webkit-gradient-type": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "linear | radial"
        },
        "-webkit-mask-box-repeat": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "repeat | stretch | round"
        },
        "-webkit-mask-clip-style": {
          comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
          syntax: "border | border-box | padding | padding-box | content | content-box | text"
        },
        "-ms-filter-function-list": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function>+"
        },
        "-ms-filter-function": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
        },
        "-ms-filter-function-progid": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
        },
        "-ms-filter-function-legacy": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<ident-token> | <function-token> <any-value>? )"
        },
        "-ms-filter": {
          syntax: "<string>"
        },
        age: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "child | young | old"
        },
        "attr-name": {
          syntax: "<wq-name>"
        },
        "attr-fallback": {
          syntax: "<any-value>"
        },
        "border-radius": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
          syntax: "<length-percentage>{1,2}"
        },
        bottom: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "content-list": {
          comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
          syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
        },
        "element()": {
          comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
          syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
        },
        "generic-voice": {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "[ <age>? <gender> <integer>? ]"
        },
        gender: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "male | female | neutral"
        },
        "generic-family": {
          comment: "added -apple-system",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "| -apple-system"
        },
        gradient: {
          comment: "added legacy syntaxes support",
          syntax: "| <-legacy-gradient>"
        },
        left: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "mask-image": {
          comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
          syntax: "<mask-reference>#"
        },
        "name-repeat": {
          comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
          syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
        },
        "named-color": {
          comment: "added non standard color names",
          syntax: "| <-non-standard-color>"
        },
        paint: {
          comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
          syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
        },
        "page-size": {
          comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
          syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
        },
        ratio: {
          comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
          syntax: "<integer> / <integer>"
        },
        right: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        shape: {
          comment: "missed spaces in function body and add backwards compatible syntax",
          syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
        },
        "svg-length": {
          comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
          references: [
            "https://www.w3.org/TR/SVG11/coords.html#Units"
          ],
          syntax: "<percentage> | <length> | <number>"
        },
        "svg-writing-mode": {
          comment: "SVG specific keywords (deprecated for CSS)",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
            "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
          ],
          syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
        },
        top: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "track-group": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
        },
        "track-list-v0": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "[ <string>* <track-group> <string>* ]+ | none"
        },
        "track-minmax": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
        },
        x: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        y: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        declaration: {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
        },
        "declaration-list": {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "[ <declaration>? ';' ]* <declaration>?"
        },
        url: {
          comment: "https://drafts.csswg.org/css-values-4/#urls",
          syntax: "url( <string> <url-modifier>* ) | <url-token>"
        },
        "url-modifier": {
          comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
          syntax: "<ident> | <function-token> <any-value> )"
        },
        "number-zero-one": {
          syntax: "<number [0,1]>"
        },
        "number-one-or-greater": {
          syntax: "<number [1,\u221E]>"
        },
        "positive-integer": {
          syntax: "<integer [0,\u221E]>"
        },
        "-non-standard-display": {
          syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
        }
      }
    };
  }
});

// node_modules/css-tree/data/index.js
var require_data = __commonJS({
  "node_modules/css-tree/data/index.js"(exports, module) {
    var mdnAtrules = require_at_rules();
    var mdnProperties = require_properties();
    var mdnSyntaxes = require_syntaxes();
    var patch = require_patch();
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const descriptor in atrule.descriptors) {
            descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
      }
      for (const key in patchDict) {
        if (key in dict) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function unpackSyntaxes(dict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax;
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
        result[key] = {
          prelude: key in patchDict && "prelude" in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
          descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)
        };
      }
      for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
          result[key] = {
            prelude: patchDict[key].prelude || null,
            descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
          };
        }
      }
      return result;
    }
    module.exports = {
      types: patchDictionary(mdnSyntaxes, patch.syntaxes),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
      properties: patchDictionary(mdnProperties, patch.properties)
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var require_AnPlusB = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AnPlusB.js"(exports, module) {
    var cmpChar = require_tokenizer().cmpChar;
    var isDigit = require_tokenizer().isDigit;
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N2 = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      var pos = this.scanner.tokenStart + offset;
      var code = this.scanner.source.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = "";
        switch (code) {
          case N2:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.scanner.tokenStart + offset);
      }
    }
    function consumeB() {
      var offset = 0;
      var sign = 0;
      var type = this.scanner.tokenType;
      while (type === WHITESPACE || type === COMMENT) {
        type = this.scanner.lookupType(++offset);
      }
      if (type !== NUMBER) {
        if (this.scanner.isDelim(PLUSSIGN, offset) || this.scanner.isDelim(HYPHENMINUS, offset)) {
          sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.scanner.lookupType(++offset);
          } while (type === WHITESPACE || type === COMMENT);
          if (type !== NUMBER) {
            this.scanner.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.scanner.skip(offset);
      }
      if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(NUMBER) : this.consume(NUMBER);
    }
    module.exports = {
      name: "AnPlusB",
      structure: {
        a: [String, null],
        b: [String, null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var a2 = null;
        var b2 = null;
        if (this.scanner.tokenType === NUMBER) {
          checkTokenIsInteger.call(this, ALLOW_SIGN);
          b2 = this.consume(NUMBER);
        } else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
          a2 = "-1";
          expectCharCode.call(this, 1, N2);
          switch (this.scanner.getTokenLength()) {
            case 2:
              this.scanner.next();
              b2 = consumeB.call(this);
              break;
            case 3:
              expectCharCode.call(this, 2, HYPHENMINUS);
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b2 = "-" + this.consume(NUMBER);
              break;
            default:
              expectCharCode.call(this, 2, HYPHENMINUS);
              checkInteger.call(this, 3, DISALLOW_SIGN);
              this.scanner.next();
              b2 = this.scanner.substrToCursor(start + 2);
          }
        } else if (this.scanner.tokenType === IDENT || this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT) {
          var sign = 0;
          a2 = "1";
          if (this.scanner.isDelim(PLUSSIGN)) {
            sign = 1;
            this.scanner.next();
          }
          expectCharCode.call(this, 0, N2);
          switch (this.scanner.getTokenLength()) {
            case 1:
              this.scanner.next();
              b2 = consumeB.call(this);
              break;
            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS);
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b2 = "-" + this.consume(NUMBER);
              break;
            default:
              expectCharCode.call(this, 1, HYPHENMINUS);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.scanner.next();
              b2 = this.scanner.substrToCursor(start + sign + 1);
          }
        } else if (this.scanner.tokenType === DIMENSION) {
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          var sign = code === PLUSSIGN || code === HYPHENMINUS;
          for (var i2 = this.scanner.tokenStart + sign; i2 < this.scanner.tokenEnd; i2++) {
            if (!isDigit(this.scanner.source.charCodeAt(i2))) {
              break;
            }
          }
          if (i2 === this.scanner.tokenStart + sign) {
            this.error("Integer is expected", this.scanner.tokenStart + sign);
          }
          expectCharCode.call(this, i2 - this.scanner.tokenStart, N2);
          a2 = this.scanner.source.substring(start, i2);
          if (i2 + 1 === this.scanner.tokenEnd) {
            this.scanner.next();
            b2 = consumeB.call(this);
          } else {
            expectCharCode.call(this, i2 - this.scanner.tokenStart + 1, HYPHENMINUS);
            if (i2 + 2 === this.scanner.tokenEnd) {
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b2 = "-" + this.consume(NUMBER);
            } else {
              checkInteger.call(this, i2 - this.scanner.tokenStart + 2, DISALLOW_SIGN);
              this.scanner.next();
              b2 = this.scanner.substrToCursor(i2 + 1);
            }
          }
        } else {
          this.error();
        }
        if (a2 !== null && a2.charCodeAt(0) === PLUSSIGN) {
          a2 = a2.substr(1);
        }
        if (b2 !== null && b2.charCodeAt(0) === PLUSSIGN) {
          b2 = b2.substr(1);
        }
        return {
          type: "AnPlusB",
          loc: this.getLocation(start, this.scanner.tokenStart),
          a: a2,
          b: b2
        };
      },
      generate: function(node) {
        var a2 = node.a !== null && node.a !== void 0;
        var b2 = node.b !== null && node.b !== void 0;
        if (a2) {
          this.chunk(
            node.a === "+1" ? "+n" : node.a === "1" ? "n" : node.a === "-1" ? "-n" : node.a + "n"
          );
          if (b2) {
            b2 = String(node.b);
            if (b2.charAt(0) === "-" || b2.charAt(0) === "+") {
              this.chunk(b2.charAt(0));
              this.chunk(b2.substr(1));
            } else {
              this.chunk("+");
              this.chunk(b2);
            }
          }
        } else {
          this.chunk(String(node.b));
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Raw.js
var require_Raw = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Raw.js"(exports, module) {
    var tokenizer = require_tokenizer();
    var TYPE = tokenizer.TYPE;
    var WhiteSpace = TYPE.WhiteSpace;
    var Semicolon = TYPE.Semicolon;
    var LeftCurlyBracket = TYPE.LeftCurlyBracket;
    var Delim = TYPE.Delim;
    var EXCLAMATIONMARK = 33;
    function getOffsetExcludeWS() {
      if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace) {
          return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
        }
      }
      return this.scanner.tokenStart;
    }
    function balanceEnd() {
      return 0;
    }
    function leftCurlyBracket(tokenType) {
      return tokenType === LeftCurlyBracket ? 1 : 0;
    }
    function leftCurlyBracketOrSemicolon(tokenType) {
      return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
    }
    function exclamationMarkOrSemicolon(tokenType, source, offset) {
      if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
        return 1;
      }
      return tokenType === Semicolon ? 1 : 0;
    }
    function semicolonIncluded(tokenType) {
      return tokenType === Semicolon ? 2 : 0;
    }
    module.exports = {
      name: "Raw",
      structure: {
        value: String
      },
      parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;
        this.scanner.skip(
          this.scanner.getRawLength(startToken, mode || balanceEnd)
        );
        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
          endOffset = getOffsetExcludeWS.call(this);
        } else {
          endOffset = this.scanner.tokenStart;
        }
        return {
          type: "Raw",
          loc: this.getLocation(startOffset, endOffset),
          value: this.scanner.source.substring(startOffset, endOffset)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      },
      mode: {
        default: balanceEnd,
        leftCurlyBracket,
        leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon,
        semicolonIncluded
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Atrule.js
var require_Atrule = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Atrule.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var ATKEYWORD = TYPE.AtKeyword;
    var SEMICOLON = TYPE.Semicolon;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
          return true;
        }
        if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
          return false;
        }
      }
      return false;
    }
    module.exports = {
      name: "Atrule",
      structure: {
        name: String,
        prelude: ["AtrulePrelude", "Raw", null],
        block: ["Block", null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;
        this.eat(ATKEYWORD);
        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();
        if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
          if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);
            if (prelude.type === "AtrulePrelude" && prelude.children.head === null) {
              prelude = null;
            }
          } else {
            prelude = consumeRaw.call(this, this.scanner.tokenIndex);
          }
          this.scanner.skipSC();
        }
        switch (this.scanner.tokenType) {
          case SEMICOLON:
            this.scanner.next();
            break;
          case LEFTCURLYBRACKET:
            if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
              block = this.atrule[nameLowerCase].block.call(this);
            } else {
              block = this.Block(isDeclarationBlockAtrule.call(this));
            }
            break;
        }
        return {
          type: "Atrule",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          prelude,
          block
        };
      },
      generate: function(node) {
        this.chunk("@");
        this.chunk(node.name);
        if (node.prelude !== null) {
          this.chunk(" ");
          this.node(node.prelude);
        }
        if (node.block) {
          this.node(node.block);
        } else {
          this.chunk(";");
        }
      },
      walkContext: "atrule"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var require_AtrulePrelude = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AtrulePrelude.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var SEMICOLON = TYPE.Semicolon;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    module.exports = {
      name: "AtrulePrelude",
      structure: {
        children: [[]]
      },
      parse: function(name) {
        var children = null;
        if (name !== null) {
          name = name.toLowerCase();
        }
        this.scanner.skipSC();
        if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === "function") {
          children = this.atrule[name].prelude.call(this);
        } else {
          children = this.readSequence(this.scope.AtrulePrelude);
        }
        this.scanner.skipSC();
        if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
          this.error("Semicolon or block is expected");
        }
        if (children === null) {
          children = this.createList();
        }
        return {
          type: "AtrulePrelude",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      },
      walkContext: "atrulePrelude"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var require_AttributeSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AttributeSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var STRING = TYPE.String;
    var COLON = TYPE.Colon;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
    var DOLLARSIGN = 36;
    var ASTERISK = 42;
    var EQUALSSIGN = 61;
    var CIRCUMFLEXACCENT = 94;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getAttributeName() {
      if (this.scanner.eof) {
        this.error("Unexpected end of input");
      }
      var start = this.scanner.tokenStart;
      var expectIdent = false;
      var checkColon = true;
      if (this.scanner.isDelim(ASTERISK)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
      } else if (!this.scanner.isDelim(VERTICALLINE)) {
        this.eat(IDENT);
      }
      if (this.scanner.isDelim(VERTICALLINE)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
          this.scanner.next();
          this.eat(IDENT);
        } else if (expectIdent) {
          this.error("Identifier is expected", this.scanner.tokenEnd);
        }
      } else if (expectIdent) {
        this.error("Vertical line is expected");
      }
      if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.eat(IDENT);
      }
      return {
        type: "Identifier",
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
      };
    }
    function getOperator() {
      var start = this.scanner.tokenStart;
      var code = this.scanner.source.charCodeAt(start);
      if (code !== EQUALSSIGN && code !== TILDE && code !== CIRCUMFLEXACCENT && code !== DOLLARSIGN && code !== ASTERISK && code !== VERTICALLINE) {
        this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
      }
      this.scanner.next();
      if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
          this.error("Equal sign is expected");
        }
        this.scanner.next();
      }
      return this.scanner.substrToCursor(start);
    }
    module.exports = {
      name: "AttributeSelector",
      structure: {
        name: "Identifier",
        matcher: [String, null],
        value: ["String", "Identifier", null],
        flags: [String, null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;
        this.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();
        name = getAttributeName.call(this);
        this.scanner.skipSC();
        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
          if (this.scanner.tokenType !== IDENT) {
            matcher = getOperator.call(this);
            this.scanner.skipSC();
            value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
            this.scanner.skipSC();
          }
          if (this.scanner.tokenType === IDENT) {
            flags = this.scanner.getTokenValue();
            this.scanner.next();
            this.scanner.skipSC();
          }
        }
        this.eat(RIGHTSQUAREBRACKET);
        return {
          type: "AttributeSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          matcher,
          value,
          flags
        };
      },
      generate: function(node) {
        var flagsPrefix = " ";
        this.chunk("[");
        this.node(node.name);
        if (node.matcher !== null) {
          this.chunk(node.matcher);
          if (node.value !== null) {
            this.node(node.value);
            if (node.value.type === "String") {
              flagsPrefix = "";
            }
          }
        }
        if (node.flags !== null) {
          this.chunk(flagsPrefix);
          this.chunk(node.flags);
        }
        this.chunk("]");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Block.js
var require_Block = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Block.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var SEMICOLON = TYPE.Semicolon;
    var ATKEYWORD = TYPE.AtKeyword;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, true);
    }
    function consumeRule() {
      return this.parseWithFallback(this.Rule, consumeRaw);
    }
    function consumeRawDeclaration(startToken) {
      return this.Raw(startToken, rawMode.semicolonIncluded, true);
    }
    function consumeDeclaration() {
      if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
      }
      var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
      if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
      }
      return node;
    }
    module.exports = {
      name: "Block",
      structure: {
        children: [[
          "Atrule",
          "Rule",
          "Declaration"
        ]]
      },
      parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;
        var start = this.scanner.tokenStart;
        var children = this.createList();
        this.eat(LEFTCURLYBRACKET);
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case RIGHTCURLYBRACKET:
                break scan;
              case WHITESPACE:
              case COMMENT:
                this.scanner.next();
                break;
              case ATKEYWORD:
                children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                break;
              default:
                children.push(consumer.call(this));
            }
          }
        if (!this.scanner.eof) {
          this.eat(RIGHTCURLYBRACKET);
        }
        return {
          type: "Block",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("{");
        this.children(node, function(prev) {
          if (prev.type === "Declaration") {
            this.chunk(";");
          }
        });
        this.chunk("}");
      },
      walkContext: "block"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Brackets.js
var require_Brackets = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Brackets.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
    module.exports = {
      name: "Brackets",
      structure: {
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;
        this.eat(LEFTSQUAREBRACKET);
        children = readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTSQUAREBRACKET);
        }
        return {
          type: "Brackets",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("[");
        this.children(node);
        this.chunk("]");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/CDC.js
var require_CDC = __commonJS({
  "node_modules/css-tree/lib/syntax/node/CDC.js"(exports, module) {
    var CDC = require_tokenizer().TYPE.CDC;
    module.exports = {
      name: "CDC",
      structure: [],
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(CDC);
        return {
          type: "CDC",
          loc: this.getLocation(start, this.scanner.tokenStart)
        };
      },
      generate: function() {
        this.chunk("-->");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/CDO.js
var require_CDO = __commonJS({
  "node_modules/css-tree/lib/syntax/node/CDO.js"(exports, module) {
    var CDO = require_tokenizer().TYPE.CDO;
    module.exports = {
      name: "CDO",
      structure: [],
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(CDO);
        return {
          type: "CDO",
          loc: this.getLocation(start, this.scanner.tokenStart)
        };
      },
      generate: function() {
        this.chunk("<!--");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var require_ClassSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/ClassSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FULLSTOP = 46;
    module.exports = {
      name: "ClassSelector",
      structure: {
        name: String
      },
      parse: function() {
        if (!this.scanner.isDelim(FULLSTOP)) {
          this.error("Full stop is expected");
        }
        this.scanner.next();
        return {
          type: "ClassSelector",
          loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
          name: this.consume(IDENT)
        };
      },
      generate: function(node) {
        this.chunk(".");
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Combinator.js
var require_Combinator = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Combinator.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var GREATERTHANSIGN = 62;
    var TILDE = 126;
    module.exports = {
      name: "Combinator",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        switch (code) {
          case GREATERTHANSIGN:
          case PLUSSIGN:
          case TILDE:
            this.scanner.next();
            break;
          case SOLIDUS:
            this.scanner.next();
            if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, "deep") === false) {
              this.error("Identifier `deep` is expected");
            }
            this.scanner.next();
            if (!this.scanner.isDelim(SOLIDUS)) {
              this.error("Solidus is expected");
            }
            this.scanner.next();
            break;
          default:
            this.error("Combinator is expected");
        }
        return {
          type: "Combinator",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Comment.js
var require_Comment = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Comment.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var COMMENT = TYPE.Comment;
    var ASTERISK = 42;
    var SOLIDUS = 47;
    module.exports = {
      name: "Comment",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;
        this.eat(COMMENT);
        if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK && this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
          end -= 2;
        }
        return {
          type: "Comment",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start + 2, end)
        };
      },
      generate: function(node) {
        this.chunk("/*");
        this.chunk(node.value);
        this.chunk("*/");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Declaration.js
var require_Declaration = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Declaration.js"(exports, module) {
    var isCustomProperty = require_names().isCustomProperty;
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var IDENT = TYPE.Ident;
    var HASH = TYPE.Hash;
    var COLON = TYPE.Colon;
    var SEMICOLON = TYPE.Semicolon;
    var DELIM = TYPE.Delim;
    var WHITESPACE = TYPE.WhiteSpace;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var DOLLARSIGN = 36;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    function consumeValueRaw(startToken) {
      return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw(startToken) {
      return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
      var startValueToken = this.scanner.tokenIndex;
      var value = this.Value();
      if (value.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isDelim(EXCLAMATIONMARK) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value;
    }
    module.exports = {
      name: "Declaration",
      structure: {
        important: [Boolean, String],
        property: String,
        value: ["Value", "Raw"]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;
        this.scanner.skipSC();
        this.eat(COLON);
        const valueStart = this.scanner.tokenIndex;
        if (!customProperty) {
          this.scanner.skipSC();
        }
        if (parseValue) {
          value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
          value = consumeRaw.call(this, this.scanner.tokenIndex);
        }
        if (customProperty && value.type === "Value" && value.children.isEmpty()) {
          for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
            if (this.scanner.lookupType(offset) === WHITESPACE) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
          important = getImportant.call(this);
          this.scanner.skipSC();
        }
        if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isBalanceEdge(startToken) === false) {
          this.error();
        }
        return {
          type: "Declaration",
          loc: this.getLocation(start, this.scanner.tokenStart),
          important,
          property,
          value
        };
      },
      generate: function(node) {
        this.chunk(node.property);
        this.chunk(":");
        this.node(node.value);
        if (node.important) {
          this.chunk(node.important === true ? "!important" : "!" + node.important);
        }
      },
      walkContext: "declaration"
    };
    function readProperty() {
      var start = this.scanner.tokenStart;
      var prefix = 0;
      if (this.scanner.tokenType === DELIM) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
          case ASTERISK:
          case DOLLARSIGN:
          case PLUSSIGN:
          case NUMBERSIGN:
          case AMPERSAND:
            this.scanner.next();
            break;
          case SOLIDUS:
            this.scanner.next();
            if (this.scanner.isDelim(SOLIDUS)) {
              this.scanner.next();
            }
            break;
        }
      }
      if (prefix) {
        this.scanner.skip(prefix);
      }
      if (this.scanner.tokenType === HASH) {
        this.eat(HASH);
      } else {
        this.eat(IDENT);
      }
      return this.scanner.substrToCursor(start);
    }
    function getImportant() {
      this.eat(DELIM);
      this.scanner.skipSC();
      var important = this.consume(IDENT);
      return important === "important" ? true : important;
    }
  }
});

// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var require_DeclarationList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/DeclarationList.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var SEMICOLON = TYPE.Semicolon;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.semicolonIncluded, true);
    }
    module.exports = {
      name: "DeclarationList",
      structure: {
        children: [[
          "Declaration"
        ]]
      },
      parse: function() {
        var children = this.createList();
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
              case COMMENT:
              case SEMICOLON:
                this.scanner.next();
                break;
              default:
                children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
          }
        return {
          type: "DeclarationList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function(prev) {
          if (prev.type === "Declaration") {
            this.chunk(";");
          }
        });
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Dimension.js
var require_Dimension = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Dimension.js"(exports, module) {
    var consumeNumber = require_utils2().consumeNumber;
    var TYPE = require_tokenizer().TYPE;
    var DIMENSION = TYPE.Dimension;
    module.exports = {
      name: "Dimension",
      structure: {
        value: String,
        unit: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);
        this.eat(DIMENSION);
        return {
          type: "Dimension",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start, numberEnd),
          unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Function.js
var require_Function = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Function.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module.exports = {
      name: "Function",
      structure: {
        name: String,
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;
        children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTPARENTHESIS);
        }
        return {
          type: "Function",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk(node.name);
        this.chunk("(");
        this.children(node);
        this.chunk(")");
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Hash.js
var require_Hash = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Hash.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var HASH = TYPE.Hash;
    module.exports = {
      name: "Hash",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(HASH);
        return {
          type: "Hash",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start + 1)
        };
      },
      generate: function(node) {
        this.chunk("#");
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Identifier.js
var require_Identifier = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Identifier.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    module.exports = {
      name: "Identifier",
      structure: {
        name: String
      },
      parse: function() {
        return {
          type: "Identifier",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          name: this.consume(IDENT)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/IdSelector.js
var require_IdSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/IdSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var HASH = TYPE.Hash;
    module.exports = {
      name: "IdSelector",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(HASH);
        return {
          type: "IdSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start + 1)
        };
      },
      generate: function(node) {
        this.chunk("#");
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaFeature.js
var require_MediaFeature = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaFeature.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    var COLON = TYPE.Colon;
    var DELIM = TYPE.Delim;
    module.exports = {
      name: "MediaFeature",
      structure: {
        name: String,
        value: ["Identifier", "Number", "Dimension", "Ratio", null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;
        this.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();
        name = this.consume(IDENT);
        this.scanner.skipSC();
        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
          this.eat(COLON);
          this.scanner.skipSC();
          switch (this.scanner.tokenType) {
            case NUMBER:
              if (this.lookupNonWSType(1) === DELIM) {
                value = this.Ratio();
              } else {
                value = this.Number();
              }
              break;
            case DIMENSION:
              value = this.Dimension();
              break;
            case IDENT:
              value = this.Identifier();
              break;
            default:
              this.error("Number, dimension, ratio or identifier is expected");
          }
          this.scanner.skipSC();
        }
        this.eat(RIGHTPARENTHESIS);
        return {
          type: "MediaFeature",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          value
        };
      },
      generate: function(node) {
        this.chunk("(");
        this.chunk(node.name);
        if (node.value !== null) {
          this.chunk(":");
          this.node(node.value);
        }
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var require_MediaQuery = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaQuery.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    module.exports = {
      name: "MediaQuery",
      structure: {
        children: [[
          "Identifier",
          "MediaFeature",
          "WhiteSpace"
        ]]
      },
      parse: function() {
        this.scanner.skipSC();
        var children = this.createList();
        var child = null;
        var space = null;
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case COMMENT:
                this.scanner.next();
                continue;
              case WHITESPACE:
                space = this.WhiteSpace();
                continue;
              case IDENT:
                child = this.Identifier();
                break;
              case LEFTPARENTHESIS:
                child = this.MediaFeature();
                break;
              default:
                break scan;
            }
            if (space !== null) {
              children.push(space);
              space = null;
            }
            children.push(child);
          }
        if (child === null) {
          this.error("Identifier or parenthesis is expected");
        }
        return {
          type: "MediaQuery",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var require_MediaQueryList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaQueryList.js"(exports, module) {
    var COMMA = require_tokenizer().TYPE.Comma;
    module.exports = {
      name: "MediaQueryList",
      structure: {
        children: [[
          "MediaQuery"
        ]]
      },
      parse: function(relative) {
        var children = this.createList();
        this.scanner.skipSC();
        while (!this.scanner.eof) {
          children.push(this.MediaQuery(relative));
          if (this.scanner.tokenType !== COMMA) {
            break;
          }
          this.scanner.next();
        }
        return {
          type: "MediaQueryList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function() {
          this.chunk(",");
        });
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Nth.js
var require_Nth = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Nth.js"(exports, module) {
    module.exports = {
      name: "Nth",
      structure: {
        nth: ["AnPlusB", "Identifier"],
        selector: ["SelectorList", null]
      },
      parse: function(allowOfClause) {
        this.scanner.skipSC();
        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;
        if (this.scanner.lookupValue(0, "odd") || this.scanner.lookupValue(0, "even")) {
          query = this.Identifier();
        } else {
          query = this.AnPlusB();
        }
        this.scanner.skipSC();
        if (allowOfClause && this.scanner.lookupValue(0, "of")) {
          this.scanner.next();
          selector = this.SelectorList();
          if (this.needPositions) {
            end = this.getLastListNode(selector.children).loc.end.offset;
          }
        } else {
          if (this.needPositions) {
            end = query.loc.end.offset;
          }
        }
        return {
          type: "Nth",
          loc: this.getLocation(start, end),
          nth: query,
          selector
        };
      },
      generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
          this.chunk(" of ");
          this.node(node.selector);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Number.js
var require_Number = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Number.js"(exports, module) {
    var NUMBER = require_tokenizer().TYPE.Number;
    module.exports = {
      name: "Number",
      structure: {
        value: String
      },
      parse: function() {
        return {
          type: "Number",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          value: this.consume(NUMBER)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Operator.js
var require_Operator = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Operator.js"(exports, module) {
    module.exports = {
      name: "Operator",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.scanner.next();
        return {
          type: "Operator",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Parentheses.js
var require_Parentheses = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Parentheses.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module.exports = {
      name: "Parentheses",
      structure: {
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;
        this.eat(LEFTPARENTHESIS);
        children = readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTPARENTHESIS);
        }
        return {
          type: "Parentheses",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("(");
        this.children(node);
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Percentage.js
var require_Percentage = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Percentage.js"(exports, module) {
    var consumeNumber = require_utils2().consumeNumber;
    var TYPE = require_tokenizer().TYPE;
    var PERCENTAGE = TYPE.Percentage;
    module.exports = {
      name: "Percentage",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);
        this.eat(PERCENTAGE);
        return {
          type: "Percentage",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start, numberEnd)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
        this.chunk("%");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var require_PseudoClassSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module.exports = {
      name: "PseudoClassSelector",
      structure: {
        name: String,
        children: [["Raw"], null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;
        this.eat(COLON);
        if (this.scanner.tokenType === FUNCTION) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.scanner.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.scanner.skipSC();
          } else {
            children = this.createList();
            children.push(
              this.Raw(this.scanner.tokenIndex, null, false)
            );
          }
          this.eat(RIGHTPARENTHESIS);
        } else {
          name = this.consume(IDENT);
        }
        return {
          type: "PseudoClassSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk(":");
        this.chunk(node.name);
        if (node.children !== null) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        }
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var require_PseudoElementSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module.exports = {
      name: "PseudoElementSelector",
      structure: {
        name: String,
        children: [["Raw"], null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;
        this.eat(COLON);
        this.eat(COLON);
        if (this.scanner.tokenType === FUNCTION) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.scanner.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.scanner.skipSC();
          } else {
            children = this.createList();
            children.push(
              this.Raw(this.scanner.tokenIndex, null, false)
            );
          }
          this.eat(RIGHTPARENTHESIS);
        } else {
          name = this.consume(IDENT);
        }
        return {
          type: "PseudoElementSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk("::");
        this.chunk(node.name);
        if (node.children !== null) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        }
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Ratio.js
var require_Ratio = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Ratio.js"(exports, module) {
    var isDigit = require_tokenizer().isDigit;
    var TYPE = require_tokenizer().TYPE;
    var NUMBER = TYPE.Number;
    var DELIM = TYPE.Delim;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    function consumeNumber() {
      this.scanner.skipWS();
      var value = this.consume(NUMBER);
      for (var i2 = 0; i2 < value.length; i2++) {
        var code = value.charCodeAt(i2);
        if (!isDigit(code) && code !== FULLSTOP) {
          this.error("Unsigned number is expected", this.scanner.tokenStart - value.length + i2);
        }
      }
      if (Number(value) === 0) {
        this.error("Zero number is not allowed", this.scanner.tokenStart - value.length);
      }
      return value;
    }
    module.exports = {
      name: "Ratio",
      structure: {
        left: String,
        right: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;
        this.scanner.skipWS();
        if (!this.scanner.isDelim(SOLIDUS)) {
          this.error("Solidus is expected");
        }
        this.eat(DELIM);
        right = consumeNumber.call(this);
        return {
          type: "Ratio",
          loc: this.getLocation(start, this.scanner.tokenStart),
          left,
          right
        };
      },
      generate: function(node) {
        this.chunk(node.left);
        this.chunk("/");
        this.chunk(node.right);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Rule.js
var require_Rule = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Rule.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.leftCurlyBracket, true);
    }
    function consumePrelude() {
      var prelude = this.SelectorList();
      if (prelude.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
      }
      return prelude;
    }
    module.exports = {
      name: "Rule",
      structure: {
        prelude: ["SelectorList", "Raw"],
        block: ["Block"]
      },
      parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;
        if (this.parseRulePrelude) {
          prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
          prelude = consumeRaw.call(this, startToken);
        }
        block = this.Block(true);
        return {
          type: "Rule",
          loc: this.getLocation(startOffset, this.scanner.tokenStart),
          prelude,
          block
        };
      },
      generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
      },
      walkContext: "rule"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Selector.js
var require_Selector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Selector.js"(exports, module) {
    module.exports = {
      name: "Selector",
      structure: {
        children: [[
          "TypeSelector",
          "IdSelector",
          "ClassSelector",
          "AttributeSelector",
          "PseudoClassSelector",
          "PseudoElementSelector",
          "Combinator",
          "WhiteSpace"
        ]]
      },
      parse: function() {
        var children = this.readSequence(this.scope.Selector);
        if (this.getFirstListNode(children) === null) {
          this.error("Selector is expected");
        }
        return {
          type: "Selector",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/SelectorList.js
var require_SelectorList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/SelectorList.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var COMMA = TYPE.Comma;
    module.exports = {
      name: "SelectorList",
      structure: {
        children: [[
          "Selector",
          "Raw"
        ]]
      },
      parse: function() {
        var children = this.createList();
        while (!this.scanner.eof) {
          children.push(this.Selector());
          if (this.scanner.tokenType === COMMA) {
            this.scanner.next();
            continue;
          }
          break;
        }
        return {
          type: "SelectorList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function() {
          this.chunk(",");
        });
      },
      walkContext: "selector"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/String.js
var require_String = __commonJS({
  "node_modules/css-tree/lib/syntax/node/String.js"(exports, module) {
    var STRING = require_tokenizer().TYPE.String;
    module.exports = {
      name: "String",
      structure: {
        value: String
      },
      parse: function() {
        return {
          type: "String",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          value: this.consume(STRING)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var require_StyleSheet = __commonJS({
  "node_modules/css-tree/lib/syntax/node/StyleSheet.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var ATKEYWORD = TYPE.AtKeyword;
    var CDO = TYPE.CDO;
    var CDC = TYPE.CDC;
    var EXCLAMATIONMARK = 33;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, false);
    }
    module.exports = {
      name: "StyleSheet",
      structure: {
        children: [[
          "Comment",
          "CDO",
          "CDC",
          "Atrule",
          "Rule",
          "Raw"
        ]]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
                this.scanner.next();
                continue;
              case COMMENT:
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                  this.scanner.next();
                  continue;
                }
                child = this.Comment();
                break;
              case CDO:
                child = this.CDO();
                break;
              case CDC:
                child = this.CDC();
                break;
              case ATKEYWORD:
                child = this.parseWithFallback(this.Atrule, consumeRaw);
                break;
              default:
                child = this.parseWithFallback(this.Rule, consumeRaw);
            }
            children.push(child);
          }
        return {
          type: "StyleSheet",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      },
      walkContext: "stylesheet"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var require_TypeSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/TypeSelector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var ASTERISK = 42;
    var VERTICALLINE = 124;
    function eatIdentifierOrAsterisk() {
      if (this.scanner.tokenType !== IDENT && this.scanner.isDelim(ASTERISK) === false) {
        this.error("Identifier or asterisk is expected");
      }
      this.scanner.next();
    }
    module.exports = {
      name: "TypeSelector",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        if (this.scanner.isDelim(VERTICALLINE)) {
          this.scanner.next();
          eatIdentifierOrAsterisk.call(this);
        } else {
          eatIdentifierOrAsterisk.call(this);
          if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
          }
        }
        return {
          type: "TypeSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var require_UnicodeRange = __commonJS({
  "node_modules/css-tree/lib/syntax/node/UnicodeRange.js"(exports, module) {
    var isHexDigit = require_tokenizer().isHexDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var NAME = require_tokenizer().NAME;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function eatHexSequence(offset, allowDash) {
      for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && len !== 0) {
          if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
            this.error();
          }
          return -1;
        }
        if (!isHexDigit(code)) {
          this.error(
            allowDash && len !== 0 ? "HyphenMinus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
            pos
          );
        }
        if (++len > 6) {
          this.error("Too many hex digits", pos);
        }
        ;
      }
      this.scanner.next();
      return len;
    }
    function eatQuestionMarkSequence(max) {
      var count = 0;
      while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
          this.error("Too many question marks");
        }
        this.scanner.next();
      }
    }
    function startsWith(code) {
      if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + " is expected");
      }
    }
    function scanUnicodeRange() {
      var hexLength = 0;
      if (this.scanner.isDelim(PLUSSIGN)) {
        this.scanner.next();
        if (this.scanner.tokenType === IDENT) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          return;
        }
        if (this.scanner.isDelim(QUESTIONMARK)) {
          this.scanner.next();
          eatQuestionMarkSequence.call(this, 5);
          return;
        }
        this.error("Hex digit or question mark is expected");
        return;
      }
      if (this.scanner.tokenType === NUMBER) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.scanner.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          return;
        }
        if (this.scanner.tokenType === DIMENSION || this.scanner.tokenType === NUMBER) {
          startsWith.call(this, HYPHENMINUS);
          eatHexSequence.call(this, 1, false);
          return;
        }
        return;
      }
      if (this.scanner.tokenType === DIMENSION) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        return;
      }
      this.error();
    }
    module.exports = {
      name: "UnicodeRange",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        if (!cmpChar(this.scanner.source, start, U)) {
          this.error("U is expected");
        }
        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
          this.error("Plus sign is expected");
        }
        this.scanner.next();
        scanUnicodeRange.call(this);
        return {
          type: "UnicodeRange",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Url.js
var require_Url = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Url.js"(exports, module) {
    var isWhiteSpace = require_tokenizer().isWhiteSpace;
    var cmpStr = require_tokenizer().cmpStr;
    var TYPE = require_tokenizer().TYPE;
    var FUNCTION = TYPE.Function;
    var URL2 = TYPE.Url;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module.exports = {
      name: "Url",
      structure: {
        value: ["String", "Raw"]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var value;
        switch (this.scanner.tokenType) {
          case URL2:
            var rawStart = start + 4;
            var rawEnd = this.scanner.tokenEnd - 1;
            while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
              rawStart++;
            }
            while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
              rawEnd--;
            }
            value = {
              type: "Raw",
              loc: this.getLocation(rawStart, rawEnd),
              value: this.scanner.source.substring(rawStart, rawEnd)
            };
            this.eat(URL2);
            break;
          case FUNCTION:
            if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(")) {
              this.error("Function name must be `url`");
            }
            this.eat(FUNCTION);
            this.scanner.skipSC();
            value = this.String();
            this.scanner.skipSC();
            this.eat(RIGHTPARENTHESIS);
            break;
          default:
            this.error("Url or Function is expected");
        }
        return {
          type: "Url",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value
        };
      },
      generate: function(node) {
        this.chunk("url");
        this.chunk("(");
        this.node(node.value);
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Value.js
var require_Value = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Value.js"(exports, module) {
    module.exports = {
      name: "Value",
      structure: {
        children: [[]]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);
        return {
          type: "Value",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var require_WhiteSpace = __commonJS({
  "node_modules/css-tree/lib/syntax/node/WhiteSpace.js"(exports, module) {
    var WHITESPACE = require_tokenizer().TYPE.WhiteSpace;
    var SPACE = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    });
    module.exports = {
      name: "WhiteSpace",
      structure: {
        value: String
      },
      parse: function() {
        this.eat(WHITESPACE);
        return SPACE;
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/index.js
var require_node2 = __commonJS({
  "node_modules/css-tree/lib/syntax/node/index.js"(exports, module) {
    module.exports = {
      AnPlusB: require_AnPlusB(),
      Atrule: require_Atrule(),
      AtrulePrelude: require_AtrulePrelude(),
      AttributeSelector: require_AttributeSelector(),
      Block: require_Block(),
      Brackets: require_Brackets(),
      CDC: require_CDC(),
      CDO: require_CDO(),
      ClassSelector: require_ClassSelector(),
      Combinator: require_Combinator(),
      Comment: require_Comment(),
      Declaration: require_Declaration(),
      DeclarationList: require_DeclarationList(),
      Dimension: require_Dimension(),
      Function: require_Function(),
      Hash: require_Hash(),
      Identifier: require_Identifier(),
      IdSelector: require_IdSelector(),
      MediaFeature: require_MediaFeature(),
      MediaQuery: require_MediaQuery(),
      MediaQueryList: require_MediaQueryList(),
      Nth: require_Nth(),
      Number: require_Number(),
      Operator: require_Operator(),
      Parentheses: require_Parentheses(),
      Percentage: require_Percentage(),
      PseudoClassSelector: require_PseudoClassSelector(),
      PseudoElementSelector: require_PseudoElementSelector(),
      Ratio: require_Ratio(),
      Raw: require_Raw(),
      Rule: require_Rule(),
      Selector: require_Selector(),
      SelectorList: require_SelectorList(),
      String: require_String(),
      StyleSheet: require_StyleSheet(),
      TypeSelector: require_TypeSelector(),
      UnicodeRange: require_UnicodeRange(),
      Url: require_Url(),
      Value: require_Value(),
      WhiteSpace: require_WhiteSpace()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/lexer.js
var require_lexer = __commonJS({
  "node_modules/css-tree/lib/syntax/config/lexer.js"(exports, module) {
    var data = require_data();
    module.exports = {
      generic: true,
      types: data.types,
      atrules: data.atrules,
      properties: data.properties,
      node: require_node2()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/default.js
var require_default = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/default.js"(exports, module) {
    var cmpChar = require_tokenizer().cmpChar;
    var cmpStr = require_tokenizer().cmpStr;
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var STRING = TYPE.String;
    var NUMBER = TYPE.Number;
    var FUNCTION = TYPE.Function;
    var URL2 = TYPE.Url;
    var HASH = TYPE.Hash;
    var DIMENSION = TYPE.Dimension;
    var PERCENTAGE = TYPE.Percentage;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var COMMA = TYPE.Comma;
    var DELIM = TYPE.Delim;
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var SOLIDUS = 47;
    var U = 117;
    module.exports = function defaultRecognizer(context) {
      switch (this.scanner.tokenType) {
        case HASH:
          return this.Hash();
        case COMMA:
          context.space = null;
          context.ignoreWSAfter = true;
          return this.Operator();
        case LEFTPARENTHESIS:
          return this.Parentheses(this.readSequence, context.recognizer);
        case LEFTSQUAREBRACKET:
          return this.Brackets(this.readSequence, context.recognizer);
        case STRING:
          return this.String();
        case DIMENSION:
          return this.Dimension();
        case PERCENTAGE:
          return this.Percentage();
        case NUMBER:
          return this.Number();
        case FUNCTION:
          return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
        case URL2:
          return this.Url();
        case IDENT:
          if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) && cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
            return this.UnicodeRange();
          } else {
            return this.Identifier();
          }
        case DELIM:
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
            return this.Operator();
          }
          if (code === NUMBERSIGN) {
            this.error("Hex or identifier is expected", this.scanner.tokenStart + 1);
          }
          break;
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var require_atrulePrelude = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/atrulePrelude.js"(exports, module) {
    module.exports = {
      getNode: require_default()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/selector.js
var require_selector = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/selector.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var DELIM = TYPE.Delim;
    var IDENT = TYPE.Ident;
    var DIMENSION = TYPE.Dimension;
    var PERCENTAGE = TYPE.Percentage;
    var NUMBER = TYPE.Number;
    var HASH = TYPE.Hash;
    var COLON = TYPE.Colon;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    var GREATERTHANSIGN = 62;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getNode(context) {
      switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
          return this.AttributeSelector();
        case HASH:
          return this.IdSelector();
        case COLON:
          if (this.scanner.lookupType(1) === COLON) {
            return this.PseudoElementSelector();
          } else {
            return this.PseudoClassSelector();
          }
        case IDENT:
          return this.TypeSelector();
        case NUMBER:
        case PERCENTAGE:
          return this.Percentage();
        case DIMENSION:
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
            this.error("Identifier is expected", this.scanner.tokenStart + 1);
          }
          break;
        case DELIM:
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
              context.space = null;
              context.ignoreWSAfter = true;
              return this.Combinator();
            case SOLIDUS:
              return this.Combinator();
            case FULLSTOP:
              return this.ClassSelector();
            case ASTERISK:
            case VERTICALLINE:
              return this.TypeSelector();
            case NUMBERSIGN:
              return this.IdSelector();
          }
          break;
      }
    }
    module.exports = {
      getNode
    };
  }
});

// node_modules/css-tree/lib/syntax/function/expression.js
var require_expression = __commonJS({
  "node_modules/css-tree/lib/syntax/function/expression.js"(exports, module) {
    module.exports = function() {
      return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
      );
    };
  }
});

// node_modules/css-tree/lib/syntax/function/var.js
var require_var = __commonJS({
  "node_modules/css-tree/lib/syntax/function/var.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var COMMA = TYPE.Comma;
    var WHITESPACE = TYPE.WhiteSpace;
    module.exports = function() {
      var children = this.createList();
      this.scanner.skipSC();
      children.push(this.Identifier());
      this.scanner.skipSC();
      if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());
        const startIndex = this.scanner.tokenIndex;
        const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);
        if (value.type === "Value" && value.children.isEmpty()) {
          for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
            if (this.scanner.lookupType(offset) === WHITESPACE) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        children.push(value);
      }
      return children;
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/value.js
var require_value = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/value.js"(exports, module) {
    module.exports = {
      getNode: require_default(),
      "expression": require_expression(),
      "var": require_var()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/index.js
var require_scope = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/index.js"(exports, module) {
    module.exports = {
      AtrulePrelude: require_atrulePrelude(),
      Selector: require_selector(),
      Value: require_value()
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var require_font_face = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/font-face.js"(exports, module) {
    module.exports = {
      parse: {
        prelude: null,
        block: function() {
          return this.Block(true);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/import.js
var require_import = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/import.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var STRING = TYPE.String;
    var IDENT = TYPE.Ident;
    var URL2 = TYPE.Url;
    var FUNCTION = TYPE.Function;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    module.exports = {
      parse: {
        prelude: function() {
          var children = this.createList();
          this.scanner.skipSC();
          switch (this.scanner.tokenType) {
            case STRING:
              children.push(this.String());
              break;
            case URL2:
            case FUNCTION:
              children.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          if (this.lookupNonWSType(0) === IDENT || this.lookupNonWSType(0) === LEFTPARENTHESIS) {
            children.push(this.WhiteSpace());
            children.push(this.MediaQueryList());
          }
          return children;
        },
        block: null
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/media.js
var require_media = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/media.js"(exports, module) {
    module.exports = {
      parse: {
        prelude: function() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block: function() {
          return this.Block(false);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/page.js
var require_page = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/page.js"(exports, module) {
    module.exports = {
      parse: {
        prelude: function() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block: function() {
          return this.Block(true);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/supports.js
var require_supports = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/supports.js"(exports, module) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    function consumeRaw() {
      return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
      );
    }
    function parentheses() {
      this.scanner.skipSC();
      if (this.scanner.tokenType === IDENT && this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
          this.Declaration()
        );
      }
      return readSequence.call(this);
    }
    function readSequence() {
      var children = this.createList();
      var space = null;
      var child;
      this.scanner.skipSC();
      scan:
        while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case WHITESPACE:
              space = this.WhiteSpace();
              continue;
            case COMMENT:
              this.scanner.next();
              continue;
            case FUNCTION:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case IDENT:
              child = this.Identifier();
              break;
            case LEFTPARENTHESIS:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          if (space !== null) {
            children.push(space);
            space = null;
          }
          children.push(child);
        }
      return children;
    }
    module.exports = {
      parse: {
        prelude: function() {
          var children = readSequence.call(this);
          if (this.getFirstListNode(children) === null) {
            this.error("Condition is expected");
          }
          return children;
        },
        block: function() {
          return this.Block(false);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/index.js
var require_atrule = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/index.js"(exports, module) {
    module.exports = {
      "font-face": require_font_face(),
      "import": require_import(),
      "media": require_media(),
      "page": require_page(),
      "supports": require_supports()
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/dir.js
var require_dir = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/dir.js"(exports, module) {
    module.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/has.js
var require_has = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/has.js"(exports, module) {
    module.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/lang.js
var require_lang = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/lang.js"(exports, module) {
    module.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js
var require_selectorList = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js"(exports, module) {
    module.exports = {
      parse: function selectorList() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/matches.js
var require_matches = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/matches.js"(exports, module) {
    module.exports = require_selectorList();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/not.js
var require_not = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/not.js"(exports, module) {
    module.exports = require_selectorList();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js
var require_nthWithOfClause = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js"(exports, module) {
    var ALLOW_OF_CLAUSE = true;
    module.exports = {
      parse: function nthWithOfClause() {
        return this.createSingleNodeList(
          this.Nth(ALLOW_OF_CLAUSE)
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-child.js
var require_nth_child = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-child.js"(exports, module) {
    module.exports = require_nthWithOfClause();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js
var require_nth_last_child = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js"(exports, module) {
    module.exports = require_nthWithOfClause();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/nth.js
var require_nth = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/nth.js"(exports, module) {
    var DISALLOW_OF_CLAUSE = false;
    module.exports = {
      parse: function nth() {
        return this.createSingleNodeList(
          this.Nth(DISALLOW_OF_CLAUSE)
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js
var require_nth_last_of_type = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js"(exports, module) {
    module.exports = require_nth();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js
var require_nth_of_type = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js"(exports, module) {
    module.exports = require_nth();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/slotted.js
var require_slotted = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/slotted.js"(exports, module) {
    module.exports = {
      parse: function compoundSelector() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/index.js
var require_pseudo = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/index.js"(exports, module) {
    module.exports = {
      "dir": require_dir(),
      "has": require_has(),
      "lang": require_lang(),
      "matches": require_matches(),
      "not": require_not(),
      "nth-child": require_nth_child(),
      "nth-last-child": require_nth_last_child(),
      "nth-last-of-type": require_nth_last_of_type(),
      "nth-of-type": require_nth_of_type(),
      "slotted": require_slotted()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/parser.js
var require_parser = __commonJS({
  "node_modules/css-tree/lib/syntax/config/parser.js"(exports, module) {
    module.exports = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude: function(options) {
          return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block: function() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      scope: require_scope(),
      atrule: require_atrule(),
      pseudo: require_pseudo(),
      node: require_node2()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/walker.js
var require_walker = __commonJS({
  "node_modules/css-tree/lib/syntax/config/walker.js"(exports, module) {
    module.exports = {
      node: require_node2()
    };
  }
});

// node_modules/css-tree/package.json
var require_package = __commonJS({
  "node_modules/css-tree/package.json"(exports, module) {
    module.exports = {
      name: "css-tree",
      version: "1.1.3",
      description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
      author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
      license: "MIT",
      repository: "csstree/csstree",
      keywords: [
        "css",
        "ast",
        "tokenizer",
        "parser",
        "walker",
        "lexer",
        "generator",
        "utils",
        "syntax",
        "validation"
      ],
      main: "lib/index.js",
      unpkg: "dist/csstree.min.js",
      jsdelivr: "dist/csstree.min.js",
      scripts: {
        build: "rollup --config",
        lint: "eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
        "lint-and-test": "npm run lint && npm test",
        "update:docs": "node scripts/update-docs",
        "review:syntax-patch": "node scripts/review-syntax-patch",
        test: "mocha --reporter progress",
        coverage: "nyc npm test",
        travis: "nyc npm run lint-and-test && npm run coveralls",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        prepublishOnly: "npm run build",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
      },
      dependencies: {
        "mdn-data": "2.0.14",
        "source-map": "^0.6.1"
      },
      devDependencies: {
        "@rollup/plugin-commonjs": "^11.0.2",
        "@rollup/plugin-json": "^4.0.2",
        "@rollup/plugin-node-resolve": "^7.1.1",
        coveralls: "^3.0.9",
        eslint: "^6.8.0",
        "json-to-ast": "^2.1.0",
        mocha: "^6.2.3",
        nyc: "^14.1.1",
        rollup: "^1.32.1",
        "rollup-plugin-terser": "^5.3.0"
      },
      engines: {
        node: ">=8.0.0"
      },
      files: [
        "data",
        "dist",
        "lib"
      ]
    };
  }
});

// node_modules/css-tree/lib/syntax/index.js
var require_syntax = __commonJS({
  "node_modules/css-tree/lib/syntax/index.js"(exports, module) {
    function merge() {
      var dest = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var src = arguments[i2];
        for (var key in src) {
          dest[key] = src[key];
        }
      }
      return dest;
    }
    module.exports = require_create5().create(
      merge(
        require_lexer(),
        require_parser(),
        require_walker()
      )
    );
    module.exports.version = require_package().version;
  }
});

// node_modules/css-tree/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/css-tree/lib/index.js"(exports, module) {
    module.exports = require_syntax();
  }
});

// node_modules/stable/stable.js
var require_stable = __commonJS({
  "node_modules/stable/stable.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.stable = factory();
    })(exports, function() {
      "use strict";
      var stable = function(arr, comp) {
        return exec(arr.slice(), comp);
      };
      stable.inplace = function(arr, comp) {
        var result = exec(arr, comp);
        if (result !== arr) {
          pass(result, null, arr.length, arr);
        }
        return arr;
      };
      function exec(arr, comp) {
        if (typeof comp !== "function") {
          comp = function(a2, b2) {
            return String(a2).localeCompare(b2);
          };
        }
        var len = arr.length;
        if (len <= 1) {
          return arr;
        }
        var buffer = new Array(len);
        for (var chk = 1; chk < len; chk *= 2) {
          pass(arr, comp, chk, buffer);
          var tmp = arr;
          arr = buffer;
          buffer = tmp;
        }
        return arr;
      }
      var pass = function(arr, comp, chk, result) {
        var len = arr.length;
        var i2 = 0;
        var dbl = chk * 2;
        var l2, r2, e2;
        var li, ri;
        for (l2 = 0; l2 < len; l2 += dbl) {
          r2 = l2 + chk;
          e2 = r2 + chk;
          if (r2 > len)
            r2 = len;
          if (e2 > len)
            e2 = len;
          li = l2;
          ri = r2;
          while (true) {
            if (li < r2 && ri < e2) {
              if (comp(arr[li], arr[ri]) <= 0) {
                result[i2++] = arr[li++];
              } else {
                result[i2++] = arr[ri++];
              }
            } else if (li < r2) {
              result[i2++] = arr[li++];
            } else if (ri < e2) {
              result[i2++] = arr[ri++];
            } else {
              break;
            }
          }
        }
      };
      return stable;
    });
  }
});

// node_modules/csso/lib/restructure/prepare/specificity.js
var require_specificity = __commonJS({
  "node_modules/csso/lib/restructure/prepare/specificity.js"(exports, module) {
    module.exports = function specificity(simpleSelector) {
      var A = 0;
      var B = 0;
      var C = 0;
      simpleSelector.children.each(function walk(node) {
        switch (node.type) {
          case "SelectorList":
          case "Selector":
            node.children.each(walk);
            break;
          case "IdSelector":
            A++;
            break;
          case "ClassSelector":
          case "AttributeSelector":
            B++;
            break;
          case "PseudoClassSelector":
            switch (node.name.toLowerCase()) {
              case "not":
                node.children.each(walk);
                break;
              case "before":
              case "after":
              case "first-line":
              case "first-letter":
                C++;
                break;
              default:
                B++;
            }
            break;
          case "PseudoElementSelector":
            C++;
            break;
          case "TypeSelector":
            if (node.name.charAt(node.name.length - 1) !== "*") {
              C++;
            }
            break;
        }
      });
      return [A, B, C];
    };
  }
});

// node_modules/svgo/lib/css-tools.js
var require_css_tools = __commonJS({
  "node_modules/svgo/lib/css-tools.js"(exports, module) {
    "use strict";
    var csstree = require_lib9();
    var List = csstree.List;
    var stable = require_stable();
    var specificity = require_specificity();
    function flattenToSelectors(cssAst) {
      var selectors = [];
      csstree.walk(cssAst, {
        visit: "Rule",
        enter: function(node) {
          if (node.type !== "Rule") {
            return;
          }
          var atrule = this.atrule;
          var rule = node;
          node.prelude.children.each(function(selectorNode, selectorItem) {
            var selector = {
              item: selectorItem,
              atrule,
              rule,
              pseudos: []
            };
            selectorNode.children.each(function(selectorChildNode, selectorChildItem, selectorChildList) {
              if (selectorChildNode.type === "PseudoClassSelector" || selectorChildNode.type === "PseudoElementSelector") {
                selector.pseudos.push({
                  item: selectorChildItem,
                  list: selectorChildList
                });
              }
            });
            selectors.push(selector);
          });
        }
      });
      return selectors;
    }
    function filterByMqs(selectors, useMqs) {
      return selectors.filter(function(selector) {
        if (selector.atrule === null) {
          return ~useMqs.indexOf("");
        }
        var mqName = selector.atrule.name;
        var mqStr = mqName;
        if (selector.atrule.expression && selector.atrule.expression.children.first().type === "MediaQueryList") {
          var mqExpr = csstree.generate(selector.atrule.expression);
          mqStr = [mqName, mqExpr].join(" ");
        }
        return ~useMqs.indexOf(mqStr);
      });
    }
    function filterByPseudos(selectors, usePseudos) {
      return selectors.filter(function(selector) {
        var pseudoSelectorsStr = csstree.generate({
          type: "Selector",
          children: new List().fromArray(
            selector.pseudos.map(function(pseudo) {
              return pseudo.item.data;
            })
          )
        });
        return ~usePseudos.indexOf(pseudoSelectorsStr);
      });
    }
    function cleanPseudos(selectors) {
      selectors.forEach(function(selector) {
        selector.pseudos.forEach(function(pseudo) {
          pseudo.list.remove(pseudo.item);
        });
      });
    }
    function compareSpecificity(aSpecificity, bSpecificity) {
      for (var i2 = 0; i2 < 4; i2 += 1) {
        if (aSpecificity[i2] < bSpecificity[i2]) {
          return -1;
        } else if (aSpecificity[i2] > bSpecificity[i2]) {
          return 1;
        }
      }
      return 0;
    }
    function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
      var aSpecificity = specificity(aSimpleSelectorNode), bSpecificity = specificity(bSimpleSelectorNode);
      return compareSpecificity(aSpecificity, bSpecificity);
    }
    function _bySelectorSpecificity(selectorA, selectorB) {
      return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
    }
    function sortSelectors(selectors) {
      return stable(selectors, _bySelectorSpecificity);
    }
    function csstreeToStyleDeclaration(declaration) {
      var propertyName = declaration.property, propertyValue = csstree.generate(declaration.value), propertyPriority = declaration.important ? "important" : "";
      return {
        name: propertyName,
        value: propertyValue,
        priority: propertyPriority
      };
    }
    function getCssStr(elem) {
      if (elem.children.length > 0 && (elem.children[0].type === "text" || elem.children[0].type === "cdata")) {
        return elem.children[0].value;
      }
      return "";
    }
    function setCssStr(elem, css) {
      if (elem.children.length === 0) {
        elem.children.push({
          type: "text",
          value: ""
        });
      }
      if (elem.children[0].type !== "text" && elem.children[0].type !== "cdata") {
        return css;
      }
      elem.children[0].value = css;
      return css;
    }
    module.exports.flattenToSelectors = flattenToSelectors;
    module.exports.filterByMqs = filterByMqs;
    module.exports.filterByPseudos = filterByPseudos;
    module.exports.cleanPseudos = cleanPseudos;
    module.exports.compareSpecificity = compareSpecificity;
    module.exports.compareSimpleSelectorNode = compareSimpleSelectorNode;
    module.exports.sortSelectors = sortSelectors;
    module.exports.csstreeToStyleDeclaration = csstreeToStyleDeclaration;
    module.exports.getCssStr = getCssStr;
    module.exports.setCssStr = setCssStr;
  }
});

// node_modules/svgo/lib/svgo/css-style-declaration.js
var require_css_style_declaration = __commonJS({
  "node_modules/svgo/lib/svgo/css-style-declaration.js"(exports, module) {
    "use strict";
    var csstree = require_lib9();
    var csstools = require_css_tools();
    var CSSStyleDeclaration = function(node) {
      this.parentNode = node;
      this.properties = /* @__PURE__ */ new Map();
      this.hasSynced = false;
      this.styleValue = null;
      this.parseError = false;
      const value = node.attributes.style;
      if (value != null) {
        this.addStyleValueHandler();
        this.setStyleValue(value);
      }
    };
    CSSStyleDeclaration.prototype.addStyleValueHandler = function() {
      Object.defineProperty(this.parentNode.attributes, "style", {
        get: this.getStyleValue.bind(this),
        set: this.setStyleValue.bind(this),
        enumerable: true,
        configurable: true
      });
    };
    CSSStyleDeclaration.prototype.getStyleValue = function() {
      return this.getCssText();
    };
    CSSStyleDeclaration.prototype.setStyleValue = function(newValue) {
      this.properties.clear();
      this.styleValue = newValue;
      this.hasSynced = false;
    };
    CSSStyleDeclaration.prototype._loadCssText = function() {
      if (this.hasSynced) {
        return;
      }
      this.hasSynced = true;
      if (!this.styleValue || this.styleValue.length === 0) {
        return;
      }
      var inlineCssStr = this.styleValue;
      var declarations = {};
      try {
        declarations = csstree.parse(inlineCssStr, {
          context: "declarationList",
          parseValue: false
        });
      } catch (parseError) {
        this.parseError = parseError;
        return;
      }
      this.parseError = false;
      var self2 = this;
      declarations.children.each(function(declaration) {
        try {
          var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
          self2.setProperty(
            styleDeclaration.name,
            styleDeclaration.value,
            styleDeclaration.priority
          );
        } catch (styleError) {
          if (styleError.message !== "Unknown node type: undefined") {
            self2.parseError = styleError;
          }
        }
      });
    };
    CSSStyleDeclaration.prototype.getCssText = function() {
      var properties = this.getProperties();
      if (this.parseError) {
        return this.styleValue;
      }
      var cssText = [];
      properties.forEach(function(property, propertyName) {
        var strImportant = property.priority === "important" ? "!important" : "";
        cssText.push(
          propertyName.trim() + ":" + property.value.trim() + strImportant
        );
      });
      return cssText.join(";");
    };
    CSSStyleDeclaration.prototype._handleParseError = function() {
      if (this.parseError) {
        console.warn(
          "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " + this.parseError
        );
      }
    };
    CSSStyleDeclaration.prototype._getProperty = function(propertyName) {
      if (typeof propertyName === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      var properties = this.getProperties();
      this._handleParseError();
      var property = properties.get(propertyName.trim());
      return property;
    };
    CSSStyleDeclaration.prototype.getPropertyPriority = function(propertyName) {
      var property = this._getProperty(propertyName);
      return property ? property.priority : "";
    };
    CSSStyleDeclaration.prototype.getPropertyValue = function(propertyName) {
      var property = this._getProperty(propertyName);
      return property ? property.value : null;
    };
    CSSStyleDeclaration.prototype.item = function(index) {
      if (typeof index === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      var properties = this.getProperties();
      this._handleParseError();
      return Array.from(properties.keys())[index];
    };
    CSSStyleDeclaration.prototype.getProperties = function() {
      this._loadCssText();
      return this.properties;
    };
    CSSStyleDeclaration.prototype.removeProperty = function(propertyName) {
      if (typeof propertyName === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      this.addStyleValueHandler();
      var properties = this.getProperties();
      this._handleParseError();
      var oldValue = this.getPropertyValue(propertyName);
      properties.delete(propertyName.trim());
      return oldValue;
    };
    CSSStyleDeclaration.prototype.setProperty = function(propertyName, value, priority) {
      if (typeof propertyName === "undefined") {
        throw Error("propertyName argument required, but only not present.");
      }
      this.addStyleValueHandler();
      var properties = this.getProperties();
      this._handleParseError();
      var property = {
        value: value.trim(),
        priority: priority.trim()
      };
      properties.set(propertyName.trim(), property);
      return property;
    };
    module.exports = CSSStyleDeclaration;
  }
});

// node_modules/svgo/lib/svgo/jsAPI.js
var require_jsAPI = __commonJS({
  "node_modules/svgo/lib/svgo/jsAPI.js"(exports, module) {
    "use strict";
    var { selectAll, selectOne, is } = require_lib8();
    var svgoCssSelectAdapter = require_css_select_adapter();
    var CSSClassList = require_css_class_list();
    var CSSStyleDeclaration = require_css_style_declaration();
    var parseName = (name) => {
      if (name == null) {
        return {
          prefix: "",
          local: ""
        };
      }
      if (name === "xmlns") {
        return {
          prefix: "xmlns",
          local: ""
        };
      }
      const chunks = name.split(":");
      if (chunks.length === 1) {
        return {
          prefix: "",
          local: chunks[0]
        };
      }
      return {
        prefix: chunks[0],
        local: chunks[1]
      };
    };
    var cssSelectOpts = {
      xmlMode: true,
      adapter: svgoCssSelectAdapter
    };
    var attrsHandler = {
      get: (attributes, name) => {
        if (attributes.hasOwnProperty(name)) {
          return {
            name,
            get value() {
              return attributes[name];
            },
            set value(value) {
              attributes[name] = value;
            }
          };
        }
      },
      set: (attributes, name, attr) => {
        attributes[name] = attr.value;
        return true;
      }
    };
    var JSAPI = function(data, parentNode) {
      Object.assign(this, data);
      if (this.type === "element") {
        if (this.attributes == null) {
          this.attributes = {};
        }
        if (this.children == null) {
          this.children = [];
        }
        Object.defineProperty(this, "class", {
          writable: true,
          configurable: true,
          value: new CSSClassList(this)
        });
        Object.defineProperty(this, "style", {
          writable: true,
          configurable: true,
          value: new CSSStyleDeclaration(this)
        });
        Object.defineProperty(this, "parentNode", {
          writable: true,
          value: parentNode
        });
        const element = this;
        Object.defineProperty(this, "attrs", {
          configurable: true,
          get() {
            return new Proxy(element.attributes, attrsHandler);
          },
          set(value) {
            const newAttributes = {};
            for (const attr of Object.values(value)) {
              newAttributes[attr.name] = attr.value;
            }
            element.attributes = newAttributes;
          }
        });
      }
    };
    module.exports = JSAPI;
    JSAPI.prototype.clone = function() {
      const { children, ...nodeData } = this;
      const clonedNode = new JSAPI(JSON.parse(JSON.stringify(nodeData)), null);
      if (children) {
        clonedNode.children = children.map((child) => {
          const clonedChild = child.clone();
          clonedChild.parentNode = clonedNode;
          return clonedChild;
        });
      }
      return clonedNode;
    };
    JSAPI.prototype.isElem = function(param) {
      if (this.type !== "element") {
        return false;
      }
      if (param == null) {
        return true;
      }
      if (Array.isArray(param)) {
        return param.includes(this.name);
      }
      return this.name === param;
    };
    JSAPI.prototype.renameElem = function(name) {
      if (name && typeof name === "string")
        this.name = name;
      return this;
    };
    JSAPI.prototype.isEmpty = function() {
      return !this.children || !this.children.length;
    };
    JSAPI.prototype.closestElem = function(elemName) {
      var elem = this;
      while ((elem = elem.parentNode) && !elem.isElem(elemName))
        ;
      return elem;
    };
    JSAPI.prototype.spliceContent = function(start, n2, insertion) {
      if (arguments.length < 2)
        return [];
      if (!Array.isArray(insertion))
        insertion = Array.apply(null, arguments).slice(2);
      insertion.forEach(function(inner) {
        inner.parentNode = this;
      }, this);
      return this.children.splice.apply(
        this.children,
        [start, n2].concat(insertion)
      );
    };
    JSAPI.prototype.hasAttr = function(name, val) {
      if (this.type !== "element") {
        return false;
      }
      if (Object.keys(this.attributes).length === 0) {
        return false;
      }
      if (name == null) {
        return true;
      }
      if (this.attributes.hasOwnProperty(name) === false) {
        return false;
      }
      if (val !== void 0) {
        return this.attributes[name] === val.toString();
      }
      return true;
    };
    JSAPI.prototype.hasAttrLocal = function(localName, val) {
      if (!this.attrs || !Object.keys(this.attrs).length)
        return false;
      if (!arguments.length)
        return !!this.attrs;
      var callback;
      switch (val != null && val.constructor && val.constructor.name) {
        case "Number":
        case "String":
          callback = stringValueTest;
          break;
        case "RegExp":
          callback = regexpValueTest;
          break;
        case "Function":
          callback = funcValueTest;
          break;
        default:
          callback = nameTest;
      }
      return this.someAttr(callback);
      function nameTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName;
      }
      function stringValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val == attr.value;
      }
      function regexpValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val.test(attr.value);
      }
      function funcValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val(attr.value);
      }
    };
    JSAPI.prototype.attr = function(name, val) {
      if (this.hasAttr(name, val)) {
        return this.attrs[name];
      }
    };
    JSAPI.prototype.computedAttr = function(name, val) {
      if (!arguments.length)
        return;
      for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attributes[name]); elem = elem.parentNode)
        ;
      if (val != null) {
        return elem ? elem.hasAttr(name, val) : false;
      } else if (elem && elem.hasAttr(name)) {
        return elem.attributes[name];
      }
    };
    JSAPI.prototype.removeAttr = function(name, val) {
      if (this.type !== "element") {
        return false;
      }
      if (arguments.length === 0) {
        return false;
      }
      if (Array.isArray(name)) {
        for (const nameItem of name) {
          this.removeAttr(nameItem, val);
        }
        return false;
      }
      if (this.hasAttr(name, val) === false) {
        return false;
      }
      delete this.attributes[name];
      return true;
    };
    JSAPI.prototype.addAttr = function(attr) {
      attr = attr || {};
      if (attr.name === void 0)
        return false;
      this.attributes[attr.name] = attr.value;
      if (attr.name === "class") {
        this.class.addClassValueHandler();
      }
      if (attr.name === "style") {
        this.style.addStyleValueHandler();
      }
      return this.attrs[attr.name];
    };
    JSAPI.prototype.eachAttr = function(callback, context) {
      if (this.type !== "element") {
        return false;
      }
      if (callback == null) {
        return false;
      }
      for (const attr of Object.values(this.attrs)) {
        callback.call(context, attr);
      }
      return true;
    };
    JSAPI.prototype.someAttr = function(callback, context) {
      if (this.type !== "element") {
        return false;
      }
      for (const attr of Object.values(this.attrs)) {
        if (callback.call(context, attr))
          return true;
      }
      return false;
    };
    JSAPI.prototype.querySelectorAll = function(selectors) {
      var matchedEls = selectAll(selectors, this, cssSelectOpts);
      return matchedEls.length > 0 ? matchedEls : null;
    };
    JSAPI.prototype.querySelector = function(selectors) {
      return selectOne(selectors, this, cssSelectOpts);
    };
    JSAPI.prototype.matches = function(selector) {
      return is(this, selector, cssSelectOpts);
    };
  }
});

// node_modules/svgo/plugins/mergeStyles.js
var require_mergeStyles = __commonJS({
  "node_modules/svgo/plugins/mergeStyles.js"(exports) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var JSAPI = require_jsAPI();
    exports.name = "mergeStyles";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "merge multiple style elements into one";
    exports.fn = () => {
      let firstStyleElement = null;
      let collectedStyles = "";
      let styleContentType = "text";
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style") {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            let css = "";
            for (const child of node.children) {
              if (child.type === "text") {
                css += child.value;
              }
              if (child.type === "cdata") {
                styleContentType = "cdata";
                css += child.value;
              }
            }
            if (css.trim().length === 0) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (node.attributes.media == null) {
              collectedStyles += css;
            } else {
              collectedStyles += `@media ${node.attributes.media}{${css}}`;
              delete node.attributes.media;
            }
            if (firstStyleElement == null) {
              firstStyleElement = node;
            } else {
              detachNodeFromParent(node, parentNode);
              firstStyleElement.children = [
                new JSAPI(
                  { type: styleContentType, value: collectedStyles },
                  firstStyleElement
                )
              ];
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/inlineStyles.js
var require_inlineStyles = __commonJS({
  "node_modules/svgo/plugins/inlineStyles.js"(exports) {
    "use strict";
    var csstree = require_lib9();
    var specificity = require_specificity();
    var stable = require_stable();
    var {
      visitSkip,
      querySelectorAll,
      detachNodeFromParent
    } = require_xast();
    exports.type = "visitor";
    exports.name = "inlineStyles";
    exports.active = true;
    exports.description = "inline styles (additional options)";
    var compareSpecificity = (a2, b2) => {
      for (var i2 = 0; i2 < 4; i2 += 1) {
        if (a2[i2] < b2[i2]) {
          return -1;
        } else if (a2[i2] > b2[i2]) {
          return 1;
        }
      }
      return 0;
    };
    exports.fn = (root, params) => {
      const {
        onlyMatchedOnce = true,
        removeMatchedSelectors = true,
        useMqs = ["", "screen"],
        usePseudos = [""]
      } = params;
      const styles = [];
      let selectors = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style" || node.children.length === 0) {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            let cssText = "";
            for (const child of node.children) {
              if (child.type === "text" || child.type === "cdata") {
                cssText += child.value;
              }
            }
            let cssAst = null;
            try {
              cssAst = csstree.parse(cssText, {
                parseValue: false,
                parseCustomProperty: false
              });
            } catch {
              return;
            }
            if (cssAst.type === "StyleSheet") {
              styles.push({ node, parentNode, cssAst });
            }
            csstree.walk(cssAst, {
              visit: "Selector",
              enter(node2, item) {
                const atrule = this.atrule;
                const rule = this.rule;
                if (rule == null) {
                  return;
                }
                let mq = "";
                if (atrule != null) {
                  mq = atrule.name;
                  if (atrule.prelude != null) {
                    mq += ` ${csstree.generate(atrule.prelude)}`;
                  }
                }
                if (useMqs.includes(mq) === false) {
                  return;
                }
                const pseudos = [];
                if (node2.type === "Selector") {
                  node2.children.each((childNode, childItem, childList) => {
                    if (childNode.type === "PseudoClassSelector" || childNode.type === "PseudoElementSelector") {
                      pseudos.push({ item: childItem, list: childList });
                    }
                  });
                }
                const pseudoSelectors = csstree.generate({
                  type: "Selector",
                  children: new csstree.List().fromArray(
                    pseudos.map((pseudo) => pseudo.item.data)
                  )
                });
                if (usePseudos.includes(pseudoSelectors) === false) {
                  return;
                }
                for (const pseudo of pseudos) {
                  pseudo.list.remove(pseudo.item);
                }
                selectors.push({ node: node2, item, rule });
              }
            });
          }
        },
        root: {
          exit: () => {
            if (styles.length === 0) {
              return;
            }
            const sortedSelectors = stable(selectors, (a2, b2) => {
              const aSpecificity = specificity(a2.item.data);
              const bSpecificity = specificity(b2.item.data);
              return compareSpecificity(aSpecificity, bSpecificity);
            }).reverse();
            for (const selector of sortedSelectors) {
              const selectorText = csstree.generate(selector.item.data);
              const matchedElements = [];
              try {
                for (const node of querySelectorAll(root, selectorText)) {
                  if (node.type === "element") {
                    matchedElements.push(node);
                  }
                }
              } catch (selectError) {
                continue;
              }
              if (matchedElements.length === 0) {
                continue;
              }
              if (onlyMatchedOnce && matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of matchedElements) {
                const styleDeclarationList = csstree.parse(
                  selectedEl.attributes.style == null ? "" : selectedEl.attributes.style,
                  {
                    context: "declarationList",
                    parseValue: false
                  }
                );
                if (styleDeclarationList.type !== "DeclarationList") {
                  continue;
                }
                const styleDeclarationItems = /* @__PURE__ */ new Map();
                csstree.walk(styleDeclarationList, {
                  visit: "Declaration",
                  enter(node, item) {
                    styleDeclarationItems.set(node.property, item);
                  }
                });
                csstree.walk(selector.rule, {
                  visit: "Declaration",
                  enter(ruleDeclaration) {
                    const matchedItem = styleDeclarationItems.get(
                      ruleDeclaration.property
                    );
                    const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);
                    if (matchedItem == null) {
                      styleDeclarationList.children.append(ruleDeclarationItem);
                    } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {
                      styleDeclarationList.children.replace(
                        matchedItem,
                        ruleDeclarationItem
                      );
                      styleDeclarationItems.set(
                        ruleDeclaration.property,
                        ruleDeclarationItem
                      );
                    }
                  }
                });
                selectedEl.attributes.style = csstree.generate(styleDeclarationList);
              }
              if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === "SelectorList") {
                selector.rule.prelude.children.remove(selector.item);
              }
              selector.matchedElements = matchedElements;
            }
            if (removeMatchedSelectors === false) {
              return;
            }
            for (const selector of sortedSelectors) {
              if (selector.matchedElements == null) {
                continue;
              }
              if (onlyMatchedOnce && selector.matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of selector.matchedElements) {
                const classList = new Set(
                  selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(" ")
                );
                const firstSubSelector = selector.node.children.first();
                if (firstSubSelector != null && firstSubSelector.type === "ClassSelector") {
                  classList.delete(firstSubSelector.name);
                }
                if (classList.size === 0) {
                  delete selectedEl.attributes.class;
                } else {
                  selectedEl.attributes.class = Array.from(classList).join(" ");
                }
                if (firstSubSelector != null && firstSubSelector.type === "IdSelector") {
                  if (selectedEl.attributes.id === firstSubSelector.name) {
                    delete selectedEl.attributes.id;
                  }
                }
              }
            }
            for (const style of styles) {
              csstree.walk(style.cssAst, {
                visit: "Rule",
                enter: function(node, item, list) {
                  if (node.type === "Rule" && node.prelude.type === "SelectorList" && node.prelude.children.isEmpty()) {
                    list.remove(item);
                  }
                }
              });
              if (style.cssAst.children.isEmpty()) {
                detachNodeFromParent(style.node, style.parentNode);
              } else {
                const firstChild = style.node.children[0];
                if (firstChild.type === "text" || firstChild.type === "cdata") {
                  firstChild.value = csstree.generate(style.cssAst);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/csso/lib/usage.js
var require_usage = __commonJS({
  "node_modules/csso/lib/usage.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function buildMap(list, caseInsensitive) {
      var map2 = /* @__PURE__ */ Object.create(null);
      if (!Array.isArray(list)) {
        return null;
      }
      for (var i2 = 0; i2 < list.length; i2++) {
        var name = list[i2];
        if (caseInsensitive) {
          name = name.toLowerCase();
        }
        map2[name] = true;
      }
      return map2;
    }
    function buildList(data) {
      if (!data) {
        return null;
      }
      var tags2 = buildMap(data.tags, true);
      var ids = buildMap(data.ids);
      var classes = buildMap(data.classes);
      if (tags2 === null && ids === null && classes === null) {
        return null;
      }
      return {
        tags: tags2,
        ids,
        classes
      };
    }
    function buildIndex(data) {
      var scopes = false;
      if (data.scopes && Array.isArray(data.scopes)) {
        scopes = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < data.scopes.length; i2++) {
          var list = data.scopes[i2];
          if (!list || !Array.isArray(list)) {
            throw new Error("Wrong usage format");
          }
          for (var j2 = 0; j2 < list.length; j2++) {
            var name = list[j2];
            if (hasOwnProperty2.call(scopes, name)) {
              throw new Error("Class can't be used for several scopes: " + name);
            }
            scopes[name] = i2 + 1;
          }
        }
      }
      return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes
      };
    }
    module.exports = {
      buildIndex
    };
  }
});

// node_modules/csso/lib/clean/utils.js
var require_utils3 = __commonJS({
  "node_modules/csso/lib/clean/utils.js"(exports, module) {
    module.exports = {
      hasNoChildren: function(node) {
        return !node || !node.children || node.children.isEmpty();
      },
      isNodeChildrenList: function(node, list) {
        return node !== null && node.children === list;
      }
    };
  }
});

// node_modules/csso/lib/clean/Atrule.js
var require_Atrule2 = __commonJS({
  "node_modules/csso/lib/clean/Atrule.js"(exports, module) {
    var resolveKeyword = require_lib9().keyword;
    var { hasNoChildren } = require_utils3();
    module.exports = function cleanAtrule(node, item, list) {
      if (node.block) {
        if (this.stylesheet !== null) {
          this.stylesheet.firstAtrulesAllowed = false;
        }
        if (hasNoChildren(node.block)) {
          list.remove(item);
          return;
        }
      }
      switch (node.name) {
        case "charset":
          if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
          }
          if (item.prev) {
            list.remove(item);
            return;
          }
          break;
        case "import":
          if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
            list.remove(item);
            return;
          }
          list.prevUntil(item.prev, function(rule) {
            if (rule.type === "Atrule") {
              if (rule.name === "import" || rule.name === "charset") {
                return;
              }
            }
            this.root.firstAtrulesAllowed = false;
            list.remove(item);
            return true;
          }, this);
          break;
        default:
          var name = resolveKeyword(node.name).basename;
          if (name === "keyframes" || name === "media" || name === "supports") {
            if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
              list.remove(item);
            }
          }
      }
    };
  }
});

// node_modules/csso/lib/clean/Comment.js
var require_Comment2 = __commonJS({
  "node_modules/csso/lib/clean/Comment.js"(exports, module) {
    module.exports = function cleanComment(data, item, list) {
      list.remove(item);
    };
  }
});

// node_modules/csso/lib/clean/Declaration.js
var require_Declaration2 = __commonJS({
  "node_modules/csso/lib/clean/Declaration.js"(exports, module) {
    var property = require_lib9().property;
    module.exports = function cleanDeclartion(node, item, list) {
      if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
        return;
      }
      if (property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
          node.value.value = node.value.value.trim();
        }
      }
    };
  }
});

// node_modules/csso/lib/clean/Raw.js
var require_Raw2 = __commonJS({
  "node_modules/csso/lib/clean/Raw.js"(exports, module) {
    var { isNodeChildrenList } = require_utils3();
    module.exports = function cleanRaw(node, item, list) {
      if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
        list.remove(item);
      }
    };
  }
});

// node_modules/csso/lib/clean/Rule.js
var require_Rule2 = __commonJS({
  "node_modules/csso/lib/clean/Rule.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var walk = require_lib9().walk;
    var { hasNoChildren } = require_utils3();
    function cleanUnused(selectorList, usageData) {
      selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;
        walk(selector, function(node) {
          if (this.selector === null || this.selector === selectorList) {
            switch (node.type) {
              case "SelectorList":
                if (this.function === null || this.function.name.toLowerCase() !== "not") {
                  if (cleanUnused(node, usageData)) {
                    shouldRemove = true;
                  }
                }
                break;
              case "ClassSelector":
                if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty2.call(usageData.whitelist.classes, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty2.call(usageData.blacklist.classes, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "IdSelector":
                if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty2.call(usageData.whitelist.ids, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty2.call(usageData.blacklist.ids, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "TypeSelector":
                if (node.name.charAt(node.name.length - 1) !== "*") {
                  if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty2.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                  if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty2.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                }
                break;
            }
          }
        });
        if (shouldRemove) {
          list.remove(item);
        }
      });
      return selectorList.children.isEmpty();
    }
    module.exports = function cleanRule(node, item, list, options) {
      if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
      }
      var usageData = options.usage;
      if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);
        if (hasNoChildren(node.prelude)) {
          list.remove(item);
          return;
        }
      }
    };
  }
});

// node_modules/csso/lib/clean/TypeSelector.js
var require_TypeSelector2 = __commonJS({
  "node_modules/csso/lib/clean/TypeSelector.js"(exports, module) {
    module.exports = function cleanTypeSelector(node, item, list) {
      var name = item.data.name;
      if (name !== "*") {
        return;
      }
      var nextType = item.next && item.next.data.type;
      if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
        list.remove(item);
      }
    };
  }
});

// node_modules/csso/lib/clean/WhiteSpace.js
var require_WhiteSpace2 = __commonJS({
  "node_modules/csso/lib/clean/WhiteSpace.js"(exports, module) {
    var { isNodeChildrenList } = require_utils3();
    function isSafeOperator(node) {
      return node.type === "Operator" && node.value !== "+" && node.value !== "-";
    }
    module.exports = function cleanWhitespace(node, item, list) {
      if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
      }
      if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
        list.remove(item);
        return;
      }
      if (item.next.data.type === "WhiteSpace") {
        list.remove(item);
        return;
      }
      if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
        list.remove(item);
        return;
      }
    };
  }
});

// node_modules/csso/lib/clean/index.js
var require_clean = __commonJS({
  "node_modules/csso/lib/clean/index.js"(exports, module) {
    var walk = require_lib9().walk;
    var handlers = {
      Atrule: require_Atrule2(),
      Comment: require_Comment2(),
      Declaration: require_Declaration2(),
      Raw: require_Raw2(),
      Rule: require_Rule2(),
      TypeSelector: require_TypeSelector2(),
      WhiteSpace: require_WhiteSpace2()
    };
    module.exports = function(ast, options) {
      walk(ast, {
        leave: function(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list, options);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/replace/atrule/keyframes.js
var require_keyframes = __commonJS({
  "node_modules/csso/lib/replace/atrule/keyframes.js"(exports, module) {
    module.exports = function(node) {
      node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
          simpleselector.children.each(function(data, item) {
            if (data.type === "Percentage" && data.value === "100") {
              item.data = {
                type: "TypeSelector",
                loc: data.loc,
                name: "to"
              };
            } else if (data.type === "TypeSelector" && data.name === "from") {
              item.data = {
                type: "Percentage",
                loc: data.loc,
                value: "0"
              };
            }
          });
        });
      });
    };
  }
});

// node_modules/csso/lib/replace/Atrule.js
var require_Atrule3 = __commonJS({
  "node_modules/csso/lib/replace/Atrule.js"(exports, module) {
    var resolveKeyword = require_lib9().keyword;
    var compressKeyframes = require_keyframes();
    module.exports = function(node) {
      if (resolveKeyword(node.name).basename === "keyframes") {
        compressKeyframes(node);
      }
    };
  }
});

// node_modules/csso/lib/replace/AttributeSelector.js
var require_AttributeSelector2 = __commonJS({
  "node_modules/csso/lib/replace/AttributeSelector.js"(exports, module) {
    var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
    var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
    function canUnquote(value) {
      if (value === "" || value === "-") {
        return;
      }
      value = value.replace(escapesRx, "a");
      return !blockUnquoteRx.test(value);
    }
    module.exports = function(node) {
      var attrValue = node.value;
      if (!attrValue || attrValue.type !== "String") {
        return;
      }
      var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, "$2");
      if (canUnquote(unquotedValue)) {
        node.value = {
          type: "Identifier",
          loc: attrValue.loc,
          name: unquotedValue
        };
      }
    };
  }
});

// node_modules/csso/lib/replace/property/font.js
var require_font = __commonJS({
  "node_modules/csso/lib/replace/property/font.js"(exports, module) {
    module.exports = function compressFont(node) {
      var list = node.children;
      list.eachRight(function(node2, item) {
        if (node2.type === "Identifier") {
          if (node2.name === "bold") {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "700"
            };
          } else if (node2.name === "normal") {
            var prev = item.prev;
            if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
              this.remove(prev);
            }
            this.remove(item);
          } else if (node2.name === "medium") {
            var next = item.next;
            if (!next || next.data.type !== "Operator") {
              this.remove(item);
            }
          }
        }
      });
      list.each(function(node2, item) {
        if (node2.type === "WhiteSpace") {
          if (!item.prev || !item.next || item.next.data.type === "WhiteSpace") {
            this.remove(item);
          }
        }
      });
      if (list.isEmpty()) {
        list.insert(list.createItem({
          type: "Identifier",
          name: "normal"
        }));
      }
    };
  }
});

// node_modules/csso/lib/replace/property/font-weight.js
var require_font_weight = __commonJS({
  "node_modules/csso/lib/replace/property/font-weight.js"(exports, module) {
    module.exports = function compressFontWeight(node) {
      var value = node.children.head.data;
      if (value.type === "Identifier") {
        switch (value.name) {
          case "normal":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "400"
            };
            break;
          case "bold":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "700"
            };
            break;
        }
      }
    };
  }
});

// node_modules/csso/lib/replace/property/background.js
var require_background = __commonJS({
  "node_modules/csso/lib/replace/property/background.js"(exports, module) {
    var List = require_lib9().List;
    module.exports = function compressBackground(node) {
      function lastType() {
        if (buffer.length) {
          return buffer[buffer.length - 1].type;
        }
      }
      function flush() {
        if (lastType() === "WhiteSpace") {
          buffer.pop();
        }
        if (!buffer.length) {
          buffer.unshift(
            {
              type: "Number",
              loc: null,
              value: "0"
            },
            {
              type: "WhiteSpace",
              value: " "
            },
            {
              type: "Number",
              loc: null,
              value: "0"
            }
          );
        }
        newValue.push.apply(newValue, buffer);
        buffer = [];
      }
      var newValue = [];
      var buffer = [];
      node.children.each(function(node2) {
        if (node2.type === "Operator" && node2.value === ",") {
          flush();
          newValue.push(node2);
          return;
        }
        if (node2.type === "Identifier") {
          if (node2.name === "transparent" || node2.name === "none" || node2.name === "repeat" || node2.name === "scroll") {
            return;
          }
        }
        if (node2.type === "WhiteSpace" && (!buffer.length || lastType() === "WhiteSpace")) {
          return;
        }
        buffer.push(node2);
      });
      flush();
      node.children = new List().fromArray(newValue);
    };
  }
});

// node_modules/csso/lib/replace/property/border.js
var require_border = __commonJS({
  "node_modules/csso/lib/replace/property/border.js"(exports, module) {
    function removeItemAndRedundantWhiteSpace(list, item) {
      var prev = item.prev;
      var next = item.next;
      if (next !== null) {
        if (next.data.type === "WhiteSpace" && (prev === null || prev.data.type === "WhiteSpace")) {
          list.remove(next);
        }
      } else if (prev !== null && prev.data.type === "WhiteSpace") {
        list.remove(prev);
      }
      list.remove(item);
    }
    module.exports = function compressBorder(node) {
      node.children.each(function(node2, item, list) {
        if (node2.type === "Identifier" && node2.name.toLowerCase() === "none") {
          if (list.head === list.tail) {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "0"
            };
          } else {
            removeItemAndRedundantWhiteSpace(list, item);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/replace/Value.js
var require_Value2 = __commonJS({
  "node_modules/csso/lib/replace/Value.js"(exports, module) {
    var resolveName = require_lib9().property;
    var handlers = {
      "font": require_font(),
      "font-weight": require_font_weight(),
      "background": require_background(),
      "border": require_border(),
      "outline": require_border()
    };
    module.exports = function compressValue(node) {
      if (!this.declaration) {
        return;
      }
      var property = resolveName(this.declaration.property);
      if (handlers.hasOwnProperty(property.basename)) {
        handlers[property.basename](node);
      }
    };
  }
});

// node_modules/csso/lib/replace/Number.js
var require_Number2 = __commonJS({
  "node_modules/csso/lib/replace/Number.js"(exports, module) {
    var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var unsafeToRemovePlusSignAfter = {
      Dimension: true,
      Hash: true,
      Identifier: true,
      Number: true,
      Raw: true,
      UnicodeRange: true
    };
    function packNumber(value, item) {
      var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN;
      value = String(value).replace(regexp, "$1$2$3");
      if (value === "" || value === "-") {
        value = "0";
      }
      return value;
    }
    module.exports = function(node, item) {
      node.value = packNumber(node.value, item);
    };
    module.exports.pack = packNumber;
  }
});

// node_modules/csso/lib/replace/Dimension.js
var require_Dimension2 = __commonJS({
  "node_modules/csso/lib/replace/Dimension.js"(exports, module) {
    var packNumber = require_Number2().pack;
    var MATH_FUNCTIONS = {
      "calc": true,
      "min": true,
      "max": true,
      "clamp": true
    };
    var LENGTH_UNIT = {
      "px": true,
      "mm": true,
      "cm": true,
      "in": true,
      "pt": true,
      "pc": true,
      "em": true,
      "ex": true,
      "ch": true,
      "rem": true,
      "vh": true,
      "vw": true,
      "vmin": true,
      "vmax": true,
      "vm": true
    };
    module.exports = function compressDimension(node, item) {
      var value = packNumber(node.value, item);
      node.value = value;
      if (value === "0" && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
          return;
        }
        if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
          return;
        }
        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
          return;
        }
        item.data = {
          type: "Number",
          loc: node.loc,
          value
        };
      }
    };
  }
});

// node_modules/csso/lib/replace/Percentage.js
var require_Percentage2 = __commonJS({
  "node_modules/csso/lib/replace/Percentage.js"(exports, module) {
    var lexer = require_lib9().lexer;
    var packNumber = require_Number2().pack;
    var blacklist = /* @__PURE__ */ new Set([
      "width",
      "min-width",
      "max-width",
      "height",
      "min-height",
      "max-height",
      "flex",
      "-ms-flex"
    ]);
    module.exports = function compressPercentage(node, item) {
      node.value = packNumber(node.value, item);
      if (node.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
        item.data = {
          type: "Number",
          loc: node.loc,
          value: node.value
        };
        if (!lexer.matchDeclaration(this.declaration).isType(item.data, "length")) {
          item.data = node;
        }
      }
    };
  }
});

// node_modules/csso/lib/replace/String.js
var require_String2 = __commonJS({
  "node_modules/csso/lib/replace/String.js"(exports, module) {
    module.exports = function(node) {
      var value = node.value;
      value = value.replace(/\\(\r\n|\r|\n|\f)/g, "");
      node.value = value;
    };
  }
});

// node_modules/csso/lib/replace/Url.js
var require_Url2 = __commonJS({
  "node_modules/csso/lib/replace/Url.js"(exports, module) {
    var UNICODE = "\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?";
    var ESCAPE = "(" + UNICODE + "|\\\\[^\\n\\r\\f0-9a-fA-F])";
    var NONPRINTABLE = "\0\b\v-\x7F";
    var SAFE_URL = new RegExp("^(" + ESCAPE + `|[^"'\\(\\)\\\\\\s` + NONPRINTABLE + "])*$", "i");
    module.exports = function(node) {
      var value = node.value;
      if (value.type !== "String") {
        return;
      }
      var quote = value.value[0];
      var url = value.value.substr(1, value.value.length - 2);
      url = url.replace(/\\\\/g, "/");
      if (SAFE_URL.test(url)) {
        node.value = {
          type: "Raw",
          loc: node.value.loc,
          value: url
        };
      } else {
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
      }
    };
  }
});

// node_modules/csso/lib/replace/color.js
var require_color = __commonJS({
  "node_modules/csso/lib/replace/color.js"(exports, module) {
    var lexer = require_lib9().lexer;
    var packNumber = require_Number2().pack;
    var NAME_TO_HEX = {
      "aliceblue": "f0f8ff",
      "antiquewhite": "faebd7",
      "aqua": "0ff",
      "aquamarine": "7fffd4",
      "azure": "f0ffff",
      "beige": "f5f5dc",
      "bisque": "ffe4c4",
      "black": "000",
      "blanchedalmond": "ffebcd",
      "blue": "00f",
      "blueviolet": "8a2be2",
      "brown": "a52a2a",
      "burlywood": "deb887",
      "cadetblue": "5f9ea0",
      "chartreuse": "7fff00",
      "chocolate": "d2691e",
      "coral": "ff7f50",
      "cornflowerblue": "6495ed",
      "cornsilk": "fff8dc",
      "crimson": "dc143c",
      "cyan": "0ff",
      "darkblue": "00008b",
      "darkcyan": "008b8b",
      "darkgoldenrod": "b8860b",
      "darkgray": "a9a9a9",
      "darkgrey": "a9a9a9",
      "darkgreen": "006400",
      "darkkhaki": "bdb76b",
      "darkmagenta": "8b008b",
      "darkolivegreen": "556b2f",
      "darkorange": "ff8c00",
      "darkorchid": "9932cc",
      "darkred": "8b0000",
      "darksalmon": "e9967a",
      "darkseagreen": "8fbc8f",
      "darkslateblue": "483d8b",
      "darkslategray": "2f4f4f",
      "darkslategrey": "2f4f4f",
      "darkturquoise": "00ced1",
      "darkviolet": "9400d3",
      "deeppink": "ff1493",
      "deepskyblue": "00bfff",
      "dimgray": "696969",
      "dimgrey": "696969",
      "dodgerblue": "1e90ff",
      "firebrick": "b22222",
      "floralwhite": "fffaf0",
      "forestgreen": "228b22",
      "fuchsia": "f0f",
      "gainsboro": "dcdcdc",
      "ghostwhite": "f8f8ff",
      "gold": "ffd700",
      "goldenrod": "daa520",
      "gray": "808080",
      "grey": "808080",
      "green": "008000",
      "greenyellow": "adff2f",
      "honeydew": "f0fff0",
      "hotpink": "ff69b4",
      "indianred": "cd5c5c",
      "indigo": "4b0082",
      "ivory": "fffff0",
      "khaki": "f0e68c",
      "lavender": "e6e6fa",
      "lavenderblush": "fff0f5",
      "lawngreen": "7cfc00",
      "lemonchiffon": "fffacd",
      "lightblue": "add8e6",
      "lightcoral": "f08080",
      "lightcyan": "e0ffff",
      "lightgoldenrodyellow": "fafad2",
      "lightgray": "d3d3d3",
      "lightgrey": "d3d3d3",
      "lightgreen": "90ee90",
      "lightpink": "ffb6c1",
      "lightsalmon": "ffa07a",
      "lightseagreen": "20b2aa",
      "lightskyblue": "87cefa",
      "lightslategray": "789",
      "lightslategrey": "789",
      "lightsteelblue": "b0c4de",
      "lightyellow": "ffffe0",
      "lime": "0f0",
      "limegreen": "32cd32",
      "linen": "faf0e6",
      "magenta": "f0f",
      "maroon": "800000",
      "mediumaquamarine": "66cdaa",
      "mediumblue": "0000cd",
      "mediumorchid": "ba55d3",
      "mediumpurple": "9370db",
      "mediumseagreen": "3cb371",
      "mediumslateblue": "7b68ee",
      "mediumspringgreen": "00fa9a",
      "mediumturquoise": "48d1cc",
      "mediumvioletred": "c71585",
      "midnightblue": "191970",
      "mintcream": "f5fffa",
      "mistyrose": "ffe4e1",
      "moccasin": "ffe4b5",
      "navajowhite": "ffdead",
      "navy": "000080",
      "oldlace": "fdf5e6",
      "olive": "808000",
      "olivedrab": "6b8e23",
      "orange": "ffa500",
      "orangered": "ff4500",
      "orchid": "da70d6",
      "palegoldenrod": "eee8aa",
      "palegreen": "98fb98",
      "paleturquoise": "afeeee",
      "palevioletred": "db7093",
      "papayawhip": "ffefd5",
      "peachpuff": "ffdab9",
      "peru": "cd853f",
      "pink": "ffc0cb",
      "plum": "dda0dd",
      "powderblue": "b0e0e6",
      "purple": "800080",
      "rebeccapurple": "639",
      "red": "f00",
      "rosybrown": "bc8f8f",
      "royalblue": "4169e1",
      "saddlebrown": "8b4513",
      "salmon": "fa8072",
      "sandybrown": "f4a460",
      "seagreen": "2e8b57",
      "seashell": "fff5ee",
      "sienna": "a0522d",
      "silver": "c0c0c0",
      "skyblue": "87ceeb",
      "slateblue": "6a5acd",
      "slategray": "708090",
      "slategrey": "708090",
      "snow": "fffafa",
      "springgreen": "00ff7f",
      "steelblue": "4682b4",
      "tan": "d2b48c",
      "teal": "008080",
      "thistle": "d8bfd8",
      "tomato": "ff6347",
      "turquoise": "40e0d0",
      "violet": "ee82ee",
      "wheat": "f5deb3",
      "white": "fff",
      "whitesmoke": "f5f5f5",
      "yellow": "ff0",
      "yellowgreen": "9acd32"
    };
    var HEX_TO_NAME = {
      "800000": "maroon",
      "800080": "purple",
      "808000": "olive",
      "808080": "gray",
      "00ffff": "cyan",
      "f0ffff": "azure",
      "f5f5dc": "beige",
      "ffe4c4": "bisque",
      "000000": "black",
      "0000ff": "blue",
      "a52a2a": "brown",
      "ff7f50": "coral",
      "ffd700": "gold",
      "008000": "green",
      "4b0082": "indigo",
      "fffff0": "ivory",
      "f0e68c": "khaki",
      "00ff00": "lime",
      "faf0e6": "linen",
      "000080": "navy",
      "ffa500": "orange",
      "da70d6": "orchid",
      "cd853f": "peru",
      "ffc0cb": "pink",
      "dda0dd": "plum",
      "f00": "red",
      "ff0000": "red",
      "fa8072": "salmon",
      "a0522d": "sienna",
      "c0c0c0": "silver",
      "fffafa": "snow",
      "d2b48c": "tan",
      "008080": "teal",
      "ff6347": "tomato",
      "ee82ee": "violet",
      "f5deb3": "wheat",
      "ffffff": "white",
      "ffff00": "yellow"
    };
    function hueToRgb(p2, q, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q - p2) * 6 * t2;
      }
      if (t2 < 1 / 2) {
        return q;
      }
      if (t2 < 2 / 3) {
        return p2 + (q - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s2, l2, a2) {
      var r2;
      var g2;
      var b2;
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q;
        r2 = hueToRgb(p2, q, h2 + 1 / 3);
        g2 = hueToRgb(p2, q, h2);
        b2 = hueToRgb(p2, q, h2 - 1 / 3);
      }
      return [
        Math.round(r2 * 255),
        Math.round(g2 * 255),
        Math.round(b2 * 255),
        a2
      ];
    }
    function toHex(value) {
      value = value.toString(16);
      return value.length === 1 ? "0" + value : value;
    }
    function parseFunctionArgs(functionArgs, count, rgb) {
      var cursor = functionArgs.head;
      var args = [];
      var wasValue = false;
      while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;
        switch (type) {
          case "Number":
          case "Percentage":
            if (wasValue) {
              return;
            }
            wasValue = true;
            args.push({
              type,
              value: Number(node.value)
            });
            break;
          case "Operator":
            if (node.value === ",") {
              if (!wasValue) {
                return;
              }
              wasValue = false;
            } else if (wasValue || node.value !== "+") {
              return;
            }
            break;
          default:
            return;
        }
        cursor = cursor.next;
      }
      if (args.length !== count) {
        return;
      }
      if (args.length === 4) {
        if (args[3].type !== "Number") {
          return;
        }
        args[3].type = "Alpha";
      }
      if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
          return;
        }
      } else {
        if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
          return;
        }
        args[0].type = "Angle";
      }
      return args.map(function(arg) {
        var value = Math.max(0, arg.value);
        switch (arg.type) {
          case "Number":
            value = Math.min(value, 255);
            break;
          case "Percentage":
            value = Math.min(value, 100) / 100;
            if (!rgb) {
              return value;
            }
            value = 255 * value;
            break;
          case "Angle":
            return (value % 360 + 360) % 360 / 360;
          case "Alpha":
            return Math.min(value, 1);
        }
        return Math.round(value);
      });
    }
    function compressFunction(node, item, list) {
      var functionName = node.name;
      var args;
      if (functionName === "rgba" || functionName === "hsla") {
        args = parseFunctionArgs(node.children, 4, functionName === "rgba");
        if (!args) {
          return;
        }
        if (functionName === "hsla") {
          args = hslToRgb.apply(null, args);
          node.name = "rgba";
        }
        if (args[3] === 0) {
          var scopeFunctionName = this.function && this.function.name;
          if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
            item.data = {
              type: "Identifier",
              loc: node.loc,
              name: "transparent"
            };
            return;
          }
        }
        if (args[3] !== 1) {
          node.children.each(function(node2, item2, list2) {
            if (node2.type === "Operator") {
              if (node2.value !== ",") {
                list2.remove(item2);
              }
              return;
            }
            item2.data = {
              type: "Number",
              loc: node2.loc,
              value: packNumber(args.shift(), null)
            };
          });
          return;
        }
        functionName = "rgb";
      }
      if (functionName === "hsl") {
        args = args || parseFunctionArgs(node.children, 3, false);
        if (!args) {
          return;
        }
        args = hslToRgb.apply(null, args);
        functionName = "rgb";
      }
      if (functionName === "rgb") {
        args = args || parseFunctionArgs(node.children, 3, true);
        if (!args) {
          return;
        }
        var next = item.next;
        if (next && next.data.type !== "WhiteSpace") {
          list.insert(list.createItem({
            type: "WhiteSpace",
            value: " "
          }), next);
        }
        item.data = {
          type: "Hash",
          loc: node.loc,
          value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };
        compressHex(item.data, item);
      }
    }
    function compressIdent(node, item) {
      if (this.declaration === null) {
        return;
      }
      var color = node.name.toLowerCase();
      if (NAME_TO_HEX.hasOwnProperty(color) && lexer.matchDeclaration(this.declaration).isType(node, "color")) {
        var hex = NAME_TO_HEX[color];
        if (hex.length + 1 <= color.length) {
          item.data = {
            type: "Hash",
            loc: node.loc,
            value: hex
          };
        } else {
          if (color === "grey") {
            color = "gray";
          }
          node.name = color;
        }
      }
    }
    function compressHex(node, item) {
      var color = node.value.toLowerCase();
      if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
      }
      if (HEX_TO_NAME[color]) {
        item.data = {
          type: "Identifier",
          loc: node.loc,
          name: HEX_TO_NAME[color]
        };
      } else {
        node.value = color;
      }
    }
    module.exports = {
      compressFunction,
      compressIdent,
      compressHex
    };
  }
});

// node_modules/csso/lib/replace/index.js
var require_replace = __commonJS({
  "node_modules/csso/lib/replace/index.js"(exports, module) {
    var walk = require_lib9().walk;
    var handlers = {
      Atrule: require_Atrule3(),
      AttributeSelector: require_AttributeSelector2(),
      Value: require_Value2(),
      Dimension: require_Dimension2(),
      Percentage: require_Percentage2(),
      Number: require_Number2(),
      String: require_String2(),
      Url: require_Url2(),
      Hash: require_color().compressHex,
      Identifier: require_color().compressIdent,
      Function: require_color().compressFunction
    };
    module.exports = function(ast) {
      walk(ast, {
        leave: function(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js
var require_createDeclarationIndexer = __commonJS({
  "node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js"(exports, module) {
    var generate = require_lib9().generate;
    function Index() {
      this.seed = 0;
      this.map = /* @__PURE__ */ Object.create(null);
    }
    Index.prototype.resolve = function(str) {
      var index = this.map[str];
      if (!index) {
        index = ++this.seed;
        this.map[str] = index;
      }
      return index;
    };
    module.exports = function createDeclarationIndexer() {
      var ids = new Index();
      return function markDeclaration(node) {
        var id = generate(node);
        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;
        return node;
      };
    };
  }
});

// node_modules/csso/lib/restructure/prepare/processSelector.js
var require_processSelector = __commonJS({
  "node_modules/csso/lib/restructure/prepare/processSelector.js"(exports, module) {
    var generate = require_lib9().generate;
    var specificity = require_specificity();
    var nonFreezePseudoElements = {
      "first-letter": true,
      "first-line": true,
      "after": true,
      "before": true
    };
    var nonFreezePseudoClasses = {
      "link": true,
      "visited": true,
      "hover": true,
      "active": true,
      "first-letter": true,
      "first-line": true,
      "after": true,
      "before": true
    };
    module.exports = function freeze(node, usageData) {
      var pseudos = /* @__PURE__ */ Object.create(null);
      var hasPseudo = false;
      node.prelude.children.each(function(simpleSelector) {
        var tagName = "*";
        var scope = 0;
        simpleSelector.children.each(function(node2) {
          switch (node2.type) {
            case "ClassSelector":
              if (usageData && usageData.scopes) {
                var classScope = usageData.scopes[node2.name] || 0;
                if (scope !== 0 && classScope !== scope) {
                  throw new Error("Selector can't has classes from different scopes: " + generate(simpleSelector));
                }
                scope = classScope;
              }
              break;
            case "PseudoClassSelector":
              var name = node2.name.toLowerCase();
              if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                pseudos[":" + name] = true;
                hasPseudo = true;
              }
              break;
            case "PseudoElementSelector":
              var name = node2.name.toLowerCase();
              if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                pseudos["::" + name] = true;
                hasPseudo = true;
              }
              break;
            case "TypeSelector":
              tagName = node2.name.toLowerCase();
              break;
            case "AttributeSelector":
              if (node2.flags) {
                pseudos["[" + node2.flags.toLowerCase() + "]"] = true;
                hasPseudo = true;
              }
              break;
            case "WhiteSpace":
            case "Combinator":
              tagName = "*";
              break;
          }
        });
        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null;
        simpleSelector.id = generate(simpleSelector);
        if (scope) {
          simpleSelector.compareMarker += ":" + scope;
        }
        if (tagName !== "*") {
          simpleSelector.compareMarker += "," + tagName;
        }
      });
      node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(",");
    };
  }
});

// node_modules/csso/lib/restructure/prepare/index.js
var require_prepare = __commonJS({
  "node_modules/csso/lib/restructure/prepare/index.js"(exports, module) {
    var resolveKeyword = require_lib9().keyword;
    var walk = require_lib9().walk;
    var generate = require_lib9().generate;
    var createDeclarationIndexer = require_createDeclarationIndexer();
    var processSelector = require_processSelector();
    module.exports = function prepare(ast, options) {
      var markDeclaration = createDeclarationIndexer();
      walk(ast, {
        visit: "Rule",
        enter: function processRule(node) {
          node.block.children.each(markDeclaration);
          processSelector(node, options.usage);
        }
      });
      walk(ast, {
        visit: "Atrule",
        enter: function(node) {
          if (node.prelude) {
            node.prelude.id = null;
            node.prelude.id = generate(node.prelude);
          }
          if (resolveKeyword(node.name).basename === "keyframes") {
            node.block.avoidRulesMerge = true;
            node.block.children.each(function(rule) {
              rule.prelude.children.each(function(simpleselector) {
                simpleselector.compareMarker = simpleselector.id;
              });
            });
          }
        }
      });
      return {
        declaration: markDeclaration
      };
    };
  }
});

// node_modules/csso/lib/restructure/1-mergeAtrule.js
var require_mergeAtrule = __commonJS({
  "node_modules/csso/lib/restructure/1-mergeAtrule.js"(exports, module) {
    var List = require_lib9().List;
    var resolveKeyword = require_lib9().keyword;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var walk = require_lib9().walk;
    function addRuleToMap(map2, item, list, single) {
      var node = item.data;
      var name = resolveKeyword(node.name).basename;
      var id = node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);
      if (!hasOwnProperty2.call(map2, name)) {
        map2[name] = /* @__PURE__ */ Object.create(null);
      }
      if (single) {
        delete map2[name][id];
      }
      if (!hasOwnProperty2.call(map2[name], id)) {
        map2[name][id] = new List();
      }
      map2[name][id].append(list.remove(item));
    }
    function relocateAtrules(ast, options) {
      var collected = /* @__PURE__ */ Object.create(null);
      var topInjectPoint = null;
      ast.children.each(function(node, item, list) {
        if (node.type === "Atrule") {
          var name = resolveKeyword(node.name).basename;
          switch (name) {
            case "keyframes":
              addRuleToMap(collected, item, list, true);
              return;
            case "media":
              if (options.forceMediaMerge) {
                addRuleToMap(collected, item, list, false);
                return;
              }
              break;
          }
          if (topInjectPoint === null && name !== "charset" && name !== "import") {
            topInjectPoint = item;
          }
        } else {
          if (topInjectPoint === null) {
            topInjectPoint = item;
          }
        }
      });
      for (var atrule in collected) {
        for (var id in collected[atrule]) {
          ast.children.insertList(
            collected[atrule][id],
            atrule === "media" ? null : topInjectPoint
          );
        }
      }
    }
    function isMediaRule(node) {
      return node.type === "Atrule" && node.name === "media";
    }
    function processAtrule(node, item, list) {
      if (!isMediaRule(node)) {
        return;
      }
      var prev = item.prev && item.prev.data;
      if (!prev || !isMediaRule(prev)) {
        return;
      }
      if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);
      }
    }
    module.exports = function rejoinAtrule(ast, options) {
      relocateAtrules(ast, options);
      walk(ast, {
        visit: "Atrule",
        reverse: true,
        enter: processAtrule
      });
    };
  }
});

// node_modules/csso/lib/restructure/utils.js
var require_utils4 = __commonJS({
  "node_modules/csso/lib/restructure/utils.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isEqualSelectors(a2, b2) {
      var cursor1 = a2.head;
      var cursor2 = b2.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function isEqualDeclarations(a2, b2) {
      var cursor1 = a2.head;
      var cursor2 = b2.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function compareDeclarations(declarations1, declarations2) {
      var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
      };
      var fingerprints = /* @__PURE__ */ Object.create(null);
      var declarations2hash = /* @__PURE__ */ Object.create(null);
      for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        declarations2hash[cursor.data.id] = true;
      }
      for (var cursor = declarations1.head; cursor; cursor = cursor.next) {
        var data = cursor.data;
        if (data.fingerprint) {
          fingerprints[data.fingerprint] = data.important;
        }
        if (declarations2hash[data.id]) {
          declarations2hash[data.id] = false;
          result.eq.push(data);
        } else {
          result.ne1.push(data);
        }
      }
      for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        var data = cursor.data;
        if (declarations2hash[data.id]) {
          if (!hasOwnProperty2.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
            result.ne2.push(data);
          }
          result.ne2overrided.push(data);
        }
      }
      return result;
    }
    function addSelectors(dest, source) {
      source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;
        while (cursor) {
          var nextStr = cursor.data.id;
          if (nextStr === newStr) {
            return;
          }
          if (nextStr > newStr) {
            break;
          }
          cursor = cursor.next;
        }
        dest.insert(dest.createItem(sourceData), cursor);
      });
      return dest;
    }
    function hasSimilarSelectors(selectors1, selectors2) {
      var cursor1 = selectors1.head;
      while (cursor1 !== null) {
        var cursor2 = selectors2.head;
        while (cursor2 !== null) {
          if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
            return true;
          }
          cursor2 = cursor2.next;
        }
        cursor1 = cursor1.next;
      }
      return false;
    }
    function unsafeToSkipNode(node) {
      switch (node.type) {
        case "Rule":
          return hasSimilarSelectors(node.prelude.children, this);
        case "Atrule":
          if (node.block) {
            return node.block.children.some(unsafeToSkipNode, this);
          }
          break;
        case "Declaration":
          return false;
      }
      return true;
    }
    module.exports = {
      isEqualSelectors,
      isEqualDeclarations,
      compareDeclarations,
      addSelectors,
      hasSimilarSelectors,
      unsafeToSkipNode
    };
  }
});

// node_modules/csso/lib/restructure/2-initialMergeRuleset.js
var require_initialMergeRuleset = __commonJS({
  "node_modules/csso/lib/restructure/2-initialMergeRuleset.js"(exports, module) {
    var walk = require_lib9().walk;
    var utils = require_utils4();
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      var declarations = node.block.children;
      list.prevUntil(item.prev, function(prev) {
        if (prev.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, prev);
        }
        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;
        if (node.pseudoSignature === prev.pseudoSignature) {
          if (utils.isEqualSelectors(prevSelectors, selectors)) {
            prevDeclarations.appendList(declarations);
            list.remove(item);
            return true;
          }
          if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
            utils.addSelectors(prevSelectors, selectors);
            list.remove(item);
            return true;
          }
        }
        return utils.hasSimilarSelectors(selectors, prevSelectors);
      });
    }
    module.exports = function initialMergeRule(ast) {
      walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/3-disjoinRuleset.js
var require_disjoinRuleset = __commonJS({
  "node_modules/csso/lib/restructure/3-disjoinRuleset.js"(exports, module) {
    var List = require_lib9().List;
    var walk = require_lib9().walk;
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      while (selectors.head !== selectors.tail) {
        var newSelectors = new List();
        newSelectors.insert(selectors.remove(selectors.head));
        list.insert(list.createItem({
          type: "Rule",
          loc: node.loc,
          prelude: {
            type: "SelectorList",
            loc: node.prelude.loc,
            children: newSelectors
          },
          block: {
            type: "Block",
            loc: node.block.loc,
            children: node.block.children.copy()
          },
          pseudoSignature: node.pseudoSignature
        }), item);
      }
    }
    module.exports = function disjoinRule(ast) {
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/4-restructShorthand.js
var require_restructShorthand = __commonJS({
  "node_modules/csso/lib/restructure/4-restructShorthand.js"(exports, module) {
    var List = require_lib9().List;
    var generate = require_lib9().generate;
    var walk = require_lib9().walk;
    var REPLACE = 1;
    var REMOVE = 2;
    var TOP = 0;
    var RIGHT = 1;
    var BOTTOM = 2;
    var LEFT = 3;
    var SIDES = ["top", "right", "bottom", "left"];
    var SIDE = {
      "margin-top": "top",
      "margin-right": "right",
      "margin-bottom": "bottom",
      "margin-left": "left",
      "padding-top": "top",
      "padding-right": "right",
      "padding-bottom": "bottom",
      "padding-left": "left",
      "border-top-color": "top",
      "border-right-color": "right",
      "border-bottom-color": "bottom",
      "border-left-color": "left",
      "border-top-width": "top",
      "border-right-width": "right",
      "border-bottom-width": "bottom",
      "border-left-width": "left",
      "border-top-style": "top",
      "border-right-style": "right",
      "border-bottom-style": "bottom",
      "border-left-style": "left"
    };
    var MAIN_PROPERTY = {
      "margin": "margin",
      "margin-top": "margin",
      "margin-right": "margin",
      "margin-bottom": "margin",
      "margin-left": "margin",
      "padding": "padding",
      "padding-top": "padding",
      "padding-right": "padding",
      "padding-bottom": "padding",
      "padding-left": "padding",
      "border-color": "border-color",
      "border-top-color": "border-color",
      "border-right-color": "border-color",
      "border-bottom-color": "border-color",
      "border-left-color": "border-color",
      "border-width": "border-width",
      "border-top-width": "border-width",
      "border-right-width": "border-width",
      "border-bottom-width": "border-width",
      "border-left-width": "border-width",
      "border-style": "border-style",
      "border-top-style": "border-style",
      "border-right-style": "border-style",
      "border-bottom-style": "border-style",
      "border-left-style": "border-style"
    };
    function TRBL(name) {
      this.name = name;
      this.loc = null;
      this.iehack = void 0;
      this.sides = {
        "top": null,
        "right": null,
        "bottom": null,
        "left": null
      };
    }
    TRBL.prototype.getValueSequence = function(declaration, count) {
      var values = [];
      var iehack = "";
      var hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
        var special = false;
        switch (child.type) {
          case "Identifier":
            switch (child.name) {
              case "\\0":
              case "\\9":
                iehack = child.name;
                return;
              case "inherit":
              case "initial":
              case "unset":
              case "revert":
                special = child.name;
                break;
            }
            break;
          case "Dimension":
            switch (child.unit) {
              case "rem":
              case "vw":
              case "vh":
              case "vmin":
              case "vmax":
              case "vm":
                special = child.unit;
                break;
            }
            break;
          case "Hash":
          case "Number":
          case "Percentage":
            break;
          case "Function":
            if (child.name === "var") {
              return true;
            }
            special = child.name;
            break;
          case "WhiteSpace":
            return false;
          default:
            return true;
        }
        values.push({
          node: child,
          special,
          important: declaration.important
        });
      });
      if (hasBadValues || values.length > count) {
        return false;
      }
      if (typeof this.iehack === "string" && this.iehack !== iehack) {
        return false;
      }
      this.iehack = iehack;
      return values;
    };
    TRBL.prototype.canOverride = function(side, value) {
      var currentValue = this.sides[side];
      return !currentValue || value.important && !currentValue.important;
    };
    TRBL.prototype.add = function(name, declaration) {
      function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];
        if (side) {
          if (side in sides === false) {
            return false;
          }
          var values = this.getValueSequence(declaration, 1);
          if (!values || !values.length) {
            return false;
          }
          for (var key in sides) {
            if (sides[key] !== null && sides[key].special !== values[0].special) {
              return false;
            }
          }
          if (!this.canOverride(side, values[0])) {
            return true;
          }
          sides[side] = values[0];
          return true;
        } else if (name === this.name) {
          var values = this.getValueSequence(declaration, 4);
          if (!values || !values.length) {
            return false;
          }
          switch (values.length) {
            case 1:
              values[RIGHT] = values[TOP];
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[TOP];
              break;
            case 2:
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[RIGHT];
              break;
            case 3:
              values[LEFT] = values[RIGHT];
              break;
          }
          for (var i2 = 0; i2 < 4; i2++) {
            for (var key in sides) {
              if (sides[key] !== null && sides[key].special !== values[i2].special) {
                return false;
              }
            }
          }
          for (var i2 = 0; i2 < 4; i2++) {
            if (this.canOverride(SIDES[i2], values[i2])) {
              sides[SIDES[i2]] = values[i2];
            }
          }
          return true;
        }
      }
      if (!attemptToAdd.call(this)) {
        return false;
      }
      if (!this.loc) {
        this.loc = declaration.loc;
      }
      return true;
    };
    TRBL.prototype.isOkToMinimize = function() {
      var top = this.sides.top;
      var right = this.sides.right;
      var bottom = this.sides.bottom;
      var left = this.sides.left;
      if (top && right && bottom && left) {
        var important = top.important + right.important + bottom.important + left.important;
        return important === 0 || important === 4;
      }
      return false;
    };
    TRBL.prototype.getValue = function() {
      var result = new List();
      var sides = this.sides;
      var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
      ];
      var stringValues = [
        generate(sides.top.node),
        generate(sides.right.node),
        generate(sides.bottom.node),
        generate(sides.left.node)
      ];
      if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
          values.pop();
          if (stringValues[RIGHT] === stringValues[TOP]) {
            values.pop();
          }
        }
      }
      for (var i2 = 0; i2 < values.length; i2++) {
        if (i2) {
          result.appendData({ type: "WhiteSpace", value: " " });
        }
        result.appendData(values[i2].node);
      }
      if (this.iehack) {
        result.appendData({ type: "WhiteSpace", value: " " });
        result.appendData({
          type: "Identifier",
          loc: null,
          name: this.iehack
        });
      }
      return {
        type: "Value",
        loc: null,
        children: result
      };
    };
    TRBL.prototype.getDeclaration = function() {
      return {
        type: "Declaration",
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
      };
    };
    function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
      var declarations = rule.block.children;
      var selector = rule.prelude.children.first().id;
      rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;
        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
          return;
        }
        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;
        if (!lastShortSelector || selector === lastShortSelector) {
          if (key in shorts) {
            operation = REMOVE;
            shorthand = shorts[key];
          }
        }
        if (!shorthand || !shorthand.add(property, declaration)) {
          operation = REPLACE;
          shorthand = new TRBL(key);
          if (!shorthand.add(property, declaration)) {
            lastShortSelector = null;
            return;
          }
        }
        shorts[key] = shorthand;
        shortDeclarations.push({
          operation,
          block: declarations,
          item,
          shorthand
        });
        lastShortSelector = selector;
      });
      return lastShortSelector;
    }
    function processShorthands(shortDeclarations, markDeclaration) {
      shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;
        if (!shorthand.isOkToMinimize()) {
          return;
        }
        if (item.operation === REPLACE) {
          item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
          item.block.remove(item.item);
        }
      });
    }
    module.exports = function restructBlock(ast, indexer) {
      var stylesheetMap = {};
      var shortDeclarations = [];
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: function(node) {
          var stylesheet = this.block || this.stylesheet;
          var ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first().id;
          var ruleMap;
          var shorts;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {
              lastShortSelector: null
            };
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            shorts = ruleMap[ruleId];
          } else {
            shorts = {};
            ruleMap[ruleId] = shorts;
          }
          ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
      });
      processShorthands(shortDeclarations, indexer.declaration);
    };
  }
});

// node_modules/csso/lib/restructure/6-restructBlock.js
var require_restructBlock = __commonJS({
  "node_modules/csso/lib/restructure/6-restructBlock.js"(exports, module) {
    var resolveProperty = require_lib9().property;
    var resolveKeyword = require_lib9().keyword;
    var walk = require_lib9().walk;
    var generate = require_lib9().generate;
    var fingerprintId = 1;
    var dontRestructure = {
      "src": 1
    };
    var DONT_MIX_VALUE = {
      "display": /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
      "text-align": /^(start|end|match-parent|justify-all)$/i
    };
    var SAFE_VALUES = {
      cursor: [
        "auto",
        "crosshair",
        "default",
        "move",
        "text",
        "wait",
        "help",
        "n-resize",
        "e-resize",
        "s-resize",
        "w-resize",
        "ne-resize",
        "nw-resize",
        "se-resize",
        "sw-resize",
        "pointer",
        "progress",
        "not-allowed",
        "no-drop",
        "vertical-text",
        "all-scroll",
        "col-resize",
        "row-resize"
      ],
      overflow: [
        "hidden",
        "visible",
        "scroll",
        "auto"
      ],
      position: [
        "static",
        "relative",
        "absolute",
        "fixed"
      ]
    };
    var NEEDLESS_TABLE = {
      "border-width": ["border"],
      "border-style": ["border"],
      "border-color": ["border"],
      "border-top": ["border"],
      "border-right": ["border"],
      "border-bottom": ["border"],
      "border-left": ["border"],
      "border-top-width": ["border-top", "border-width", "border"],
      "border-right-width": ["border-right", "border-width", "border"],
      "border-bottom-width": ["border-bottom", "border-width", "border"],
      "border-left-width": ["border-left", "border-width", "border"],
      "border-top-style": ["border-top", "border-style", "border"],
      "border-right-style": ["border-right", "border-style", "border"],
      "border-bottom-style": ["border-bottom", "border-style", "border"],
      "border-left-style": ["border-left", "border-style", "border"],
      "border-top-color": ["border-top", "border-color", "border"],
      "border-right-color": ["border-right", "border-color", "border"],
      "border-bottom-color": ["border-bottom", "border-color", "border"],
      "border-left-color": ["border-left", "border-color", "border"],
      "margin-top": ["margin"],
      "margin-right": ["margin"],
      "margin-bottom": ["margin"],
      "margin-left": ["margin"],
      "padding-top": ["padding"],
      "padding-right": ["padding"],
      "padding-bottom": ["padding"],
      "padding-left": ["padding"],
      "font-style": ["font"],
      "font-variant": ["font"],
      "font-weight": ["font"],
      "font-size": ["font"],
      "font-family": ["font"],
      "list-style-type": ["list-style"],
      "list-style-position": ["list-style"],
      "list-style-image": ["list-style"]
    };
    function getPropertyFingerprint(propertyName, declaration, fingerprints) {
      var realName = resolveProperty(propertyName).basename;
      if (realName === "background") {
        return propertyName + ":" + generate(declaration.value);
      }
      var declarationId = declaration.id;
      var fingerprint = fingerprints[declarationId];
      if (!fingerprint) {
        switch (declaration.value.type) {
          case "Value":
            var vendorId = "";
            var iehack = "";
            var special = {};
            var raw = false;
            declaration.value.children.each(function walk2(node) {
              switch (node.type) {
                case "Value":
                case "Brackets":
                case "Parentheses":
                  node.children.each(walk2);
                  break;
                case "Raw":
                  raw = true;
                  break;
                case "Identifier":
                  var name = node.name;
                  if (!vendorId) {
                    vendorId = resolveKeyword(name).vendor;
                  }
                  if (/\\[09]/.test(name)) {
                    iehack = RegExp.lastMatch;
                  }
                  if (SAFE_VALUES.hasOwnProperty(realName)) {
                    if (SAFE_VALUES[realName].indexOf(name) === -1) {
                      special[name] = true;
                    }
                  } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                    if (DONT_MIX_VALUE[realName].test(name)) {
                      special[name] = true;
                    }
                  }
                  break;
                case "Function":
                  var name = node.name;
                  if (!vendorId) {
                    vendorId = resolveKeyword(name).vendor;
                  }
                  if (name === "rect") {
                    var hasComma = node.children.some(function(node2) {
                      return node2.type === "Operator" && node2.value === ",";
                    });
                    if (!hasComma) {
                      name = "rect-backward";
                    }
                  }
                  special[name + "()"] = true;
                  node.children.each(walk2);
                  break;
                case "Dimension":
                  var unit = node.unit;
                  if (/\\[09]/.test(unit)) {
                    iehack = RegExp.lastMatch;
                  }
                  switch (unit) {
                    case "rem":
                    case "vw":
                    case "vh":
                    case "vmin":
                    case "vmax":
                    case "vm":
                      special[unit] = true;
                      break;
                  }
                  break;
              }
            });
            fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
            break;
          case "Raw":
            fingerprint = "!" + declaration.value.value;
            break;
          default:
            fingerprint = generate(declaration.value);
        }
        fingerprints[declarationId] = fingerprint;
      }
      return propertyName + fingerprint;
    }
    function needless(props, declaration, fingerprints) {
      var property = resolveProperty(declaration.property);
      if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];
        for (var i2 = 0; i2 < table.length; i2++) {
          var ppre = getPropertyFingerprint(property.prefix + table[i2], declaration, fingerprints);
          var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
          if (prev && (!declaration.important || prev.item.data.important)) {
            return prev;
          }
        }
      }
    }
    function processRule(rule, item, list, props, fingerprints) {
      var declarations = rule.block.children;
      declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];
        if (prev && !dontRestructure.hasOwnProperty(property)) {
          if (declaration.important && !prev.item.data.important) {
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
            prev.block.remove(prev.item);
          } else {
            declarations.remove(declarationItem);
          }
        } else {
          var prev = needless(props, declaration, fingerprints);
          if (prev) {
            declarations.remove(declarationItem);
          } else {
            declaration.fingerprint = fingerprint;
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
          }
        }
      });
      if (declarations.isEmpty()) {
        list.remove(item);
      }
    }
    module.exports = function restructBlock(ast) {
      var stylesheetMap = {};
      var fingerprints = /* @__PURE__ */ Object.create(null);
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: function(node, item, list) {
          var stylesheet = this.block || this.stylesheet;
          var ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first().id;
          var ruleMap;
          var props;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {};
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            props = ruleMap[ruleId];
          } else {
            props = {};
            ruleMap[ruleId] = props;
          }
          processRule.call(this, node, item, list, props, fingerprints);
        }
      });
    };
  }
});

// node_modules/csso/lib/restructure/7-mergeRuleset.js
var require_mergeRuleset = __commonJS({
  "node_modules/csso/lib/restructure/7-mergeRuleset.js"(exports, module) {
    var walk = require_lib9().walk;
    var utils = require_utils4();
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      var declarations = node.block.children;
      var nodeCompareMarker = selectors.first().compareMarker;
      var skippedCompareMarkers = {};
      list.nextUntil(item.next, function(next, nextItem) {
        if (next.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, next);
        }
        if (node.pseudoSignature !== next.pseudoSignature) {
          return true;
        }
        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;
        if (nextCompareMarker in skippedCompareMarkers) {
          return true;
        }
        if (selectors.head === selectors.tail) {
          if (selectors.first().id === nextFirstSelector.data.id) {
            declarations.appendList(nextDeclarations);
            list.remove(nextItem);
            return;
          }
        }
        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
          var nextStr = nextFirstSelector.data.id;
          selectors.some(function(data, item2) {
            var curStr = data.id;
            if (nextStr < curStr) {
              selectors.insert(nextFirstSelector, item2);
              return true;
            }
            if (!item2.next) {
              selectors.insert(nextFirstSelector);
              return true;
            }
          });
          list.remove(nextItem);
          return;
        }
        if (nextCompareMarker === nodeCompareMarker) {
          return true;
        }
        skippedCompareMarkers[nextCompareMarker] = true;
      });
    }
    module.exports = function mergeRule(ast) {
      walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/8-restructRuleset.js
var require_restructRuleset = __commonJS({
  "node_modules/csso/lib/restructure/8-restructRuleset.js"(exports, module) {
    var List = require_lib9().List;
    var walk = require_lib9().walk;
    var utils = require_utils4();
    function calcSelectorLength(list) {
      var length = 0;
      list.each(function(data) {
        length += data.id.length + 1;
      });
      return length - 1;
    }
    function calcDeclarationsLength(tokens) {
      var length = 0;
      for (var i2 = 0; i2 < tokens.length; i2++) {
        length += tokens[i2].length;
      }
      return length + tokens.length - 1;
    }
    function processRule(node, item, list) {
      var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
      var selectors = node.prelude.children;
      var block = node.block;
      var disallowDownMarkers = /* @__PURE__ */ Object.create(null);
      var allowMergeUp = true;
      var allowMergeDown = true;
      list.prevUntil(item.prev, function(prev, prevItem) {
        var prevBlock = prev.block;
        var prevType = prev.type;
        if (prevType !== "Rule") {
          var unsafe = utils.unsafeToSkipNode.call(selectors, prev);
          if (!unsafe && prevType === "Atrule" && prevBlock) {
            walk(prevBlock, {
              visit: "Rule",
              enter: function(node2) {
                node2.prelude.children.each(function(data) {
                  disallowDownMarkers[data.compareMarker] = true;
                });
              }
            });
          }
          return unsafe;
        }
        var prevSelectors = prev.prelude.children;
        if (node.pseudoSignature !== prev.pseudoSignature) {
          return true;
        }
        allowMergeDown = !prevSelectors.some(function(selector) {
          return selector.compareMarker in disallowDownMarkers;
        });
        if (!allowMergeDown && !allowMergeUp) {
          return true;
        }
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
          prevBlock.children.appendList(block.children);
          list.remove(item);
          return true;
        }
        var diff = utils.compareDeclarations(block.children, prevBlock.children);
        if (diff.eq.length) {
          if (!diff.ne1.length && !diff.ne2.length) {
            if (allowMergeDown) {
              utils.addSelectors(selectors, prevSelectors);
              list.remove(prevItem);
            }
            return true;
          } else if (!avoidRulesMerge) {
            if (diff.ne1.length && !diff.ne2.length) {
              var selectorLength = calcSelectorLength(selectors);
              var blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeUp && selectorLength < blockLength) {
                utils.addSelectors(prevSelectors, selectors);
                block.children = new List().fromArray(diff.ne1);
              }
            } else if (!diff.ne1.length && diff.ne2.length) {
              var selectorLength = calcSelectorLength(prevSelectors);
              var blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeDown && selectorLength < blockLength) {
                utils.addSelectors(selectors, prevSelectors);
                prevBlock.children = new List().fromArray(diff.ne2);
              }
            } else {
              var newSelector = {
                type: "SelectorList",
                loc: null,
                children: utils.addSelectors(prevSelectors.copy(), selectors)
              };
              var newBlockLength = calcSelectorLength(newSelector.children) + 2;
              var blockLength = calcDeclarationsLength(diff.eq);
              if (blockLength >= newBlockLength) {
                var newItem = list.createItem({
                  type: "Rule",
                  loc: null,
                  prelude: newSelector,
                  block: {
                    type: "Block",
                    loc: null,
                    children: new List().fromArray(diff.eq)
                  },
                  pseudoSignature: node.pseudoSignature
                });
                block.children = new List().fromArray(diff.ne1);
                prevBlock.children = new List().fromArray(diff.ne2overrided);
                if (allowMergeUp) {
                  list.insert(newItem, prevItem);
                } else {
                  list.insert(newItem, item);
                }
                return true;
              }
            }
          }
        }
        if (allowMergeUp) {
          allowMergeUp = !prevSelectors.some(function(prevSelector) {
            return selectors.some(function(selector) {
              return selector.compareMarker === prevSelector.compareMarker;
            });
          });
        }
        prevSelectors.each(function(data) {
          disallowDownMarkers[data.compareMarker] = true;
        });
      });
    }
    module.exports = function restructRule(ast) {
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/index.js
var require_restructure = __commonJS({
  "node_modules/csso/lib/restructure/index.js"(exports, module) {
    var prepare = require_prepare();
    var mergeAtrule = require_mergeAtrule();
    var initialMergeRuleset = require_initialMergeRuleset();
    var disjoinRuleset = require_disjoinRuleset();
    var restructShorthand = require_restructShorthand();
    var restructBlock = require_restructBlock();
    var mergeRuleset = require_mergeRuleset();
    var restructRuleset = require_restructRuleset();
    module.exports = function(ast, options) {
      var indexer = prepare(ast, options);
      options.logger("prepare", ast);
      mergeAtrule(ast, options);
      options.logger("mergeAtrule", ast);
      initialMergeRuleset(ast);
      options.logger("initialMergeRuleset", ast);
      disjoinRuleset(ast);
      options.logger("disjoinRuleset", ast);
      restructShorthand(ast, indexer);
      options.logger("restructShorthand", ast);
      restructBlock(ast);
      options.logger("restructBlock", ast);
      mergeRuleset(ast);
      options.logger("mergeRuleset", ast);
      restructRuleset(ast);
      options.logger("restructRuleset", ast);
    };
  }
});

// node_modules/csso/lib/compress.js
var require_compress = __commonJS({
  "node_modules/csso/lib/compress.js"(exports, module) {
    var List = require_lib9().List;
    var clone = require_lib9().clone;
    var usageUtils = require_usage();
    var clean = require_clean();
    var replace = require_replace();
    var restructure = require_restructure();
    var walk = require_lib9().walk;
    function readChunk(children, specialComments) {
      var buffer = new List();
      var nonSpaceTokenInBuffer = false;
      var protectedComment;
      children.nextUntil(children.head, function(node, item, list) {
        if (node.type === "Comment") {
          if (!specialComments || node.value.charAt(0) !== "!") {
            list.remove(item);
            return;
          }
          if (nonSpaceTokenInBuffer || protectedComment) {
            return true;
          }
          list.remove(item);
          protectedComment = node;
          return;
        }
        if (node.type !== "WhiteSpace") {
          nonSpaceTokenInBuffer = true;
        }
        buffer.insert(list.remove(item));
      });
      return {
        comment: protectedComment,
        stylesheet: {
          type: "StyleSheet",
          loc: null,
          children: buffer
        }
      };
    }
    function compressChunk(ast, firstAtrulesAllowed, num, options) {
      options.logger("Compress block #" + num, null, true);
      var seed = 1;
      if (ast.type === "StyleSheet") {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
      }
      walk(ast, {
        visit: "Atrule",
        enter: function markScopes(node) {
          if (node.block !== null) {
            node.block.id = seed++;
          }
        }
      });
      options.logger("init", ast);
      clean(ast, options);
      options.logger("clean", ast);
      replace(ast, options);
      options.logger("replace", ast);
      if (options.restructuring) {
        restructure(ast, options);
      }
      return ast;
    }
    function getCommentsOption(options) {
      var comments = "comments" in options ? options.comments : "exclamation";
      if (typeof comments === "boolean") {
        comments = comments ? "exclamation" : false;
      } else if (comments !== "exclamation" && comments !== "first-exclamation") {
        comments = false;
      }
      return comments;
    }
    function getRestructureOption(options) {
      if ("restructure" in options) {
        return options.restructure;
      }
      return "restructuring" in options ? options.restructuring : true;
    }
    function wrapBlock(block) {
      return new List().appendData({
        type: "Rule",
        loc: null,
        prelude: {
          type: "SelectorList",
          loc: null,
          children: new List().appendData({
            type: "Selector",
            loc: null,
            children: new List().appendData({
              type: "TypeSelector",
              loc: null,
              name: "x"
            })
          })
        },
        block
      });
    }
    module.exports = function compress(ast, options) {
      ast = ast || { type: "StyleSheet", loc: null, children: new List() };
      options = options || {};
      var compressOptions = {
        logger: typeof options.logger === "function" ? options.logger : function() {
        },
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
      };
      var specialComments = getCommentsOption(options);
      var firstAtrulesAllowed = true;
      var input;
      var output = new List();
      var chunk;
      var chunkNum = 1;
      var chunkChildren;
      if (options.clone) {
        ast = clone(ast);
      }
      if (ast.type === "StyleSheet") {
        input = ast.children;
        ast.children = output;
      } else {
        input = wrapBlock(ast);
      }
      do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;
        if (chunk.comment) {
          if (!output.isEmpty()) {
            output.insert(List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
          output.insert(List.createItem(chunk.comment));
          if (!chunkChildren.isEmpty()) {
            output.insert(List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
        }
        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
          var lastRule = chunkChildren.last();
          if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
            firstAtrulesAllowed = false;
          }
        }
        if (specialComments !== "exclamation") {
          specialComments = false;
        }
        output.appendList(chunkChildren);
      } while (!input.isEmpty());
      return {
        ast
      };
    };
  }
});

// node_modules/csso/package.json
var require_package2 = __commonJS({
  "node_modules/csso/package.json"(exports, module) {
    module.exports = {
      name: "csso",
      version: "4.2.0",
      description: "CSS minifier with structural optimisations",
      homepage: "https://github.com/css/csso",
      author: "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)",
      maintainers: [
        {
          name: "Roman Dvornov",
          email: "rdvornov@gmail.com",
          "github-username": "lahmatiy"
        }
      ],
      license: "MIT",
      repository: "css/csso",
      bugs: {
        url: "https://github.com/css/csso/issues"
      },
      keywords: [
        "css",
        "compress",
        "minifier",
        "minify",
        "optimise",
        "optimisation",
        "csstree"
      ],
      main: "./lib/index",
      scripts: {
        test: "mocha --reporter dot",
        lint: "eslint lib test",
        "lint-and-test": "npm run lint && npm test",
        build: "rollup --config && terser dist/csso.js --compress --mangle -o dist/csso.min.js",
        coverage: "nyc npm test",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        travis: "nyc npm run lint-and-test && npm run coveralls",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
        prepublishOnly: "npm run build"
      },
      dependencies: {
        "css-tree": "^1.1.2"
      },
      browser: {
        "css-tree": "css-tree/dist/csstree.min.js"
      },
      devDependencies: {
        "@rollup/plugin-commonjs": "^11.0.1",
        "@rollup/plugin-json": "^4.0.1",
        "@rollup/plugin-node-resolve": "^7.0.0",
        coveralls: "^3.0.11",
        eslint: "^6.8.0",
        mocha: "^7.1.1",
        nyc: "^15.0.0",
        rollup: "^1.29.0",
        "source-map": "^0.6.1",
        terser: "^4.6.3"
      },
      engines: {
        node: ">=8.0.0"
      },
      files: [
        "dist",
        "lib"
      ]
    };
  }
});

// node_modules/csso/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/csso/lib/index.js"(exports, module) {
    var csstree = require_lib9();
    var parse4 = csstree.parse;
    var compress = require_compress();
    var generate = csstree.generate;
    function debugOutput(name, options, startTime, data) {
      if (options.debug) {
        console.error("## " + name + " done in %d ms\n", Date.now() - startTime);
      }
      return data;
    }
    function createDefaultLogger(level) {
      var lastDebug;
      return function logger(title, ast) {
        var line = title;
        if (ast) {
          line = "[" + ((Date.now() - lastDebug) / 1e3).toFixed(3) + "s] " + line;
        }
        if (level > 1 && ast) {
          var css = generate(ast);
          if (level === 2 && css.length > 256) {
            css = css.substr(0, 256) + "...";
          }
          line += "\n  " + css + "\n";
        }
        console.error(line);
        lastDebug = Date.now();
      };
    }
    function copy(obj) {
      var result = {};
      for (var key in obj) {
        result[key] = obj[key];
      }
      return result;
    }
    function buildCompressOptions(options) {
      options = copy(options);
      if (typeof options.logger !== "function" && options.debug) {
        options.logger = createDefaultLogger(options.debug);
      }
      return options;
    }
    function runHandler(ast, options, handlers) {
      if (!Array.isArray(handlers)) {
        handlers = [handlers];
      }
      handlers.forEach(function(fn) {
        fn(ast, options);
      });
    }
    function minify(context, source, options) {
      options = options || {};
      var filename = options.filename || "<unknown>";
      var result;
      var ast = debugOutput(
        "parsing",
        options,
        Date.now(),
        parse4(source, {
          context,
          filename,
          positions: Boolean(options.sourceMap)
        })
      );
      if (options.beforeCompress) {
        debugOutput(
          "beforeCompress",
          options,
          Date.now(),
          runHandler(ast, options, options.beforeCompress)
        );
      }
      var compressResult = debugOutput(
        "compress",
        options,
        Date.now(),
        compress(ast, buildCompressOptions(options))
      );
      if (options.afterCompress) {
        debugOutput(
          "afterCompress",
          options,
          Date.now(),
          runHandler(compressResult, options, options.afterCompress)
        );
      }
      if (options.sourceMap) {
        result = debugOutput("generate(sourceMap: true)", options, Date.now(), function() {
          var tmp = generate(compressResult.ast, { sourceMap: true });
          tmp.map._file = filename;
          tmp.map.setSourceContent(filename, source);
          return tmp;
        }());
      } else {
        result = debugOutput("generate", options, Date.now(), {
          css: generate(compressResult.ast),
          map: null
        });
      }
      return result;
    }
    function minifyStylesheet(source, options) {
      return minify("stylesheet", source, options);
    }
    function minifyBlock(source, options) {
      return minify("declarationList", source, options);
    }
    module.exports = {
      version: require_package2().version,
      minify: minifyStylesheet,
      minifyBlock,
      syntax: Object.assign({
        compress
      }, csstree)
    };
  }
});

// node_modules/svgo/plugins/minifyStyles.js
var require_minifyStyles = __commonJS({
  "node_modules/svgo/plugins/minifyStyles.js"(exports) {
    "use strict";
    var csso = require_lib10();
    exports.type = "visitor";
    exports.name = "minifyStyles";
    exports.active = true;
    exports.description = "minifies styles and removes unused styles based on usage data";
    exports.fn = (_root, { usage, ...params }) => {
      let enableTagsUsage = true;
      let enableIdsUsage = true;
      let enableClassesUsage = true;
      let forceUsageDeoptimized = false;
      if (typeof usage === "boolean") {
        enableTagsUsage = usage;
        enableIdsUsage = usage;
        enableClassesUsage = usage;
      } else if (usage) {
        enableTagsUsage = usage.tags == null ? true : usage.tags;
        enableIdsUsage = usage.ids == null ? true : usage.ids;
        enableClassesUsage = usage.classes == null ? true : usage.classes;
        forceUsageDeoptimized = usage.force == null ? false : usage.force;
      }
      const styleElements = [];
      const elementsWithStyleAttributes = [];
      let deoptimized = false;
      const tagsUsage = /* @__PURE__ */ new Set();
      const idsUsage = /* @__PURE__ */ new Set();
      const classesUsage = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node) => {
            if (node.name === "script") {
              deoptimized = true;
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.startsWith("on")) {
                deoptimized = true;
              }
            }
            tagsUsage.add(node.name);
            if (node.attributes.id != null) {
              idsUsage.add(node.attributes.id);
            }
            if (node.attributes.class != null) {
              for (const className of node.attributes.class.split(/\s+/)) {
                classesUsage.add(className);
              }
            }
            if (node.name === "style" && node.children.length !== 0) {
              styleElements.push(node);
            } else if (node.attributes.style != null) {
              elementsWithStyleAttributes.push(node);
            }
          }
        },
        root: {
          exit: () => {
            const cssoUsage = {};
            if (deoptimized === false || forceUsageDeoptimized === true) {
              if (enableTagsUsage && tagsUsage.size !== 0) {
                cssoUsage.tags = Array.from(tagsUsage);
              }
              if (enableIdsUsage && idsUsage.size !== 0) {
                cssoUsage.ids = Array.from(idsUsage);
              }
              if (enableClassesUsage && classesUsage.size !== 0) {
                cssoUsage.classes = Array.from(classesUsage);
              }
            }
            for (const node of styleElements) {
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                const cssText = node.children[0].value;
                const minified = csso.minify(cssText, {
                  ...params,
                  usage: cssoUsage
                }).css;
                if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                  node.children[0].type = "cdata";
                  node.children[0].value = minified;
                } else {
                  node.children[0].type = "text";
                  node.children[0].value = minified;
                }
              }
            }
            for (const node of elementsWithStyleAttributes) {
              const elemStyle = node.attributes.style;
              node.attributes.style = csso.minifyBlock(elemStyle, {
                ...params
              }).css;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupIDs.js
var require_cleanupIDs = __commonJS({
  "node_modules/svgo/plugins/cleanupIDs.js"(exports) {
    "use strict";
    var { visitSkip } = require_xast();
    var { referencesProps } = require_collections();
    exports.type = "visitor";
    exports.name = "cleanupIDs";
    exports.active = true;
    exports.description = "removes unused IDs and minifies used";
    var regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/;
    var regReferencesHref = /^#(.+?)$/;
    var regReferencesBegin = /(\w+)\./;
    var generateIDchars = [
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    var maxIDindex = generateIDchars.length - 1;
    var hasStringPrefix = (string2, prefixes) => {
      for (const prefix of prefixes) {
        if (string2.startsWith(prefix)) {
          return true;
        }
      }
      return false;
    };
    var generateID = (currentID) => {
      if (currentID == null) {
        return [0];
      }
      currentID[currentID.length - 1] += 1;
      for (let i2 = currentID.length - 1; i2 > 0; i2--) {
        if (currentID[i2] > maxIDindex) {
          currentID[i2] = 0;
          if (currentID[i2 - 1] !== void 0) {
            currentID[i2 - 1]++;
          }
        }
      }
      if (currentID[0] > maxIDindex) {
        currentID[0] = 0;
        currentID.unshift(0);
      }
      return currentID;
    };
    var getIDstring = (arr, prefix) => {
      return prefix + arr.map((i2) => generateIDchars[i2]).join("");
    };
    exports.fn = (_root, params) => {
      const {
        remove = true,
        minify = true,
        prefix = "",
        preserve = [],
        preservePrefixes = [],
        force = false
      } = params;
      const preserveIDs = new Set(
        Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
      );
      const preserveIDPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];
      const nodeById = /* @__PURE__ */ new Map();
      const referencesById = /* @__PURE__ */ new Map();
      let deoptimized = false;
      return {
        element: {
          enter: (node) => {
            if (force == false) {
              if ((node.name === "style" || node.name === "script") && node.children.length !== 0) {
                deoptimized = true;
                return;
              }
              if (node.name === "svg") {
                let hasDefsOnly = true;
                for (const child of node.children) {
                  if (child.type !== "element" || child.name !== "defs") {
                    hasDefsOnly = false;
                    break;
                  }
                }
                if (hasDefsOnly) {
                  return visitSkip;
                }
              }
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "id") {
                const id = value;
                if (nodeById.has(id)) {
                  delete node.attributes.id;
                } else {
                  nodeById.set(id, node);
                }
              } else {
                let id = null;
                if (referencesProps.includes(name)) {
                  const match = value.match(regReferencesUrl);
                  if (match != null) {
                    id = match[2];
                  }
                }
                if (name === "href" || name.endsWith(":href")) {
                  const match = value.match(regReferencesHref);
                  if (match != null) {
                    id = match[1];
                  }
                }
                if (name === "begin") {
                  const match = value.match(regReferencesBegin);
                  if (match != null) {
                    id = match[1];
                  }
                }
                if (id != null) {
                  let refs = referencesById.get(id);
                  if (refs == null) {
                    refs = [];
                    referencesById.set(id, refs);
                  }
                  refs.push({ element: node, name, value });
                }
              }
            }
          }
        },
        root: {
          exit: () => {
            if (deoptimized) {
              return;
            }
            const isIdPreserved = (id) => preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);
            let currentID = null;
            for (const [id, refs] of referencesById) {
              const node = nodeById.get(id);
              if (node != null) {
                if (minify && isIdPreserved(id) === false) {
                  let currentIDString = null;
                  do {
                    currentID = generateID(currentID);
                    currentIDString = getIDstring(currentID, prefix);
                  } while (isIdPreserved(currentIDString));
                  node.attributes.id = currentIDString;
                  for (const { element, name, value } of refs) {
                    if (value.includes("#")) {
                      element.attributes[name] = value.replace(
                        `#${id}`,
                        `#${currentIDString}`
                      );
                    } else {
                      element.attributes[name] = value.replace(
                        `${id}.`,
                        `${currentIDString}.`
                      );
                    }
                  }
                }
                nodeById.delete(id);
              }
            }
            if (remove) {
              for (const [id, node] of nodeById) {
                if (isIdPreserved(id) === false) {
                  delete node.attributes.id;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUselessDefs.js
var require_removeUselessDefs = __commonJS({
  "node_modules/svgo/plugins/removeUselessDefs.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports.type = "visitor";
    exports.name = "removeUselessDefs";
    exports.active = true;
    exports.description = "removes elements in <defs> without id";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "defs") {
              const usefulNodes = [];
              collectUsefulNodes(node, usefulNodes);
              if (usefulNodes.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              for (const usefulNode of usefulNodes) {
                usefulNode.parentNode = node;
              }
              node.children = usefulNodes;
            } else if (elemsGroups.nonRendering.includes(node.name) && node.attributes.id == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
    var collectUsefulNodes = (node, usefulNodes) => {
      for (const child of node.children) {
        if (child.type === "element") {
          if (child.attributes.id != null || child.name === "style") {
            usefulNodes.push(child);
          } else {
            collectUsefulNodes(child, usefulNodes);
          }
        }
      }
    };
  }
});

// node_modules/svgo/lib/svgo/tools.js
var require_tools = __commonJS({
  "node_modules/svgo/lib/svgo/tools.js"(exports) {
    "use strict";
    exports.encodeSVGDatauri = (str, type) => {
      var prefix = "data:image/svg+xml";
      if (!type || type === "base64") {
        prefix += ";base64,";
        str = prefix + Buffer.from(str).toString("base64");
      } else if (type === "enc") {
        str = prefix + "," + encodeURIComponent(str);
      } else if (type === "unenc") {
        str = prefix + "," + str;
      }
      return str;
    };
    exports.decodeSVGDatauri = (str) => {
      var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
      var match = regexp.exec(str);
      if (!match)
        return str;
      var data = match[3];
      if (match[2]) {
        str = Buffer.from(data, "base64").toString("utf8");
      } else if (data.charAt(0) === "%") {
        str = decodeURIComponent(data);
      } else if (data.charAt(0) === "<") {
        str = data;
      }
      return str;
    };
    exports.cleanupOutData = (data, params, command) => {
      let str = "";
      let delimiter;
      let prev;
      data.forEach((item, i2) => {
        delimiter = " ";
        if (i2 == 0)
          delimiter = "";
        if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
          var pos = i2 % 7;
          if (pos == 4 || pos == 5)
            delimiter = "";
        }
        const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();
        if (params.negativeExtraSpace && delimiter != "" && (item < 0 || itemStr.charAt(0) === "." && prev % 1 !== 0)) {
          delimiter = "";
        }
        prev = item;
        str += delimiter + itemStr;
      });
      return str;
    };
    var removeLeadingZero = (num) => {
      var strNum = num.toString();
      if (0 < num && num < 1 && strNum.charAt(0) === "0") {
        strNum = strNum.slice(1);
      } else if (-1 < num && num < 0 && strNum.charAt(1) === "0") {
        strNum = strNum.charAt(0) + strNum.slice(2);
      }
      return strNum;
    };
    exports.removeLeadingZero = removeLeadingZero;
  }
});

// node_modules/svgo/plugins/cleanupNumericValues.js
var require_cleanupNumericValues = __commonJS({
  "node_modules/svgo/plugins/cleanupNumericValues.js"(exports) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports.name = "cleanupNumericValues";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "rounds numeric values to the fixed precision, removes default \u2018px\u2019 units";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var absoluteLengths = {
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      return {
        element: {
          enter: (node) => {
            if (node.attributes.viewBox != null) {
              const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
              node.attributes.viewBox = nums.map((value) => {
                const num = Number(value);
                return Number.isNaN(num) ? value : Number(num.toFixed(floatPrecision));
              }).join(" ");
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "version") {
                continue;
              }
              const match = value.match(regNumericValues);
              if (match) {
                let num = Number(Number(match[1]).toFixed(floatPrecision));
                let matchedUnit = match[3] || "";
                let units = matchedUnit;
                if (convertToPx && units !== "" && units in absoluteLengths) {
                  const pxNum = Number(
                    (absoluteLengths[units] * Number(match[1])).toFixed(
                      floatPrecision
                    )
                  );
                  if (pxNum.toString().length < match[0].length) {
                    num = pxNum;
                    units = "px";
                  }
                }
                let str;
                if (leadingZero) {
                  str = removeLeadingZero(num);
                } else {
                  str = num.toString();
                }
                if (defaultPx && units === "px") {
                  units = "";
                }
                node.attributes[name] = str + units;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertColors.js
var require_convertColors = __commonJS({
  "node_modules/svgo/plugins/convertColors.js"(exports) {
    "use strict";
    var collections = require_collections();
    exports.type = "visitor";
    exports.name = "convertColors";
    exports.active = true;
    exports.description = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
    var rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
    var rComma = "\\s*,\\s*";
    var regRGB = new RegExp(
      "^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$"
    );
    var regHEX = /^#(([a-fA-F0-9])\2){3}$/;
    var convertRgbToHex = ([r2, g2, b2]) => {
      const hexNumber = (256 + r2 << 8 | g2) << 8 | b2;
      return "#" + hexNumber.toString(16).slice(1).toUpperCase();
    };
    exports.fn = (_root, params) => {
      const {
        currentColor = false,
        names2hex = true,
        rgb2hex = true,
        shorthex = true,
        shortname = true
      } = params;
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (collections.colorsProps.includes(name)) {
                let val = value;
                if (currentColor) {
                  let matched;
                  if (typeof currentColor === "string") {
                    matched = val === currentColor;
                  } else if (currentColor instanceof RegExp) {
                    matched = currentColor.exec(val) != null;
                  } else {
                    matched = val !== "none";
                  }
                  if (matched) {
                    val = "currentColor";
                  }
                }
                if (names2hex) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsNames[colorName] != null) {
                    val = collections.colorsNames[colorName];
                  }
                }
                if (rgb2hex) {
                  let match = val.match(regRGB);
                  if (match != null) {
                    let nums = match.slice(1, 4).map((m2) => {
                      let n2;
                      if (m2.indexOf("%") > -1) {
                        n2 = Math.round(parseFloat(m2) * 2.55);
                      } else {
                        n2 = Number(m2);
                      }
                      return Math.max(0, Math.min(n2, 255));
                    });
                    val = convertRgbToHex(nums);
                  }
                }
                if (shorthex) {
                  let match = val.match(regHEX);
                  if (match != null) {
                    val = "#" + match[0][1] + match[0][3] + match[0][5];
                  }
                }
                if (shortname) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsShortNames[colorName] != null) {
                    val = collections.colorsShortNames[colorName];
                  }
                }
                node.attributes[name] = val;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/style.js
var require_style = __commonJS({
  "node_modules/svgo/lib/style.js"(exports) {
    "use strict";
    var stable = require_stable();
    var csstree = require_lib9();
    var specificity = require_specificity();
    var { visit: visit3, matches } = require_xast();
    var {
      attrsGroups,
      inheritableAttrs,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    var csstreeWalkSkip = csstree.walk.skip;
    var parseRule = (ruleNode, dynamic) => {
      let selectors;
      let selectorsSpecificity;
      const declarations = [];
      csstree.walk(ruleNode, (cssNode) => {
        if (cssNode.type === "SelectorList") {
          selectorsSpecificity = specificity(cssNode);
          const newSelectorsNode = csstree.clone(cssNode);
          csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
            if (pseudoClassNode.type === "PseudoClassSelector") {
              dynamic = true;
              list.remove(item);
            }
          });
          selectors = csstree.generate(newSelectorsNode);
          return csstreeWalkSkip;
        }
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
          return csstreeWalkSkip;
        }
      });
      if (selectors == null || selectorsSpecificity == null) {
        throw Error("assert");
      }
      return {
        dynamic,
        selectors,
        specificity: selectorsSpecificity,
        declarations
      };
    };
    var parseStylesheet = (css, dynamic) => {
      const rules = [];
      const ast = csstree.parse(css, {
        parseValue: false,
        parseAtrulePrelude: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Rule") {
          rules.push(parseRule(cssNode, dynamic || false));
          return csstreeWalkSkip;
        }
        if (cssNode.type === "Atrule") {
          if (cssNode.name === "keyframes") {
            return csstreeWalkSkip;
          }
          csstree.walk(cssNode, (ruleNode) => {
            if (ruleNode.type === "Rule") {
              rules.push(parseRule(ruleNode, dynamic || true));
              return csstreeWalkSkip;
            }
          });
          return csstreeWalkSkip;
        }
      });
      return rules;
    };
    var parseStyleDeclarations = (css) => {
      const declarations = [];
      const ast = csstree.parse(css, {
        context: "declarationList",
        parseValue: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
        }
      });
      return declarations;
    };
    var computeOwnStyle = (stylesheet, node) => {
      const computedStyle = {};
      const importantStyles = /* @__PURE__ */ new Map();
      for (const [name, value] of Object.entries(node.attributes)) {
        if (attrsGroups.presentation.includes(name)) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, false);
        }
      }
      for (const { selectors, declarations, dynamic } of stylesheet.rules) {
        if (matches(node, selectors)) {
          for (const { name, value, important } of declarations) {
            const computed = computedStyle[name];
            if (computed && computed.type === "dynamic") {
              continue;
            }
            if (dynamic) {
              computedStyle[name] = { type: "dynamic", inherited: false };
              continue;
            }
            if (computed == null || important === true || importantStyles.get(name) === false) {
              computedStyle[name] = { type: "static", inherited: false, value };
              importantStyles.set(name, important);
            }
          }
        }
      }
      const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);
      for (const { name, value, important } of styleDeclarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === "dynamic") {
          continue;
        }
        if (computed == null || important === true || importantStyles.get(name) === false) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, important);
        }
      }
      return computedStyle;
    };
    var compareSpecificity = (a2, b2) => {
      for (var i2 = 0; i2 < 4; i2 += 1) {
        if (a2[i2] < b2[i2]) {
          return -1;
        } else if (a2[i2] > b2[i2]) {
          return 1;
        }
      }
      return 0;
    };
    var collectStylesheet = (root) => {
      const rules = [];
      const parents = /* @__PURE__ */ new Map();
      visit3(root, {
        element: {
          enter: (node, parentNode) => {
            parents.set(node, parentNode);
            if (node.name === "style") {
              const dynamic = node.attributes.media != null && node.attributes.media !== "all";
              if (node.attributes.type == null || node.attributes.type === "" || node.attributes.type === "text/css") {
                const children = node.children;
                for (const child of children) {
                  if (child.type === "text" || child.type === "cdata") {
                    rules.push(...parseStylesheet(child.value, dynamic));
                  }
                }
              }
            }
          }
        }
      });
      stable.inplace(
        rules,
        (a2, b2) => compareSpecificity(a2.specificity, b2.specificity)
      );
      return { rules, parents };
    };
    exports.collectStylesheet = collectStylesheet;
    var computeStyle = (stylesheet, node) => {
      const { parents } = stylesheet;
      const computedStyles = computeOwnStyle(stylesheet, node);
      let parent = parents.get(node);
      while (parent != null && parent.type !== "root") {
        const inheritedStyles = computeOwnStyle(stylesheet, parent);
        for (const [name, computed] of Object.entries(inheritedStyles)) {
          if (computedStyles[name] == null && inheritableAttrs.includes(name) === true && presentationNonInheritableGroupAttrs.includes(name) === false) {
            computedStyles[name] = { ...computed, inherited: true };
          }
        }
        parent = parents.get(parent);
      }
      return computedStyles;
    };
    exports.computeStyle = computeStyle;
  }
});

// node_modules/svgo/plugins/removeUnknownsAndDefaults.js
var require_removeUnknownsAndDefaults = __commonJS({
  "node_modules/svgo/plugins/removeUnknownsAndDefaults.js"(exports) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var {
      elems,
      attrsGroups,
      elemsGroups,
      attrsGroupsDefaults,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports.type = "visitor";
    exports.name = "removeUnknownsAndDefaults";
    exports.active = true;
    exports.description = "removes unknown elements content and attributes, removes attrs with default values";
    var allowedChildrenPerElement = /* @__PURE__ */ new Map();
    var allowedAttributesPerElement = /* @__PURE__ */ new Map();
    var attributesDefaultsPerElement = /* @__PURE__ */ new Map();
    for (const [name, config] of Object.entries(elems)) {
      const allowedChildren = /* @__PURE__ */ new Set();
      if (config.content) {
        for (const elementName of config.content) {
          allowedChildren.add(elementName);
        }
      }
      if (config.contentGroups) {
        for (const contentGroupName of config.contentGroups) {
          const elemsGroup = elemsGroups[contentGroupName];
          if (elemsGroup) {
            for (const elementName of elemsGroup) {
              allowedChildren.add(elementName);
            }
          }
        }
      }
      const allowedAttributes = /* @__PURE__ */ new Set();
      if (config.attrs) {
        for (const attrName of config.attrs) {
          allowedAttributes.add(attrName);
        }
      }
      const attributesDefaults = /* @__PURE__ */ new Map();
      if (config.defaults) {
        for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
          attributesDefaults.set(attrName, defaultValue);
        }
      }
      for (const attrsGroupName of config.attrsGroups) {
        const attrsGroup = attrsGroups[attrsGroupName];
        if (attrsGroup) {
          for (const attrName of attrsGroup) {
            allowedAttributes.add(attrName);
          }
        }
        const groupDefaults = attrsGroupsDefaults[attrsGroupName];
        if (groupDefaults) {
          for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
            attributesDefaults.set(attrName, defaultValue);
          }
        }
      }
      allowedChildrenPerElement.set(name, allowedChildren);
      allowedAttributesPerElement.set(name, allowedAttributes);
      attributesDefaultsPerElement.set(name, attributesDefaults);
    }
    exports.fn = (root, params) => {
      const {
        unknownContent = true,
        unknownAttrs = true,
        defaultAttrs = true,
        uselessOverrides = true,
        keepDataAttrs = true,
        keepAriaAttrs = true,
        keepRoleAttr = false
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name.includes(":")) {
              return;
            }
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (unknownContent && parentNode.type === "element") {
              const allowedChildren = allowedChildrenPerElement.get(
                parentNode.name
              );
              if (allowedChildren == null || allowedChildren.size === 0) {
                if (allowedChildrenPerElement.get(node.name) == null) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              } else {
                if (allowedChildren.has(node.name) === false) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              }
            }
            const allowedAttributes = allowedAttributesPerElement.get(node.name);
            const attributesDefaults = attributesDefaultsPerElement.get(node.name);
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            for (const [name, value] of Object.entries(node.attributes)) {
              if (keepDataAttrs && name.startsWith("data-")) {
                continue;
              }
              if (keepAriaAttrs && name.startsWith("aria-")) {
                continue;
              }
              if (keepRoleAttr && name === "role") {
                continue;
              }
              if (name === "xmlns") {
                continue;
              }
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefix !== "xml" && prefix !== "xlink") {
                  continue;
                }
              }
              if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {
                delete node.attributes[name];
              }
              if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {
                if (computedParentStyle == null || computedParentStyle[name] == null) {
                  delete node.attributes[name];
                }
              }
              if (uselessOverrides && node.attributes.id == null) {
                const style = computedParentStyle == null ? null : computedParentStyle[name];
                if (presentationNonInheritableGroupAttrs.includes(name) === false && style != null && style.type === "static" && style.value === value) {
                  delete node.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js
var require_removeNonInheritableGroupAttrs = __commonJS({
  "node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js"(exports) {
    "use strict";
    exports.name = "removeNonInheritableGroupAttrs";
    exports.type = "perItem";
    exports.active = true;
    exports.description = "removes non-inheritable group\u2019s presentational attributes";
    var {
      inheritableAttrs,
      attrsGroups,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports.fn = function(item) {
      if (item.type === "element" && item.name === "g") {
        for (const name of Object.keys(item.attributes)) {
          if (attrsGroups.presentation.includes(name) === true && inheritableAttrs.includes(name) === false && presentationNonInheritableGroupAttrs.includes(name) === false) {
            delete item.attributes[name];
          }
        }
      }
    };
  }
});

// node_modules/svgo/plugins/removeUselessStrokeAndFill.js
var require_removeUselessStrokeAndFill = __commonJS({
  "node_modules/svgo/plugins/removeUselessStrokeAndFill.js"(exports) {
    "use strict";
    var { visit: visit3, visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { elemsGroups } = require_collections();
    exports.type = "visitor";
    exports.name = "removeUselessStrokeAndFill";
    exports.active = true;
    exports.description = "removes useless stroke and fill attributes";
    exports.fn = (root, params) => {
      const {
        stroke: removeStroke = true,
        fill: removeFill = true,
        removeNone = false
      } = params;
      let hasStyleOrScript = false;
      visit3(root, {
        element: {
          enter: (node) => {
            if (node.name === "style" || node.name === "script") {
              hasStyleOrScript = true;
            }
          }
        }
      });
      if (hasStyleOrScript) {
        return null;
      }
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null) {
              return visitSkip;
            }
            if (elemsGroups.shape.includes(node.name) == false) {
              return;
            }
            const computedStyle = computeStyle(stylesheet, node);
            const stroke = computedStyle.stroke;
            const strokeOpacity = computedStyle["stroke-opacity"];
            const strokeWidth = computedStyle["stroke-width"];
            const markerEnd = computedStyle["marker-end"];
            const fill = computedStyle.fill;
            const fillOpacity = computedStyle["fill-opacity"];
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;
            if (removeStroke) {
              if (stroke == null || stroke.type === "static" && stroke.value == "none" || strokeOpacity != null && strokeOpacity.type === "static" && strokeOpacity.value === "0" || strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0") {
                if (strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0" || markerEnd == null) {
                  for (const name of Object.keys(node.attributes)) {
                    if (name.startsWith("stroke")) {
                      delete node.attributes[name];
                    }
                  }
                  if (parentStroke != null && parentStroke.type === "static" && parentStroke.value !== "none") {
                    node.attributes.stroke = "none";
                  }
                }
              }
            }
            if (removeFill) {
              if (fill != null && fill.type === "static" && fill.value === "none" || fillOpacity != null && fillOpacity.type === "static" && fillOpacity.value === "0") {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("fill-")) {
                    delete node.attributes[name];
                  }
                }
                if (fill == null || fill.type === "static" && fill.value !== "none") {
                  node.attributes.fill = "none";
                }
              }
            }
            if (removeNone) {
              if ((stroke == null || node.attributes.stroke === "none") && (fill != null && fill.type === "static" && fill.value === "none" || node.attributes.fill === "none")) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeViewBox.js
var require_removeViewBox = __commonJS({
  "node_modules/svgo/plugins/removeViewBox.js"(exports) {
    "use strict";
    exports.type = "visitor";
    exports.name = "removeViewBox";
    exports.active = true;
    exports.description = "removes viewBox attribute when possible";
    var viewBoxElems = ["svg", "pattern", "symbol"];
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (viewBoxElems.includes(node.name) && node.attributes.viewBox != null && node.attributes.width != null && node.attributes.height != null) {
              if (node.name === "svg" && parentNode.type !== "root") {
                return;
              }
              const nums = node.attributes.viewBox.split(/[ ,]+/g);
              if (nums[0] === "0" && nums[1] === "0" && node.attributes.width.replace(/px$/, "") === nums[2] && node.attributes.height.replace(/px$/, "") === nums[3]) {
                delete node.attributes.viewBox;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupEnableBackground.js
var require_cleanupEnableBackground = __commonJS({
  "node_modules/svgo/plugins/cleanupEnableBackground.js"(exports) {
    "use strict";
    var { visit: visit3 } = require_xast();
    exports.type = "visitor";
    exports.name = "cleanupEnableBackground";
    exports.active = true;
    exports.description = "remove or cleanup enable-background attribute when possible";
    exports.fn = (root) => {
      const regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
      let hasFilter = false;
      visit3(root, {
        element: {
          enter: (node) => {
            if (node.name === "filter") {
              hasFilter = true;
            }
          }
        }
      });
      return {
        element: {
          enter: (node) => {
            if (node.attributes["enable-background"] == null) {
              return;
            }
            if (hasFilter) {
              if ((node.name === "svg" || node.name === "mask" || node.name === "pattern") && node.attributes.width != null && node.attributes.height != null) {
                const match = node.attributes["enable-background"].match(regEnableBackground);
                if (match != null && node.attributes.width === match[1] && node.attributes.height === match[3]) {
                  if (node.name === "svg") {
                    delete node.attributes["enable-background"];
                  } else {
                    node.attributes["enable-background"] = "new";
                  }
                }
              }
            } else {
              delete node.attributes["enable-background"];
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/path.js
var require_path2 = __commonJS({
  "node_modules/svgo/lib/path.js"(exports) {
    "use strict";
    var argsCountPerCommand = {
      M: 2,
      m: 2,
      Z: 0,
      z: 0,
      L: 2,
      l: 2,
      H: 1,
      h: 1,
      V: 1,
      v: 1,
      C: 6,
      c: 6,
      S: 4,
      s: 4,
      Q: 4,
      q: 4,
      T: 2,
      t: 2,
      A: 7,
      a: 7
    };
    var isCommand = (c2) => {
      return c2 in argsCountPerCommand;
    };
    var isWsp = (c2) => {
      const codePoint = c2.codePointAt(0);
      return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
    };
    var isDigit = (c2) => {
      const codePoint = c2.codePointAt(0);
      if (codePoint == null) {
        return false;
      }
      return 48 <= codePoint && codePoint <= 57;
    };
    var readNumber = (string2, cursor) => {
      let i2 = cursor;
      let value = "";
      let state = "none";
      for (; i2 < string2.length; i2 += 1) {
        const c2 = string2[i2];
        if (c2 === "+" || c2 === "-") {
          if (state === "none") {
            state = "sign";
            value += c2;
            continue;
          }
          if (state === "e") {
            state = "exponent_sign";
            value += c2;
            continue;
          }
        }
        if (isDigit(c2)) {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "whole";
            value += c2;
            continue;
          }
          if (state === "decimal_point" || state === "decimal") {
            state = "decimal";
            value += c2;
            continue;
          }
          if (state === "e" || state === "exponent_sign" || state === "exponent") {
            state = "exponent";
            value += c2;
            continue;
          }
        }
        if (c2 === ".") {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "decimal_point";
            value += c2;
            continue;
          }
        }
        if (c2 === "E" || c2 == "e") {
          if (state === "whole" || state === "decimal_point" || state === "decimal") {
            state = "e";
            value += c2;
            continue;
          }
        }
        break;
      }
      const number = Number.parseFloat(value);
      if (Number.isNaN(number)) {
        return [cursor, null];
      } else {
        return [i2 - 1, number];
      }
    };
    var parsePathData = (string2) => {
      const pathData = [];
      let command = null;
      let args = [];
      let argsCount = 0;
      let canHaveComma = false;
      let hadComma = false;
      for (let i2 = 0; i2 < string2.length; i2 += 1) {
        const c2 = string2.charAt(i2);
        if (isWsp(c2)) {
          continue;
        }
        if (canHaveComma && c2 === ",") {
          if (hadComma) {
            break;
          }
          hadComma = true;
          continue;
        }
        if (isCommand(c2)) {
          if (hadComma) {
            return pathData;
          }
          if (command == null) {
            if (c2 !== "M" && c2 !== "m") {
              return pathData;
            }
          } else {
            if (args.length !== 0) {
              return pathData;
            }
          }
          command = c2;
          args = [];
          argsCount = argsCountPerCommand[command];
          canHaveComma = false;
          if (argsCount === 0) {
            pathData.push({ command, args });
          }
          continue;
        }
        if (command == null) {
          return pathData;
        }
        let newCursor = i2;
        let number = null;
        if (command === "A" || command === "a") {
          const position = args.length;
          if (position === 0 || position === 1) {
            if (c2 !== "+" && c2 !== "-") {
              [newCursor, number] = readNumber(string2, i2);
            }
          }
          if (position === 2 || position === 5 || position === 6) {
            [newCursor, number] = readNumber(string2, i2);
          }
          if (position === 3 || position === 4) {
            if (c2 === "0") {
              number = 0;
            }
            if (c2 === "1") {
              number = 1;
            }
          }
        } else {
          [newCursor, number] = readNumber(string2, i2);
        }
        if (number == null) {
          return pathData;
        }
        args.push(number);
        canHaveComma = true;
        hadComma = false;
        i2 = newCursor;
        if (args.length === argsCount) {
          pathData.push({ command, args });
          if (command === "M") {
            command = "L";
          }
          if (command === "m") {
            command = "l";
          }
          args = [];
        }
      }
      return pathData;
    };
    exports.parsePathData = parsePathData;
    var stringifyNumber2 = (number, precision) => {
      if (precision != null) {
        const ratio = 10 ** precision;
        number = Math.round(number * ratio) / ratio;
      }
      return number.toString().replace(/^0\./, ".").replace(/^-0\./, "-.");
    };
    var stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
      let result = "";
      let prev = "";
      for (let i2 = 0; i2 < args.length; i2 += 1) {
        const number = args[i2];
        const numberString = stringifyNumber2(number, precision);
        if (disableSpaceAfterFlags && (command === "A" || command === "a") && (i2 % 7 === 4 || i2 % 7 === 5)) {
          result += numberString;
        } else if (i2 === 0 || numberString.startsWith("-")) {
          result += numberString;
        } else if (prev.includes(".") && numberString.startsWith(".")) {
          result += numberString;
        } else {
          result += ` ${numberString}`;
        }
        prev = numberString;
      }
      return result;
    };
    var stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {
      let combined = [];
      for (let i2 = 0; i2 < pathData.length; i2 += 1) {
        const { command, args } = pathData[i2];
        if (i2 === 0) {
          combined.push({ command, args });
        } else {
          const last = combined[combined.length - 1];
          if (i2 === 1) {
            if (command === "L") {
              last.command = "M";
            }
            if (command === "l") {
              last.command = "m";
            }
          }
          if (last.command === command && last.command !== "M" && last.command !== "m" || last.command === "M" && command === "L" || last.command === "m" && command === "l") {
            last.args = [...last.args, ...args];
          } else {
            combined.push({ command, args });
          }
        }
      }
      let result = "";
      for (const { command, args } of combined) {
        result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
      }
      return result;
    };
    exports.stringifyPathData = stringifyPathData;
  }
});

// node_modules/svgo/plugins/removeHiddenElems.js
var require_removeHiddenElems = __commonJS({
  "node_modules/svgo/plugins/removeHiddenElems.js"(exports) {
    "use strict";
    var {
      querySelector,
      closestByName,
      detachNodeFromParent
    } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { parsePathData } = require_path2();
    exports.name = "removeHiddenElems";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes hidden elements (zero sized, with absent attributes)";
    exports.fn = (root, params) => {
      const {
        isHidden = true,
        displayNone = true,
        opacity0 = true,
        circleR0 = true,
        ellipseRX0 = true,
        ellipseRY0 = true,
        rectWidth0 = true,
        rectHeight0 = true,
        patternWidth0 = true,
        patternHeight0 = true,
        imageWidth0 = true,
        imageHeight0 = true,
        pathEmptyD = true,
        polylineEmptyPoints = true,
        polygonEmptyPoints = true
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            const computedStyle = computeStyle(stylesheet, node);
            if (isHidden && computedStyle.visibility && computedStyle.visibility.type === "static" && computedStyle.visibility.value === "hidden" && querySelector(node, "[visibility=visible]") == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (displayNone && computedStyle.display && computedStyle.display.type === "static" && computedStyle.display.value === "none" && node.name !== "marker") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === "static" && computedStyle.opacity.value === "0" && closestByName(node, "clipPath") == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (circleR0 && node.name === "circle" && node.children.length === 0 && node.attributes.r === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (ellipseRX0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.rx === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (ellipseRY0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.ry === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (rectHeight0 && rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (patternWidth0 && node.name === "pattern" && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (patternHeight0 && node.name === "pattern" && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (imageWidth0 && node.name === "image" && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (imageHeight0 && node.name === "image" && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (pathEmptyD && node.name === "path") {
              if (node.attributes.d == null) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              const pathData = parsePathData(node.attributes.d);
              if (pathData.length === 0) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (pathData.length === 1 && computedStyle["marker-start"] == null && computedStyle["marker-end"] == null) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              return;
            }
            if (polylineEmptyPoints && node.name === "polyline" && node.attributes.points == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (polygonEmptyPoints && node.name === "polygon" && node.attributes.points == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyText.js
var require_removeEmptyText = __commonJS({
  "node_modules/svgo/plugins/removeEmptyText.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeEmptyText";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes empty <text> elements";
    exports.fn = (root, params) => {
      const { text = true, tspan = true, tref = true } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (text && node.name === "text" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tspan && node.name === "tspan" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tref && node.name === "tref" && node.attributes["xlink:href"] == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertShapeToPath.js
var require_convertShapeToPath = __commonJS({
  "node_modules/svgo/plugins/convertShapeToPath.js"(exports) {
    "use strict";
    var { stringifyPathData } = require_path2();
    var { detachNodeFromParent } = require_xast();
    exports.name = "convertShapeToPath";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "converts basic shapes to more compact path form";
    var regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports.fn = (root, params) => {
      const { convertArcs = false, floatPrecision: precision } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "rect" && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {
              const x2 = Number(node.attributes.x || "0");
              const y2 = Number(node.attributes.y || "0");
              const width = Number(node.attributes.width);
              const height = Number(node.attributes.height);
              if (Number.isNaN(x2 - y2 + width - height))
                return;
              const pathData = [
                { command: "M", args: [x2, y2] },
                { command: "H", args: [x2 + width] },
                { command: "V", args: [y2 + height] },
                { command: "H", args: [x2] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x;
              delete node.attributes.y;
              delete node.attributes.width;
              delete node.attributes.height;
            }
            if (node.name === "line") {
              const x1 = Number(node.attributes.x1 || "0");
              const y1 = Number(node.attributes.y1 || "0");
              const x2 = Number(node.attributes.x2 || "0");
              const y2 = Number(node.attributes.y2 || "0");
              if (Number.isNaN(x1 - y1 + x2 - y2))
                return;
              const pathData = [
                { command: "M", args: [x1, y1] },
                { command: "L", args: [x2, y2] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x1;
              delete node.attributes.y1;
              delete node.attributes.x2;
              delete node.attributes.y2;
            }
            if ((node.name === "polyline" || node.name === "polygon") && node.attributes.points != null) {
              const coords = (node.attributes.points.match(regNumber) || []).map(
                Number
              );
              if (coords.length < 4) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              const pathData = [];
              for (let i2 = 0; i2 < coords.length; i2 += 2) {
                pathData.push({
                  command: i2 === 0 ? "M" : "L",
                  args: coords.slice(i2, i2 + 2)
                });
              }
              if (node.name === "polygon") {
                pathData.push({ command: "z", args: [] });
              }
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.points;
            }
            if (node.name === "circle" && convertArcs) {
              const cx = Number(node.attributes.cx || "0");
              const cy = Number(node.attributes.cy || "0");
              const r2 = Number(node.attributes.r || "0");
              if (Number.isNaN(cx - cy + r2)) {
                return;
              }
              const pathData = [
                { command: "M", args: [cx, cy - r2] },
                { command: "A", args: [r2, r2, 0, 1, 0, cx, cy + r2] },
                { command: "A", args: [r2, r2, 0, 1, 0, cx, cy - r2] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.r;
            }
            if (node.name === "ellipse" && convertArcs) {
              const ecx = Number(node.attributes.cx || "0");
              const ecy = Number(node.attributes.cy || "0");
              const rx = Number(node.attributes.rx || "0");
              const ry = Number(node.attributes.ry || "0");
              if (Number.isNaN(ecx - ecy + rx - ry)) {
                return;
              }
              const pathData = [
                { command: "M", args: [ecx, ecy - ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.rx;
              delete node.attributes.ry;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertEllipseToCircle.js
var require_convertEllipseToCircle = __commonJS({
  "node_modules/svgo/plugins/convertEllipseToCircle.js"(exports) {
    "use strict";
    exports.name = "convertEllipseToCircle";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "converts non-eccentric <ellipse>s to <circle>s";
    exports.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "ellipse") {
              const rx = node.attributes.rx || "0";
              const ry = node.attributes.ry || "0";
              if (rx === ry || rx === "auto" || ry === "auto") {
                node.name = "circle";
                const radius = rx === "auto" ? ry : rx;
                delete node.attributes.rx;
                delete node.attributes.ry;
                node.attributes.r = radius;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveElemsAttrsToGroup.js
var require_moveElemsAttrsToGroup = __commonJS({
  "node_modules/svgo/plugins/moveElemsAttrsToGroup.js"(exports) {
    "use strict";
    var { visit: visit3 } = require_xast();
    var { inheritableAttrs, pathElems } = require_collections();
    exports.type = "visitor";
    exports.name = "moveElemsAttrsToGroup";
    exports.active = true;
    exports.description = "Move common attributes of group children to the group";
    exports.fn = (root) => {
      let deoptimizedWithStyles = false;
      visit3(root, {
        element: {
          enter: (node) => {
            if (node.name === "style") {
              deoptimizedWithStyles = true;
            }
          }
        }
      });
      return {
        element: {
          exit: (node) => {
            if (node.name !== "g" || node.children.length <= 1) {
              return;
            }
            if (deoptimizedWithStyles) {
              return;
            }
            const commonAttributes = /* @__PURE__ */ new Map();
            let initial = true;
            let everyChildIsPath = true;
            for (const child of node.children) {
              if (child.type === "element") {
                if (pathElems.includes(child.name) === false) {
                  everyChildIsPath = false;
                }
                if (initial) {
                  initial = false;
                  for (const [name, value] of Object.entries(child.attributes)) {
                    if (inheritableAttrs.includes(name)) {
                      commonAttributes.set(name, value);
                    }
                  }
                } else {
                  for (const [name, value] of commonAttributes) {
                    if (child.attributes[name] !== value) {
                      commonAttributes.delete(name);
                    }
                  }
                }
              }
            }
            if (node.attributes["clip-path"] != null || node.attributes.mask != null) {
              commonAttributes.delete("transform");
            }
            if (everyChildIsPath) {
              commonAttributes.delete("transform");
            }
            for (const [name, value] of commonAttributes) {
              if (name === "transform") {
                if (node.attributes.transform != null) {
                  node.attributes.transform = `${node.attributes.transform} ${value}`;
                } else {
                  node.attributes.transform = value;
                }
              } else {
                node.attributes[name] = value;
              }
            }
            for (const child of node.children) {
              if (child.type === "element") {
                for (const [name] of commonAttributes) {
                  delete child.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveGroupAttrsToElems.js
var require_moveGroupAttrsToElems = __commonJS({
  "node_modules/svgo/plugins/moveGroupAttrsToElems.js"(exports) {
    "use strict";
    var { pathElems, referencesProps } = require_collections();
    exports.name = "moveGroupAttrsToElems";
    exports.type = "perItem";
    exports.active = true;
    exports.description = "moves some group attributes to the content elements";
    var pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
    exports.fn = function(item) {
      if (item.type === "element" && item.name === "g" && item.children.length !== 0 && item.attributes.transform != null && Object.entries(item.attributes).some(
        ([name, value]) => referencesProps.includes(name) && value.includes("url(")
      ) === false && item.children.every(
        (inner) => pathElemsWithGroupsAndText.includes(inner.name) && inner.attributes.id == null
      )) {
        for (const inner of item.children) {
          const value = item.attributes.transform;
          if (inner.attributes.transform != null) {
            inner.attributes.transform = value + " " + inner.attributes.transform;
          } else {
            inner.attributes.transform = value;
          }
        }
        delete item.attributes.transform;
      }
    };
  }
});

// node_modules/svgo/plugins/collapseGroups.js
var require_collapseGroups = __commonJS({
  "node_modules/svgo/plugins/collapseGroups.js"(exports) {
    "use strict";
    var { inheritableAttrs, elemsGroups } = require_collections();
    exports.type = "visitor";
    exports.name = "collapseGroups";
    exports.active = true;
    exports.description = "collapses useless groups";
    var hasAnimatedAttr = (node, name) => {
      if (node.type === "element") {
        if (elemsGroups.animation.includes(node.name) && node.attributes.attributeName === name) {
          return true;
        }
        for (const child of node.children) {
          if (hasAnimatedAttr(child, name)) {
            return true;
          }
        }
      }
      return false;
    };
    exports.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (parentNode.type === "root" || parentNode.name === "switch") {
              return;
            }
            if (node.name !== "g" || node.children.length === 0) {
              return;
            }
            if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {
              const firstChild = node.children[0];
              if (firstChild.type === "element" && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes["clip-path"] == null && node.attributes.mask == null || firstChild.name === "g" && node.attributes.transform == null && firstChild.attributes.transform == null)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (hasAnimatedAttr(firstChild, name)) {
                    return;
                  }
                  if (firstChild.attributes[name] == null) {
                    firstChild.attributes[name] = value;
                  } else if (name === "transform") {
                    firstChild.attributes[name] = value + " " + firstChild.attributes[name];
                  } else if (firstChild.attributes[name] === "inherit") {
                    firstChild.attributes[name] = value;
                  } else if (inheritableAttrs.includes(name) === false && firstChild.attributes[name] !== value) {
                    return;
                  }
                  delete node.attributes[name];
                }
              }
            }
            if (Object.keys(node.attributes).length === 0) {
              for (const child of node.children) {
                if (child.type === "element" && elemsGroups.animation.includes(child.name)) {
                  return;
                }
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                child.parentNode = parentNode;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/_path.js
var require_path3 = __commonJS({
  "node_modules/svgo/plugins/_path.js"(exports) {
    "use strict";
    var { parsePathData, stringifyPathData } = require_path2();
    var prevCtrlPoint;
    var path2js = (path) => {
      if (path.pathJS)
        return path.pathJS;
      const pathData = [];
      const newPathData = parsePathData(path.attributes.d);
      for (const { command, args } of newPathData) {
        pathData.push({ command, args });
      }
      if (pathData.length && pathData[0].command == "m") {
        pathData[0].command = "M";
      }
      path.pathJS = pathData;
      return pathData;
    };
    exports.path2js = path2js;
    var convertRelativeToAbsolute = (data) => {
      const newData = [];
      let start = [0, 0];
      let cursor = [0, 0];
      for (let { command, args } of data) {
        args = args.slice();
        if (command === "m") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "M";
        }
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "h") {
          args[0] += cursor[0];
          command = "H";
        }
        if (command === "H") {
          cursor[0] = args[0];
        }
        if (command === "v") {
          args[0] += cursor[1];
          command = "V";
        }
        if (command === "V") {
          cursor[1] = args[0];
        }
        if (command === "l") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "L";
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "c") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          args[4] += cursor[0];
          args[5] += cursor[1];
          command = "C";
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
        }
        if (command === "s") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "S";
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "q") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "Q";
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "t") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "T";
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "a") {
          args[5] += cursor[0];
          args[6] += cursor[1];
          command = "A";
        }
        if (command === "A") {
          cursor[0] = args[5];
          cursor[1] = args[6];
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
          command = "z";
        }
        newData.push({ command, args });
      }
      return newData;
    };
    exports.js2path = function(path, data, params) {
      path.pathJS = data;
      const pathData = [];
      for (const item of data) {
        if (pathData.length !== 0 && (item.command === "M" || item.command === "m")) {
          const last = pathData[pathData.length - 1];
          if (last.command === "M" || last.command === "m") {
            pathData.pop();
          }
        }
        pathData.push({
          command: item.command,
          args: item.args
        });
      }
      path.attributes.d = stringifyPathData({
        pathData,
        precision: params.floatPrecision,
        disableSpaceAfterFlags: params.noSpaceAfterFlags
      });
    };
    function set2(dest, source) {
      dest[0] = source[source.length - 2];
      dest[1] = source[source.length - 1];
      return dest;
    }
    exports.intersects = function(path1, path2) {
      const points1 = gatherPoints(convertRelativeToAbsolute(path1));
      const points2 = gatherPoints(convertRelativeToAbsolute(path2));
      if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every((set1) => {
        return points2.list.every((set22) => {
          return set1.list[set1.maxX][0] <= set22.list[set22.minX][0] || set22.list[set22.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set22.list[set22.minY][1] || set22.list[set22.maxY][1] <= set1.list[set1.minY][1];
        });
      }))
        return false;
      const hullNest1 = points1.list.map(convexHull);
      const hullNest2 = points2.list.map(convexHull);
      return hullNest1.some(function(hull1) {
        if (hull1.list.length < 3)
          return false;
        return hullNest2.some(function(hull2) {
          if (hull2.list.length < 3)
            return false;
          var simplex = [getSupport(hull1, hull2, [1, 0])], direction = minus(simplex[0]);
          var iterations = 1e4;
          while (true) {
            if (iterations-- == 0) {
              console.error(
                "Error: infinite loop while processing mergePaths plugin."
              );
              return true;
            }
            simplex.push(getSupport(hull1, hull2, direction));
            if (dot(direction, simplex[simplex.length - 1]) <= 0)
              return false;
            if (processSimplex(simplex, direction))
              return true;
          }
        });
      });
      function getSupport(a2, b2, direction) {
        return sub(supportPoint(a2, direction), supportPoint(b2, minus(direction)));
      }
      function supportPoint(polygon, direction) {
        var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY, max = -Infinity, value;
        while ((value = dot(polygon.list[index], direction)) > max) {
          max = value;
          index = ++index % polygon.list.length;
        }
        return polygon.list[(index || polygon.list.length) - 1];
      }
    };
    function processSimplex(simplex, direction) {
      if (simplex.length == 2) {
        let a2 = simplex[1], b2 = simplex[0], AO = minus(simplex[1]), AB = sub(b2, a2);
        if (dot(AO, AB) > 0) {
          set2(direction, orth(AB, a2));
        } else {
          set2(direction, AO);
          simplex.shift();
        }
      } else {
        let a2 = simplex[2], b2 = simplex[1], c2 = simplex[0], AB = sub(b2, a2), AC = sub(c2, a2), AO = minus(a2), ACB = orth(AB, AC), ABC = orth(AC, AB);
        if (dot(ACB, AO) > 0) {
          if (dot(AB, AO) > 0) {
            set2(direction, ACB);
            simplex.shift();
          } else {
            set2(direction, AO);
            simplex.splice(0, 2);
          }
        } else if (dot(ABC, AO) > 0) {
          if (dot(AC, AO) > 0) {
            set2(direction, ABC);
            simplex.splice(1, 1);
          } else {
            set2(direction, AO);
            simplex.splice(0, 2);
          }
        } else
          return true;
      }
      return false;
    }
    function minus(v2) {
      return [-v2[0], -v2[1]];
    }
    function sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    }
    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function orth(v2, from) {
      var o2 = [-v2[1], v2[0]];
      return dot(o2, minus(from)) < 0 ? minus(o2) : o2;
    }
    function gatherPoints(pathData) {
      const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
      const addPoint = (path, point) => {
        if (!path.list.length || point[1] > path.list[path.maxY][1]) {
          path.maxY = path.list.length;
          points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];
        }
        if (!path.list.length || point[0] > path.list[path.maxX][0]) {
          path.maxX = path.list.length;
          points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];
        }
        if (!path.list.length || point[1] < path.list[path.minY][1]) {
          path.minY = path.list.length;
          points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];
        }
        if (!path.list.length || point[0] < path.list[path.minX][0]) {
          path.minX = path.list.length;
          points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];
        }
        path.list.push(point);
      };
      for (let i2 = 0; i2 < pathData.length; i2 += 1) {
        const pathDataItem = pathData[i2];
        let subPath = points.list.length === 0 ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : points.list[points.list.length - 1];
        let prev = i2 === 0 ? null : pathData[i2 - 1];
        let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
        let data = pathDataItem.args;
        let ctrlPoint = basePoint;
        const toAbsolute = (n2, i3) => n2 + (basePoint == null ? 0 : basePoint[i3 % 2]);
        switch (pathDataItem.command) {
          case "M":
            subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
            points.list.push(subPath);
            break;
          case "H":
            if (basePoint != null) {
              addPoint(subPath, [data[0], basePoint[1]]);
            }
            break;
          case "V":
            if (basePoint != null) {
              addPoint(subPath, [basePoint[0], data[0]]);
            }
            break;
          case "Q":
            addPoint(subPath, data.slice(0, 2));
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "T":
            if (basePoint != null && prev != null && (prev.command == "Q" || prev.command == "T")) {
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
              addPoint(subPath, ctrlPoint);
              prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
            }
            break;
          case "C":
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + data[0]),
                0.5 * (basePoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            addPoint(subPath, [
              0.5 * (data[2] + data[4]),
              0.5 * (data[3] + data[5])
            ]);
            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
            break;
          case "S":
            if (basePoint != null && prev != null && (prev.command == "C" || prev.command == "S")) {
              addPoint(subPath, [
                basePoint[0] + 0.5 * prevCtrlPoint[0],
                basePoint[1] + 0.5 * prevCtrlPoint[1]
              ]);
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
            }
            if (ctrlPoint != null) {
              addPoint(subPath, [
                0.5 * (ctrlPoint[0] + data[0]),
                0.5 * (ctrlPoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "A":
            if (basePoint != null) {
              var curves = a2c.apply(0, basePoint.concat(data));
              for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
                if (basePoint != null) {
                  addPoint(subPath, [
                    0.5 * (basePoint[0] + cData[0]),
                    0.5 * (basePoint[1] + cData[1])
                  ]);
                }
                addPoint(subPath, [
                  0.5 * (cData[0] + cData[2]),
                  0.5 * (cData[1] + cData[3])
                ]);
                addPoint(subPath, [
                  0.5 * (cData[2] + cData[4]),
                  0.5 * (cData[3] + cData[5])
                ]);
                if (curves.length)
                  addPoint(subPath, basePoint = cData.slice(-2));
              }
            }
            break;
        }
        if (data.length >= 2)
          addPoint(subPath, data.slice(-2));
      }
      return points;
    }
    function convexHull(points) {
      points.list.sort(function(a2, b2) {
        return a2[0] == b2[0] ? a2[1] - b2[1] : a2[0] - b2[0];
      });
      var lower = [], minY = 0, bottom = 0;
      for (let i2 = 0; i2 < points.list.length; i2++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i2]) <= 0) {
          lower.pop();
        }
        if (points.list[i2][1] < points.list[minY][1]) {
          minY = i2;
          bottom = lower.length;
        }
        lower.push(points.list[i2]);
      }
      var upper = [], maxY = points.list.length - 1, top = 0;
      for (let i2 = points.list.length; i2--; ) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i2]) <= 0) {
          upper.pop();
        }
        if (points.list[i2][1] > points.list[maxY][1]) {
          maxY = i2;
          top = upper.length;
        }
        upper.push(points.list[i2]);
      }
      upper.pop();
      lower.pop();
      const hullList = lower.concat(upper);
      const hull = {
        list: hullList,
        minX: 0,
        maxX: lower.length,
        minY: bottom,
        maxY: (lower.length + top) % hullList.length
      };
      return hull;
    }
    function cross(o2, a2, b2) {
      return (a2[0] - o2[0]) * (b2[1] - o2[1]) - (a2[1] - o2[1]) * (b2[0] - o2[0]);
    }
    var a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {
      const _120 = Math.PI * 120 / 180;
      const rad = Math.PI / 180 * (+angle || 0);
      let res = [];
      const rotateX = (x4, y4, rad2) => {
        return x4 * Math.cos(rad2) - y4 * Math.sin(rad2);
      };
      const rotateY = (x4, y4, rad2) => {
        return x4 * Math.sin(rad2) + y4 * Math.cos(rad2);
      };
      if (!recursive) {
        x1 = rotateX(x1, y1, -rad);
        y1 = rotateY(x1, y1, -rad);
        x2 = rotateX(x2, y2, -rad);
        y2 = rotateY(x2, y2, -rad);
        var x3 = (x1 - x2) / 2, y3 = (y1 - y2) / 2;
        var h2 = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
        if (h2 > 1) {
          h2 = Math.sqrt(h2);
          rx = h2 * rx;
          ry = h2 * ry;
        }
        var rx2 = rx * rx;
        var ry2 = ry * ry;
        var k2 = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(
          Math.abs(
            (rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)
          )
        );
        var cx = k2 * rx * y3 / ry + (x1 + x2) / 2;
        var cy = k2 * -ry * x3 / rx + (y1 + y2) / 2;
        var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
        var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        f1 < 0 && (f1 = Math.PI * 2 + f1);
        f2 < 0 && (f2 = Math.PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - Math.PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - Math.PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (Math.abs(df) > _120) {
        var f2old = f2, x2old = x2, y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2);
        y2 = cy + ry * Math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
          f2,
          f2old,
          cx,
          cy
        ]);
      }
      df = f2 - f1;
      var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t2 = Math.tan(df / 4), hx = 4 / 3 * rx * t2, hy = 4 / 3 * ry * t2, m2 = [
        -hx * s1,
        hy * c1,
        x2 + hx * s2 - x1,
        y2 - hy * c2 - y1,
        x2 - x1,
        y2 - y1
      ];
      if (recursive) {
        return m2.concat(res);
      } else {
        res = m2.concat(res);
        var newres = [];
        for (var i2 = 0, n2 = res.length; i2 < n2; i2++) {
          newres[i2] = i2 % 2 ? rotateY(res[i2 - 1], res[i2], rad) : rotateX(res[i2], res[i2 + 1], rad);
        }
        return newres;
      }
    };
  }
});

// node_modules/svgo/plugins/_transforms.js
var require_transforms = __commonJS({
  "node_modules/svgo/plugins/_transforms.js"(exports) {
    "use strict";
    var regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;
    var regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
    var regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports.transform2js = (transformString) => {
      const transforms = [];
      let current = null;
      for (const item of transformString.split(regTransformSplit)) {
        var num;
        if (item) {
          if (regTransformTypes.test(item)) {
            current = { name: item, data: [] };
            transforms.push(current);
          } else {
            while (num = regNumericValues.exec(item)) {
              num = Number(num);
              if (current != null) {
                current.data.push(num);
              }
            }
          }
        }
      }
      return current == null || current.data.length == 0 ? [] : transforms;
    };
    exports.transformsMultiply = (transforms) => {
      const matrixData = transforms.map((transform) => {
        if (transform.name === "matrix") {
          return transform.data;
        }
        return transformToMatrix(transform);
      });
      const matrixTransform = {
        name: "matrix",
        data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []
      };
      return matrixTransform;
    };
    var mth = {
      rad: (deg) => {
        return deg * Math.PI / 180;
      },
      deg: (rad) => {
        return rad * 180 / Math.PI;
      },
      cos: (deg) => {
        return Math.cos(mth.rad(deg));
      },
      acos: (val, floatPrecision) => {
        return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));
      },
      sin: (deg) => {
        return Math.sin(mth.rad(deg));
      },
      asin: (val, floatPrecision) => {
        return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));
      },
      tan: (deg) => {
        return Math.tan(mth.rad(deg));
      },
      atan: (val, floatPrecision) => {
        return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));
      }
    };
    exports.matrixToTransform = (transform, params) => {
      let floatPrecision = params.floatPrecision;
      let data = transform.data;
      let transforms = [];
      let sx = Number(
        Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)
      );
      let sy = Number(
        ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
          params.transformPrecision
        )
      );
      let colsSum = data[0] * data[2] + data[1] * data[3];
      let rowsSum = data[0] * data[1] + data[2] * data[3];
      let scaleBefore = rowsSum != 0 || sx == sy;
      if (data[4] || data[5]) {
        transforms.push({
          name: "translate",
          data: data.slice(4, data[5] ? 6 : 5)
        });
      }
      if (!data[1] && data[2]) {
        transforms.push({
          name: "skewX",
          data: [mth.atan(data[2] / sy, floatPrecision)]
        });
      } else if (data[1] && !data[2]) {
        transforms.push({
          name: "skewY",
          data: [mth.atan(data[1] / data[0], floatPrecision)]
        });
        sx = data[0];
        sy = data[3];
      } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {
        if (!scaleBefore) {
          sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
          sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
          transforms.push({ name: "scale", data: [sx, sy] });
        }
        var angle = Math.min(Math.max(-1, data[0] / sx), 1), rotate = [
          mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)
        ];
        if (rotate[0])
          transforms.push({ name: "rotate", data: rotate });
        if (rowsSum && colsSum)
          transforms.push({
            name: "skewX",
            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]
          });
        if (rotate[0] && (data[4] || data[5])) {
          transforms.shift();
          var cos = data[0] / sx, sin = data[1] / (scaleBefore ? sx : sy), x2 = data[4] * (scaleBefore ? 1 : sy), y2 = data[5] * (scaleBefore ? 1 : sx), denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore ? 1 : sx * sy);
          rotate.push(((1 - cos) * x2 - sin * y2) / denom);
          rotate.push(((1 - cos) * y2 + sin * x2) / denom);
        }
      } else if (data[1] || data[2]) {
        return [transform];
      }
      if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length)
        transforms.push({
          name: "scale",
          data: sx == sy ? [sx] : [sx, sy]
        });
      return transforms;
    };
    var transformToMatrix = (transform) => {
      if (transform.name === "matrix") {
        return transform.data;
      }
      switch (transform.name) {
        case "translate":
          return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
        case "scale":
          return [
            transform.data[0],
            0,
            0,
            transform.data[1] || transform.data[0],
            0,
            0
          ];
        case "rotate":
          var cos = mth.cos(transform.data[0]), sin = mth.sin(transform.data[0]), cx = transform.data[1] || 0, cy = transform.data[2] || 0;
          return [
            cos,
            sin,
            -sin,
            cos,
            (1 - cos) * cx + sin * cy,
            (1 - cos) * cy - sin * cx
          ];
        case "skewX":
          return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
        case "skewY":
          return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
        default:
          throw Error(`Unknown transform ${transform.name}`);
      }
    };
    exports.transformArc = (cursor, arc, transform) => {
      const x2 = arc[5] - cursor[0];
      const y2 = arc[6] - cursor[1];
      let a2 = arc[0];
      let b2 = arc[1];
      const rot = arc[2] * Math.PI / 180;
      const cos = Math.cos(rot);
      const sin = Math.sin(rot);
      if (a2 > 0 && b2 > 0) {
        let h2 = Math.pow(x2 * cos + y2 * sin, 2) / (4 * a2 * a2) + Math.pow(y2 * cos - x2 * sin, 2) / (4 * b2 * b2);
        if (h2 > 1) {
          h2 = Math.sqrt(h2);
          a2 *= h2;
          b2 *= h2;
        }
      }
      const ellipse = [a2 * cos, a2 * sin, -b2 * sin, b2 * cos, 0, 0];
      const m2 = multiplyTransformMatrices(transform, ellipse);
      const lastCol = m2[2] * m2[2] + m2[3] * m2[3];
      const squareSum = m2[0] * m2[0] + m2[1] * m2[1] + lastCol;
      const root = Math.hypot(m2[0] - m2[3], m2[1] + m2[2]) * Math.hypot(m2[0] + m2[3], m2[1] - m2[2]);
      if (!root) {
        arc[0] = arc[1] = Math.sqrt(squareSum / 2);
        arc[2] = 0;
      } else {
        const majorAxisSqr = (squareSum + root) / 2;
        const minorAxisSqr = (squareSum - root) / 2;
        const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
        const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
        const rowsSum = m2[0] * m2[2] + m2[1] * m2[3];
        const term1 = m2[0] * sub + m2[2] * rowsSum;
        const term2 = m2[1] * sub + m2[3] * rowsSum;
        arc[0] = Math.sqrt(majorAxisSqr);
        arc[1] = Math.sqrt(minorAxisSqr);
        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;
      }
      if (transform[0] < 0 !== transform[3] < 0) {
        arc[4] = 1 - arc[4];
      }
      return arc;
    };
    var multiplyTransformMatrices = (a2, b2) => {
      return [
        a2[0] * b2[0] + a2[2] * b2[1],
        a2[1] * b2[0] + a2[3] * b2[1],
        a2[0] * b2[2] + a2[2] * b2[3],
        a2[1] * b2[2] + a2[3] * b2[3],
        a2[0] * b2[4] + a2[2] * b2[5] + a2[4],
        a2[1] * b2[4] + a2[3] * b2[5] + a2[5]
      ];
    };
  }
});

// node_modules/svgo/plugins/_applyTransforms.js
var require_applyTransforms = __commonJS({
  "node_modules/svgo/plugins/_applyTransforms.js"(exports) {
    "use strict";
    var {
      transformsMultiply,
      transform2js,
      transformArc
    } = require_transforms();
    var { removeLeadingZero } = require_tools();
    var { referencesProps, attrsGroupsDefaults } = require_collections();
    var regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    var defaultStrokeWidth = attrsGroupsDefaults.presentation["stroke-width"];
    var applyTransforms = (elem, pathData, params) => {
      if (elem.attributes.transform == null || elem.attributes.transform === "" || elem.attributes.style != null || Object.entries(elem.attributes).some(
        ([name, value]) => referencesProps.includes(name) && value.includes("url(")
      )) {
        return;
      }
      const matrix = transformsMultiply(transform2js(elem.attributes.transform));
      const stroke = elem.computedAttr("stroke");
      const id = elem.computedAttr("id");
      const transformPrecision = params.transformPrecision;
      if (stroke && stroke != "none") {
        if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
          return;
        if (id) {
          let idElem = elem;
          let hasStrokeWidth = false;
          do {
            if (idElem.attributes["stroke-width"]) {
              hasStrokeWidth = true;
            }
          } while (idElem.attributes.id !== id && !hasStrokeWidth && (idElem = idElem.parentNode));
          if (!hasStrokeWidth)
            return;
        }
        const scale = +Math.sqrt(
          matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
        ).toFixed(transformPrecision);
        if (scale !== 1) {
          const strokeWidth = elem.computedAttr("stroke-width") || defaultStrokeWidth;
          if (elem.attributes["vector-effect"] == null || elem.attributes["vector-effect"] !== "non-scaling-stroke") {
            if (elem.attributes["stroke-width"] != null) {
              elem.attributes["stroke-width"] = elem.attributes["stroke-width"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            } else {
              elem.attributes["stroke-width"] = strokeWidth.replace(
                regNumericValues,
                (num) => removeLeadingZero(num * scale)
              );
            }
            if (elem.attributes["stroke-dashoffset"] != null) {
              elem.attributes["stroke-dashoffset"] = elem.attributes["stroke-dashoffset"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            }
            if (elem.attributes["stroke-dasharray"] != null) {
              elem.attributes["stroke-dasharray"] = elem.attributes["stroke-dasharray"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            }
          }
        }
      } else if (id) {
        return;
      }
      applyMatrixToPathData(pathData, matrix.data);
      delete elem.attributes.transform;
      return;
    };
    exports.applyTransforms = applyTransforms;
    var transformAbsolutePoint = (matrix, x2, y2) => {
      const newX = matrix[0] * x2 + matrix[2] * y2 + matrix[4];
      const newY = matrix[1] * x2 + matrix[3] * y2 + matrix[5];
      return [newX, newY];
    };
    var transformRelativePoint = (matrix, x2, y2) => {
      const newX = matrix[0] * x2 + matrix[2] * y2;
      const newY = matrix[1] * x2 + matrix[3] * y2;
      return [newX, newY];
    };
    var applyMatrixToPathData = (pathData, matrix) => {
      const start = [0, 0];
      const cursor = [0, 0];
      for (const pathItem of pathData) {
        let { command, args } = pathItem;
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "H") {
          command = "L";
          args = [args[0], cursor[1]];
        }
        if (command === "h") {
          command = "l";
          args = [args[0], 0];
        }
        if (command === "V") {
          command = "L";
          args = [cursor[0], args[0]];
        }
        if (command === "v") {
          command = "l";
          args = [0, args[0]];
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
          const [x3, y3] = transformAbsolutePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x3;
          args[5] = y3;
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
          const [x3, y3] = transformRelativePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x3;
          args[5] = y3;
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x3, y3] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x3;
          args[3] = y3;
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          const [x3, y3] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x3;
          args[3] = y3;
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x2;
          args[1] = y2;
        }
        if (command === "A") {
          transformArc(cursor, args, matrix);
          cursor[0] = args[5];
          cursor[1] = args[6];
          if (Math.abs(args[2]) > 80) {
            const a2 = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a2;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x2, y2] = transformAbsolutePoint(matrix, args[5], args[6]);
          args[5] = x2;
          args[6] = y2;
        }
        if (command === "a") {
          transformArc([0, 0], args, matrix);
          cursor[0] += args[5];
          cursor[1] += args[6];
          if (Math.abs(args[2]) > 80) {
            const a2 = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a2;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x2, y2] = transformRelativePoint(matrix, args[5], args[6]);
          args[5] = x2;
          args[6] = y2;
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
      }
    };
  }
});

// node_modules/svgo/plugins/convertPathData.js
var require_convertPathData = __commonJS({
  "node_modules/svgo/plugins/convertPathData.js"(exports) {
    "use strict";
    var { collectStylesheet, computeStyle } = require_style();
    var { pathElems } = require_collections();
    var { path2js, js2path } = require_path3();
    var { applyTransforms } = require_applyTransforms();
    var { cleanupOutData } = require_tools();
    exports.name = "convertPathData";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "optimizes path data: writes in shorter form, applies transformations";
    exports.params = {
      applyTransforms: true,
      applyTransformsStroked: true,
      makeArcs: {
        threshold: 2.5,
        tolerance: 0.5
      },
      straightCurves: true,
      lineShorthands: true,
      curveSmoothShorthands: true,
      floatPrecision: 3,
      transformPrecision: 5,
      removeUseless: true,
      collapseRepeated: true,
      utilizeAbsolute: true,
      leadingZero: true,
      negativeExtraSpace: true,
      noSpaceAfterFlags: false,
      forceAbsolutePath: false
    };
    var roundData;
    var precision;
    var error;
    var arcThreshold;
    var arcTolerance;
    exports.fn = (root, params) => {
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            if (pathElems.includes(node.name) && node.attributes.d != null) {
              const computedStyle = computeStyle(stylesheet, node);
              precision = params.floatPrecision;
              error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 0.01;
              roundData = precision > 0 && precision < 20 ? strongRound : round;
              if (params.makeArcs) {
                arcThreshold = params.makeArcs.threshold;
                arcTolerance = params.makeArcs.tolerance;
              }
              const hasMarkerMid = computedStyle["marker-mid"] != null;
              const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === "dynamic" || computedStyle.stroke.value !== "none");
              const maybeHasLinecap = computedStyle["stroke-linecap"] && (computedStyle["stroke-linecap"].type === "dynamic" || computedStyle["stroke-linecap"].value !== "butt");
              const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
              var data = path2js(node);
              if (data.length) {
                if (params.applyTransforms) {
                  applyTransforms(node, data, params);
                }
                convertToRelative(data);
                data = filters(data, params, {
                  maybeHasStrokeAndLinecap,
                  hasMarkerMid
                });
                if (params.utilizeAbsolute) {
                  data = convertToMixed(data, params);
                }
                js2path(node, data, params);
              }
            }
          }
        }
      };
    };
    var convertToRelative = (pathData) => {
      let start = [0, 0];
      let cursor = [0, 0];
      let prevCoords = [0, 0];
      for (let i2 = 0; i2 < pathData.length; i2 += 1) {
        const pathItem = pathData[i2];
        let { command, args } = pathItem;
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "M") {
          if (i2 !== 0) {
            command = "m";
          }
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "L") {
          command = "l";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "h") {
          cursor[0] += args[0];
        }
        if (command === "H") {
          command = "h";
          args[0] -= cursor[0];
          cursor[0] += args[0];
        }
        if (command === "v") {
          cursor[1] += args[0];
        }
        if (command === "V") {
          command = "v";
          args[0] -= cursor[1];
          cursor[1] += args[0];
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "C") {
          command = "c";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          args[4] -= cursor[0];
          args[5] -= cursor[1];
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "S") {
          command = "s";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "Q") {
          command = "q";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "T") {
          command = "t";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "a") {
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "A") {
          command = "a";
          args[5] -= cursor[0];
          args[6] -= cursor[1];
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "Z" || command === "z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
        pathItem.base = prevCoords;
        pathItem.coords = [cursor[0], cursor[1]];
        prevCoords = pathItem.coords;
      }
      return pathData;
    };
    function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
      var stringify17 = data2Path.bind(null, params), relSubpoint = [0, 0], pathBase = [0, 0], prev = {};
      path = path.filter(function(item, index, path2) {
        let command = item.command;
        let data = item.args;
        let next = path2[index + 1];
        if (command !== "Z" && command !== "z") {
          var sdata = data, circle;
          if (command === "s") {
            sdata = [0, 0].concat(data);
            if (command === "c" || command === "s") {
              var pdata = prev.args, n2 = pdata.length;
              sdata[0] = pdata[n2 - 2] - pdata[n2 - 4];
              sdata[1] = pdata[n2 - 1] - pdata[n2 - 3];
            }
          }
          if (params.makeArcs && (command == "c" || command == "s") && isConvex(sdata) && (circle = findCircle(sdata))) {
            var r2 = roundData([circle.radius])[0], angle = findArcAngle(sdata, circle), sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0, arc = {
              command: "a",
              args: [r2, r2, 0, 0, sweep, sdata[4], sdata[5]],
              coords: item.coords.slice(),
              base: item.base
            }, output = [arc], relCenter = [
              circle.center[0] - sdata[4],
              circle.center[1] - sdata[5]
            ], relCircle = { center: relCenter, radius: circle.radius }, arcCurves = [item], hasPrev = 0, suffix = "", nextLonghand;
            if (prev.command == "c" && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle)) {
              arcCurves.unshift(prev);
              arc.base = prev.base;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
              var prevData = prev.command == "a" ? prev.sdata : prev.args;
              var prevAngle = findArcAngle(prevData, {
                center: [
                  prevData[4] + circle.center[0],
                  prevData[5] + circle.center[1]
                ],
                radius: circle.radius
              });
              angle += prevAngle;
              if (angle > Math.PI)
                arc.args[3] = 1;
              hasPrev = 1;
            }
            for (var j2 = index; (next = path2[++j2]) && ~"cs".indexOf(next.command); ) {
              var nextData = next.args;
              if (next.command == "s") {
                nextLonghand = makeLonghand(
                  { command: "s", args: next.args.slice() },
                  path2[j2 - 1].args
                );
                nextData = nextLonghand.args;
                nextLonghand.args = nextData.slice(0, 2);
                suffix = stringify17([nextLonghand]);
              }
              if (isConvex(nextData) && isArc(nextData, relCircle)) {
                angle += findArcAngle(nextData, relCircle);
                if (angle - 2 * Math.PI > 1e-3)
                  break;
                if (angle > Math.PI)
                  arc.args[3] = 1;
                arcCurves.push(next);
                if (2 * Math.PI - angle > 1e-3) {
                  arc.coords = next.coords;
                  arc.args[5] = arc.coords[0] - arc.base[0];
                  arc.args[6] = arc.coords[1] - arc.base[1];
                } else {
                  arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                  arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                  arc.coords = [
                    arc.base[0] + arc.args[5],
                    arc.base[1] + arc.args[6]
                  ];
                  arc = {
                    command: "a",
                    args: [
                      r2,
                      r2,
                      0,
                      0,
                      sweep,
                      next.coords[0] - arc.coords[0],
                      next.coords[1] - arc.coords[1]
                    ],
                    coords: next.coords,
                    base: arc.coords
                  };
                  output.push(arc);
                  j2++;
                  break;
                }
                relCenter[0] -= nextData[4];
                relCenter[1] -= nextData[5];
              } else
                break;
            }
            if ((stringify17(output) + suffix).length < stringify17(arcCurves).length) {
              if (path2[j2] && path2[j2].command == "s") {
                makeLonghand(path2[j2], path2[j2 - 1].args);
              }
              if (hasPrev) {
                var prevArc = output.shift();
                roundData(prevArc.args);
                relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
                relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
                prev.command = "a";
                prev.args = prevArc.args;
                item.base = prev.coords = prevArc.coords;
              }
              arc = output.shift();
              if (arcCurves.length == 1) {
                item.sdata = sdata.slice();
              } else if (arcCurves.length - 1 - hasPrev > 0) {
                path2.splice.apply(
                  path2,
                  [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
                );
              }
              if (!arc)
                return false;
              command = "a";
              data = arc.args;
              item.coords = arc.coords;
            }
          }
          if (precision !== false) {
            if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
              for (var i2 = data.length; i2--; ) {
                data[i2] += item.base[i2 % 2] - relSubpoint[i2 % 2];
              }
            } else if (command == "h") {
              data[0] += item.base[0] - relSubpoint[0];
            } else if (command == "v") {
              data[0] += item.base[1] - relSubpoint[1];
            } else if (command == "a") {
              data[5] += item.base[0] - relSubpoint[0];
              data[6] += item.base[1] - relSubpoint[1];
            }
            roundData(data);
            if (command == "h")
              relSubpoint[0] += data[0];
            else if (command == "v")
              relSubpoint[1] += data[0];
            else {
              relSubpoint[0] += data[data.length - 2];
              relSubpoint[1] += data[data.length - 1];
            }
            roundData(relSubpoint);
            if (command === "M" || command === "m") {
              pathBase[0] = relSubpoint[0];
              pathBase[1] = relSubpoint[1];
            }
          }
          if (params.straightCurves) {
            if (command === "c" && isCurveStraightLine(data) || command === "s" && isCurveStraightLine(sdata)) {
              if (next && next.command == "s")
                makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "q" && isCurveStraightLine(data)) {
              if (next && next.command == "t")
                makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "t" && prev.command !== "q" && prev.command !== "t") {
              command = "l";
              data = data.slice(-2);
            } else if (command === "a" && (data[0] === 0 || data[1] === 0)) {
              command = "l";
              data = data.slice(-2);
            }
          }
          if (params.lineShorthands && command === "l") {
            if (data[1] === 0) {
              command = "h";
              data.pop();
            } else if (data[0] === 0) {
              command = "v";
              data.shift();
            }
          }
          if (params.collapseRepeated && hasMarkerMid === false && (command === "m" || command === "h" || command === "v") && prev.command && command == prev.command.toLowerCase() && (command != "h" && command != "v" || prev.args[0] >= 0 == data[0] >= 0)) {
            prev.args[0] += data[0];
            if (command != "h" && command != "v") {
              prev.args[1] += data[1];
            }
            prev.coords = item.coords;
            path2[index] = prev;
            return false;
          }
          if (params.curveSmoothShorthands && prev.command) {
            if (command === "c") {
              if (prev.command === "c" && data[0] === -(prev.args[2] - prev.args[4]) && data[1] === -(prev.args[3] - prev.args[5])) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command === "s" && data[0] === -(prev.args[0] - prev.args[2]) && data[1] === -(prev.args[1] - prev.args[3])) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command !== "c" && prev.command !== "s" && data[0] === 0 && data[1] === 0) {
                command = "s";
                data = data.slice(2);
              }
            } else if (command === "q") {
              if (prev.command === "q" && data[0] === prev.args[2] - prev.args[0] && data[1] === prev.args[3] - prev.args[1]) {
                command = "t";
                data = data.slice(2);
              } else if (prev.command === "t" && data[2] === prev.args[0] && data[3] === prev.args[1]) {
                command = "t";
                data = data.slice(2);
              }
            }
          }
          if (params.removeUseless && !maybeHasStrokeAndLinecap) {
            if ((command === "l" || command === "h" || command === "v" || command === "q" || command === "t" || command === "c" || command === "s") && data.every(function(i3) {
              return i3 === 0;
            })) {
              path2[index] = prev;
              return false;
            }
            if (command === "a" && data[5] === 0 && data[6] === 0) {
              path2[index] = prev;
              return false;
            }
          }
          item.command = command;
          item.args = data;
          prev = item;
        } else {
          relSubpoint[0] = pathBase[0];
          relSubpoint[1] = pathBase[1];
          if (prev.command === "Z" || prev.command === "z")
            return false;
          prev = item;
        }
        return true;
      });
      return path;
    }
    function convertToMixed(path, params) {
      var prev = path[0];
      path = path.filter(function(item, index) {
        if (index == 0)
          return true;
        if (item.command === "Z" || item.command === "z") {
          prev = item;
          return true;
        }
        var command = item.command, data = item.args, adata = data.slice();
        if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
          for (var i2 = adata.length; i2--; ) {
            adata[i2] += item.base[i2 % 2];
          }
        } else if (command == "h") {
          adata[0] += item.base[0];
        } else if (command == "v") {
          adata[0] += item.base[1];
        } else if (command == "a") {
          adata[5] += item.base[0];
          adata[6] += item.base[1];
        }
        roundData(adata);
        var absoluteDataStr = cleanupOutData(adata, params), relativeDataStr = cleanupOutData(data, params);
        if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))) {
          item.command = command.toUpperCase();
          item.args = adata;
        }
        prev = item;
        return true;
      });
      return path;
    }
    function isConvex(data) {
      var center = getIntersection([
        0,
        0,
        data[2],
        data[3],
        data[0],
        data[1],
        data[4],
        data[5]
      ]);
      return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];
    }
    function getIntersection(coords) {
      var a1 = coords[1] - coords[3], b1 = coords[2] - coords[0], c1 = coords[0] * coords[3] - coords[2] * coords[1], a2 = coords[5] - coords[7], b2 = coords[6] - coords[4], c2 = coords[4] * coords[7] - coords[5] * coords[6], denom = a1 * b2 - a2 * b1;
      if (!denom)
        return;
      var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
      if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {
        return cross;
      }
    }
    function strongRound(data) {
      for (var i2 = data.length; i2-- > 0; ) {
        if (data[i2].toFixed(precision) != data[i2]) {
          var rounded = +data[i2].toFixed(precision - 1);
          data[i2] = +Math.abs(rounded - data[i2]).toFixed(precision + 1) >= error ? +data[i2].toFixed(precision) : rounded;
        }
      }
      return data;
    }
    function round(data) {
      for (var i2 = data.length; i2-- > 0; ) {
        data[i2] = Math.round(data[i2]);
      }
      return data;
    }
    function isCurveStraightLine(data) {
      var i2 = data.length - 2, a2 = -data[i2 + 1], b2 = data[i2], d2 = 1 / (a2 * a2 + b2 * b2);
      if (i2 <= 1 || !isFinite(d2))
        return false;
      while ((i2 -= 2) >= 0) {
        if (Math.sqrt(Math.pow(a2 * data[i2] + b2 * data[i2 + 1], 2) * d2) > error)
          return false;
      }
      return true;
    }
    function makeLonghand(item, data) {
      switch (item.command) {
        case "s":
          item.command = "c";
          break;
        case "t":
          item.command = "q";
          break;
      }
      item.args.unshift(
        data[data.length - 2] - data[data.length - 4],
        data[data.length - 1] - data[data.length - 3]
      );
      return item;
    }
    function getDistance(point1, point2) {
      return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
    }
    function getCubicBezierPoint(curve, t2) {
      var sqrT = t2 * t2, cubT = sqrT * t2, mt = 1 - t2, sqrMt = mt * mt;
      return [
        3 * sqrMt * t2 * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
        3 * sqrMt * t2 * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
      ];
    }
    function findCircle(curve) {
      var midPoint = getCubicBezierPoint(curve, 1 / 2), m1 = [midPoint[0] / 2, midPoint[1] / 2], m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2], center = getIntersection([
        m1[0],
        m1[1],
        m1[0] + m1[1],
        m1[1] - m1[0],
        m2[0],
        m2[1],
        m2[0] + (m2[1] - midPoint[1]),
        m2[1] - (m2[0] - midPoint[0])
      ]), radius = center && getDistance([0, 0], center), tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);
      if (center && radius < 1e15 && [1 / 4, 3 / 4].every(function(point) {
        return Math.abs(
          getDistance(getCubicBezierPoint(curve, point), center) - radius
        ) <= tolerance;
      }))
        return { center, radius };
    }
    function isArc(curve, circle) {
      var tolerance = Math.min(
        arcThreshold * error,
        arcTolerance * circle.radius / 100
      );
      return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function(point) {
        return Math.abs(
          getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius
        ) <= tolerance;
      });
    }
    function isArcPrev(curve, circle) {
      return isArc(curve, {
        center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
        radius: circle.radius
      });
    }
    function findArcAngle(curve, relCircle) {
      var x1 = -relCircle.center[0], y1 = -relCircle.center[1], x2 = curve[4] - relCircle.center[0], y2 = curve[5] - relCircle.center[1];
      return Math.acos(
        (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
      );
    }
    function data2Path(params, pathData) {
      return pathData.reduce(function(pathString, item) {
        var strData = "";
        if (item.args) {
          strData = cleanupOutData(roundData(item.args.slice()), params);
        }
        return pathString + item.command + strData;
      }, "");
    }
  }
});

// node_modules/svgo/plugins/convertTransform.js
var require_convertTransform = __commonJS({
  "node_modules/svgo/plugins/convertTransform.js"(exports) {
    "use strict";
    var { cleanupOutData } = require_tools();
    var {
      transform2js,
      transformsMultiply,
      matrixToTransform
    } = require_transforms();
    exports.type = "visitor";
    exports.name = "convertTransform";
    exports.active = true;
    exports.description = "collapses multiple transformations and optimizes it";
    exports.fn = (_root, params) => {
      const {
        convertToShorts: convertToShorts2 = true,
        degPrecision,
        floatPrecision = 3,
        transformPrecision = 5,
        matrixToTransform: matrixToTransform2 = true,
        shortTranslate = true,
        shortScale = true,
        shortRotate = true,
        removeUseless: removeUseless2 = true,
        collapseIntoOne = true,
        leadingZero = true,
        negativeExtraSpace = false
      } = params;
      const newParams = {
        convertToShorts: convertToShorts2,
        degPrecision,
        floatPrecision,
        transformPrecision,
        matrixToTransform: matrixToTransform2,
        shortTranslate,
        shortScale,
        shortRotate,
        removeUseless: removeUseless2,
        collapseIntoOne,
        leadingZero,
        negativeExtraSpace
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.transform != null) {
              convertTransform(node, "transform", newParams);
            }
            if (node.attributes.gradientTransform != null) {
              convertTransform(node, "gradientTransform", newParams);
            }
            if (node.attributes.patternTransform != null) {
              convertTransform(node, "patternTransform", newParams);
            }
          }
        }
      };
    };
    var convertTransform = (item, attrName, params) => {
      let data = transform2js(item.attributes[attrName]);
      params = definePrecision(data, params);
      if (params.collapseIntoOne && data.length > 1) {
        data = [transformsMultiply(data)];
      }
      if (params.convertToShorts) {
        data = convertToShorts(data, params);
      } else {
        data.forEach((item2) => roundTransform(item2, params));
      }
      if (params.removeUseless) {
        data = removeUseless(data);
      }
      if (data.length) {
        item.attributes[attrName] = js2transform(data, params);
      } else {
        delete item.attributes[attrName];
      }
    };
    var definePrecision = (data, { ...newParams }) => {
      const matrixData = [];
      for (const item of data) {
        if (item.name == "matrix") {
          matrixData.push(...item.data.slice(0, 4));
        }
      }
      let significantDigits = newParams.transformPrecision;
      if (matrixData.length) {
        newParams.transformPrecision = Math.min(
          newParams.transformPrecision,
          Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision
        );
        significantDigits = Math.max.apply(
          Math,
          matrixData.map(
            (n2) => n2.toString().replace(/\D+/g, "").length
          )
        );
      }
      if (newParams.degPrecision == null) {
        newParams.degPrecision = Math.max(
          0,
          Math.min(newParams.floatPrecision, significantDigits - 2)
        );
      }
      return newParams;
    };
    var degRound = (data, params) => {
      if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.degPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatRound = (data, params) => {
      if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.floatPrecision, data);
      } else {
        return round(data);
      }
    };
    var transformRound = (data, params) => {
      if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.transformPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatDigits = (n2) => {
      const str = n2.toString();
      return str.slice(str.indexOf(".")).length - 1;
    };
    var convertToShorts = (transforms, params) => {
      for (var i2 = 0; i2 < transforms.length; i2++) {
        var transform = transforms[i2];
        if (params.matrixToTransform && transform.name === "matrix") {
          var decomposed = matrixToTransform(transform, params);
          if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {
            transforms.splice(i2, 1, ...decomposed);
          }
          transform = transforms[i2];
        }
        roundTransform(transform, params);
        if (params.shortTranslate && transform.name === "translate" && transform.data.length === 2 && !transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortScale && transform.name === "scale" && transform.data.length === 2 && transform.data[0] === transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortRotate && transforms[i2 - 2] && transforms[i2 - 2].name === "translate" && transforms[i2 - 1].name === "rotate" && transforms[i2].name === "translate" && transforms[i2 - 2].data[0] === -transforms[i2].data[0] && transforms[i2 - 2].data[1] === -transforms[i2].data[1]) {
          transforms.splice(i2 - 2, 3, {
            name: "rotate",
            data: [
              transforms[i2 - 1].data[0],
              transforms[i2 - 2].data[0],
              transforms[i2 - 2].data[1]
            ]
          });
          i2 -= 2;
        }
      }
      return transforms;
    };
    var removeUseless = (transforms) => {
      return transforms.filter((transform) => {
        if (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == "rotate") && !transform.data[0] || transform.name == "translate" && !transform.data[0] && !transform.data[1] || transform.name == "scale" && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || transform.name == "matrix" && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {
          return false;
        }
        return true;
      });
    };
    var js2transform = (transformJS, params) => {
      var transformString = "";
      transformJS.forEach((transform) => {
        roundTransform(transform, params);
        transformString += (transformString && " ") + transform.name + "(" + cleanupOutData(transform.data, params) + ")";
      });
      return transformString;
    };
    var roundTransform = (transform, params) => {
      switch (transform.name) {
        case "translate":
          transform.data = floatRound(transform.data, params);
          break;
        case "rotate":
          transform.data = [
            ...degRound(transform.data.slice(0, 1), params),
            ...floatRound(transform.data.slice(1), params)
          ];
          break;
        case "skewX":
        case "skewY":
          transform.data = degRound(transform.data, params);
          break;
        case "scale":
          transform.data = transformRound(transform.data, params);
          break;
        case "matrix":
          transform.data = [
            ...transformRound(transform.data.slice(0, 4), params),
            ...floatRound(transform.data.slice(4), params)
          ];
          break;
      }
      return transform;
    };
    var round = (data) => {
      return data.map(Math.round);
    };
    var smartRound = (precision, data) => {
      for (var i2 = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i2--; ) {
        if (Number(data[i2].toFixed(precision)) !== data[i2]) {
          var rounded = +data[i2].toFixed(precision - 1);
          data[i2] = +Math.abs(rounded - data[i2]).toFixed(precision + 1) >= tolerance ? +data[i2].toFixed(precision) : rounded;
        }
      }
      return data;
    };
  }
});

// node_modules/svgo/plugins/removeEmptyAttrs.js
var require_removeEmptyAttrs = __commonJS({
  "node_modules/svgo/plugins/removeEmptyAttrs.js"(exports) {
    "use strict";
    var { attrsGroups } = require_collections();
    exports.type = "visitor";
    exports.name = "removeEmptyAttrs";
    exports.active = true;
    exports.description = "removes empty attributes";
    exports.fn = () => {
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (value === "" && attrsGroups.conditionalProcessing.includes(name) === false) {
                delete node.attributes[name];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyContainers.js
var require_removeEmptyContainers = __commonJS({
  "node_modules/svgo/plugins/removeEmptyContainers.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports.type = "visitor";
    exports.name = "removeEmptyContainers";
    exports.active = true;
    exports.description = "removes empty container elements";
    exports.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (node.name === "svg" || elemsGroups.container.includes(node.name) === false || node.children.length !== 0) {
              return;
            }
            if (node.name === "pattern" && Object.keys(node.attributes).length !== 0) {
              return;
            }
            if (node.name === "g" && node.attributes.filter != null) {
              return;
            }
            if (node.name === "mask" && node.attributes.id != null) {
              return;
            }
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/mergePaths.js
var require_mergePaths = __commonJS({
  "node_modules/svgo/plugins/mergePaths.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { path2js, js2path, intersects } = require_path3();
    exports.type = "visitor";
    exports.name = "mergePaths";
    exports.active = true;
    exports.description = "merges multiple paths in one if possible";
    exports.fn = (root, params) => {
      const {
        force = false,
        floatPrecision,
        noSpaceAfterFlags = false
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            let prevChild = null;
            for (const child of node.children) {
              if (prevChild == null || prevChild.type !== "element" || prevChild.name !== "path" || prevChild.children.length !== 0 || prevChild.attributes.d == null) {
                prevChild = child;
                continue;
              }
              if (child.type !== "element" || child.name !== "path" || child.children.length !== 0 || child.attributes.d == null) {
                prevChild = child;
                continue;
              }
              const computedStyle = computeStyle(stylesheet, child);
              if (computedStyle["marker-start"] || computedStyle["marker-mid"] || computedStyle["marker-end"]) {
                prevChild = child;
                continue;
              }
              const prevChildAttrs = Object.keys(prevChild.attributes);
              const childAttrs = Object.keys(child.attributes);
              let attributesAreEqual = prevChildAttrs.length === childAttrs.length;
              for (const name of childAttrs) {
                if (name !== "d") {
                  if (prevChild.attributes[name] == null || prevChild.attributes[name] !== child.attributes[name]) {
                    attributesAreEqual = false;
                  }
                }
              }
              const prevPathJS = path2js(prevChild);
              const curPathJS = path2js(child);
              if (attributesAreEqual && (force || !intersects(prevPathJS, curPathJS))) {
                js2path(prevChild, prevPathJS.concat(curPathJS), {
                  floatPrecision,
                  noSpaceAfterFlags
                });
                detachNodeFromParent(child, node);
                continue;
              }
              prevChild = child;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUnusedNS.js
var require_removeUnusedNS = __commonJS({
  "node_modules/svgo/plugins/removeUnusedNS.js"(exports) {
    "use strict";
    exports.type = "visitor";
    exports.name = "removeUnusedNS";
    exports.active = true;
    exports.description = "removes unused namespaces declaration";
    exports.fn = () => {
      const unusedNamespaces = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("xmlns:")) {
                  const local = name.slice("xmlns:".length);
                  unusedNamespaces.add(local);
                }
              }
            }
            if (unusedNamespaces.size !== 0) {
              if (node.name.includes(":")) {
                const [ns] = node.name.split(":");
                if (unusedNamespaces.has(ns)) {
                  unusedNamespaces.delete(ns);
                }
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.includes(":")) {
                  const [ns] = name.split(":");
                  unusedNamespaces.delete(ns);
                }
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of unusedNamespaces) {
                delete node.attributes[`xmlns:${name}`];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortDefsChildren.js
var require_sortDefsChildren = __commonJS({
  "node_modules/svgo/plugins/sortDefsChildren.js"(exports) {
    "use strict";
    exports.type = "visitor";
    exports.name = "sortDefsChildren";
    exports.active = true;
    exports.description = "Sorts children of <defs> to improve compression";
    exports.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "defs") {
              const frequencies = /* @__PURE__ */ new Map();
              for (const child of node.children) {
                if (child.type === "element") {
                  const frequency = frequencies.get(child.name);
                  if (frequency == null) {
                    frequencies.set(child.name, 1);
                  } else {
                    frequencies.set(child.name, frequency + 1);
                  }
                }
              }
              node.children.sort((a2, b2) => {
                if (a2.type !== "element" || b2.type !== "element") {
                  return 0;
                }
                const aFrequency = frequencies.get(a2.name);
                const bFrequency = frequencies.get(b2.name);
                if (aFrequency != null && bFrequency != null) {
                  const frequencyComparison = bFrequency - aFrequency;
                  if (frequencyComparison !== 0) {
                    return frequencyComparison;
                  }
                }
                const lengthComparison = b2.name.length - a2.name.length;
                if (lengthComparison !== 0) {
                  return lengthComparison;
                }
                if (a2.name !== b2.name) {
                  return a2.name > b2.name ? -1 : 1;
                }
                return 0;
              });
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeTitle.js
var require_removeTitle = __commonJS({
  "node_modules/svgo/plugins/removeTitle.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeTitle";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes <title>";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "title") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDesc.js
var require_removeDesc = __commonJS({
  "node_modules/svgo/plugins/removeDesc.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeDesc";
    exports.type = "visitor";
    exports.active = true;
    exports.description = "removes <desc>";
    var standardDescs = /^(Created with|Created using)/;
    exports.fn = (root, params) => {
      const { removeAny = true } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "desc") {
              if (removeAny || node.children.length === 0 || node.children[0].type === "text" && standardDescs.test(node.children[0].value)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/preset-default.js
var require_preset_default = __commonJS({
  "node_modules/svgo/plugins/preset-default.js"(exports, module) {
    "use strict";
    var { createPreset } = require_plugins();
    var removeDoctype = require_removeDoctype();
    var removeXMLProcInst = require_removeXMLProcInst();
    var removeComments = require_removeComments();
    var removeMetadata = require_removeMetadata();
    var removeEditorsNSData = require_removeEditorsNSData();
    var cleanupAttrs = require_cleanupAttrs();
    var mergeStyles = require_mergeStyles();
    var inlineStyles = require_inlineStyles();
    var minifyStyles = require_minifyStyles();
    var cleanupIDs = require_cleanupIDs();
    var removeUselessDefs = require_removeUselessDefs();
    var cleanupNumericValues = require_cleanupNumericValues();
    var convertColors = require_convertColors();
    var removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
    var removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
    var removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
    var removeViewBox = require_removeViewBox();
    var cleanupEnableBackground = require_cleanupEnableBackground();
    var removeHiddenElems = require_removeHiddenElems();
    var removeEmptyText = require_removeEmptyText();
    var convertShapeToPath = require_convertShapeToPath();
    var convertEllipseToCircle = require_convertEllipseToCircle();
    var moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
    var moveGroupAttrsToElems = require_moveGroupAttrsToElems();
    var collapseGroups = require_collapseGroups();
    var convertPathData = require_convertPathData();
    var convertTransform = require_convertTransform();
    var removeEmptyAttrs = require_removeEmptyAttrs();
    var removeEmptyContainers = require_removeEmptyContainers();
    var mergePaths = require_mergePaths();
    var removeUnusedNS = require_removeUnusedNS();
    var sortDefsChildren = require_sortDefsChildren();
    var removeTitle = require_removeTitle();
    var removeDesc = require_removeDesc();
    var presetDefault = createPreset({
      name: "presetDefault",
      plugins: [
        removeDoctype,
        removeXMLProcInst,
        removeComments,
        removeMetadata,
        removeEditorsNSData,
        cleanupAttrs,
        mergeStyles,
        inlineStyles,
        minifyStyles,
        cleanupIDs,
        removeUselessDefs,
        cleanupNumericValues,
        convertColors,
        removeUnknownsAndDefaults,
        removeNonInheritableGroupAttrs,
        removeUselessStrokeAndFill,
        removeViewBox,
        cleanupEnableBackground,
        removeHiddenElems,
        removeEmptyText,
        convertShapeToPath,
        convertEllipseToCircle,
        moveElemsAttrsToGroup,
        moveGroupAttrsToElems,
        collapseGroups,
        convertPathData,
        convertTransform,
        removeEmptyAttrs,
        removeEmptyContainers,
        mergePaths,
        removeUnusedNS,
        sortDefsChildren,
        removeTitle,
        removeDesc
      ]
    });
    module.exports = presetDefault;
  }
});

// node_modules/svgo/plugins/addAttributesToSVGElement.js
var require_addAttributesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addAttributesToSVGElement.js"(exports) {
    "use strict";
    exports.name = "addAttributesToSVGElement";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "adds attributes to an outer <svg> element";
    var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;
    exports.fn = (root, params) => {
      if (!Array.isArray(params.attributes) && !params.attribute) {
        console.error(ENOCLS);
        return null;
      }
      const attributes = params.attributes || [params.attribute];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const attribute of attributes) {
                if (typeof attribute === "string") {
                  if (node.attributes[attribute] == null) {
                    node.attributes[attribute] = void 0;
                  }
                }
                if (typeof attribute === "object") {
                  for (const key of Object.keys(attribute)) {
                    if (node.attributes[key] == null) {
                      node.attributes[key] = attribute[key];
                    }
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/addClassesToSVGElement.js
var require_addClassesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addClassesToSVGElement.js"(exports) {
    "use strict";
    exports.name = "addClassesToSVGElement";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "adds classnames to an outer <svg> element";
    var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;
    exports.fn = (root, params) => {
      if (!(Array.isArray(params.classNames) && params.classNames.some(String)) && !params.className) {
        console.error(ENOCLS);
        return null;
      }
      const classNames = params.classNames || [params.className];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              const classList = new Set(
                node.attributes.class == null ? null : node.attributes.class.split(" ")
              );
              for (const className of classNames) {
                if (className != null) {
                  classList.add(className);
                }
              }
              node.attributes.class = Array.from(classList).join(" ");
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupListOfValues.js
var require_cleanupListOfValues = __commonJS({
  "node_modules/svgo/plugins/cleanupListOfValues.js"(exports) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports.name = "cleanupListOfValues";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "rounds list of values to the fixed precision";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var regSeparator = /\s+,?\s*|,\s*/;
    var absoluteLengths = {
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      const roundValues = (lists) => {
        const roundedList = [];
        for (const elem of lists.split(regSeparator)) {
          const match = elem.match(regNumericValues);
          const matchNew = elem.match(/new/);
          if (match) {
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            let matchedUnit = match[3] || "";
            let units = matchedUnit;
            if (convertToPx && units && units in absoluteLengths) {
              const pxNum = Number(
                (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision)
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units = "px";
              }
            }
            let str;
            if (leadingZero) {
              str = removeLeadingZero(num);
            } else {
              str = num.toString();
            }
            if (defaultPx && units === "px") {
              units = "";
            }
            roundedList.push(str + units);
          } else if (matchNew) {
            roundedList.push("new");
          } else if (elem) {
            roundedList.push(elem);
          }
        }
        return roundedList.join(" ");
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.points != null) {
              node.attributes.points = roundValues(node.attributes.points);
            }
            if (node.attributes["enable-background"] != null) {
              node.attributes["enable-background"] = roundValues(
                node.attributes["enable-background"]
              );
            }
            if (node.attributes.viewBox != null) {
              node.attributes.viewBox = roundValues(node.attributes.viewBox);
            }
            if (node.attributes["stroke-dasharray"] != null) {
              node.attributes["stroke-dasharray"] = roundValues(
                node.attributes["stroke-dasharray"]
              );
            }
            if (node.attributes.dx != null) {
              node.attributes.dx = roundValues(node.attributes.dx);
            }
            if (node.attributes.dy != null) {
              node.attributes.dy = roundValues(node.attributes.dy);
            }
            if (node.attributes.x != null) {
              node.attributes.x = roundValues(node.attributes.x);
            }
            if (node.attributes.y != null) {
              node.attributes.y = roundValues(node.attributes.y);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertStyleToAttrs.js
var require_convertStyleToAttrs = __commonJS({
  "node_modules/svgo/plugins/convertStyleToAttrs.js"(exports) {
    "use strict";
    exports.name = "convertStyleToAttrs";
    exports.type = "perItem";
    exports.active = false;
    exports.description = "converts style to attributes";
    exports.params = {
      keepImportant: false
    };
    var stylingProps = require_collections().attrsGroups.presentation;
    var rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
    var rAttr = "\\s*(" + g2("[^:;\\\\]", rEscape) + "*?)\\s*";
    var rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
    var rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
    var rQuotedString = new RegExp("^" + g2(rSingleQuotes, rQuotes) + "$");
    var rParenthesis = "\\(" + g2(`[^'"()\\\\]+`, rEscape, rSingleQuotes, rQuotes) + "*?\\)";
    var rValue = "\\s*(" + g2(
      `[^!'"();\\\\]+?`,
      rEscape,
      rSingleQuotes,
      rQuotes,
      rParenthesis,
      "[^;]*?"
    ) + "*?)";
    var rDeclEnd = "\\s*(?:;\\s*|$)";
    var rImportant = "(\\s*!important(?![-(\\w]))?";
    var regDeclarationBlock = new RegExp(
      rAttr + ":" + rValue + rImportant + rDeclEnd,
      "ig"
    );
    var regStripComments = new RegExp(
      g2(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
      "ig"
    );
    exports.fn = function(item, params) {
      if (item.type === "element" && item.attributes.style != null) {
        let styles = [];
        const newAttributes = {};
        const styleValue = item.attributes.style.replace(
          regStripComments,
          (match) => {
            return match[0] == "/" ? "" : match[0] == "\\" && /[-g-z]/i.test(match[1]) ? match[1] : match;
          }
        );
        regDeclarationBlock.lastIndex = 0;
        for (var rule; rule = regDeclarationBlock.exec(styleValue); ) {
          if (!params.keepImportant || !rule[3]) {
            styles.push([rule[1], rule[2]]);
          }
        }
        if (styles.length) {
          styles = styles.filter(function(style) {
            if (style[0]) {
              var prop = style[0].toLowerCase(), val = style[1];
              if (rQuotedString.test(val)) {
                val = val.slice(1, -1);
              }
              if (stylingProps.includes(prop)) {
                newAttributes[prop] = val;
                return false;
              }
            }
            return true;
          });
          Object.assign(item.attributes, newAttributes);
          if (styles.length) {
            item.attributes.style = styles.map((declaration) => declaration.join(":")).join(";");
          } else {
            delete item.attributes.style;
          }
        }
      }
    };
    function g2() {
      return "(?:" + Array.prototype.join.call(arguments, "|") + ")";
    }
  }
});

// node_modules/svgo/plugins/prefixIds.js
var require_prefixIds = __commonJS({
  "node_modules/svgo/plugins/prefixIds.js"(exports) {
    "use strict";
    var csstree = require_lib9();
    var { referencesProps } = require_collections();
    exports.type = "visitor";
    exports.name = "prefixIds";
    exports.active = false;
    exports.description = "prefix IDs";
    var getBasename = (path) => {
      const matched = path.match(/[/\\]?([^/\\]+)$/);
      if (matched) {
        return matched[1];
      }
      return "";
    };
    var escapeIdentifierName = (str) => {
      return str.replace(/[. ]/g, "_");
    };
    var unquote = (string2) => {
      if (string2.startsWith('"') && string2.endsWith('"') || string2.startsWith("'") && string2.endsWith("'")) {
        return string2.slice(1, -1);
      }
      return string2;
    };
    var prefixId = (prefix, value) => {
      if (value.startsWith(prefix)) {
        return value;
      }
      return prefix + value;
    };
    var prefixReference = (prefix, value) => {
      if (value.startsWith("#")) {
        return "#" + prefixId(prefix, value.slice(1));
      }
      return null;
    };
    exports.fn = (_root, params, info) => {
      const { delim = "__", prefixIds = true, prefixClassNames = true } = params;
      return {
        element: {
          enter: (node) => {
            let prefix = "prefix" + delim;
            if (typeof params.prefix === "function") {
              prefix = params.prefix(node, info) + delim;
            } else if (typeof params.prefix === "string") {
              prefix = params.prefix + delim;
            } else if (params.prefix === false) {
              prefix = "";
            } else if (info.path != null && info.path.length > 0) {
              prefix = escapeIdentifierName(getBasename(info.path)) + delim;
            }
            if (node.name === "style") {
              if (node.children.length === 0) {
                return;
              }
              let cssText = "";
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                cssText = node.children[0].value;
              }
              let cssAst = null;
              try {
                cssAst = csstree.parse(cssText, {
                  parseValue: true,
                  parseCustomProperty: false
                });
              } catch {
                return;
              }
              csstree.walk(cssAst, (node2) => {
                if (prefixIds && node2.type === "IdSelector" || prefixClassNames && node2.type === "ClassSelector") {
                  node2.name = prefixId(prefix, node2.name);
                  return;
                }
                if (node2.type === "Url" && node2.value.value && node2.value.value.length > 0) {
                  const prefixed = prefixReference(
                    prefix,
                    unquote(node2.value.value)
                  );
                  if (prefixed != null) {
                    node2.value.value = prefixed;
                  }
                }
              });
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                node.children[0].value = csstree.generate(cssAst);
              }
              return;
            }
            if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {
              node.attributes.id = prefixId(prefix, node.attributes.id);
            }
            if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {
              node.attributes.class = node.attributes.class.split(/\s+/).map((name) => prefixId(prefix, name)).join(" ");
            }
            for (const name of ["href", "xlink:href"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const prefixed = prefixReference(prefix, node.attributes[name]);
                if (prefixed != null) {
                  node.attributes[name] = prefixed;
                }
              }
            }
            for (const name of referencesProps) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                node.attributes[name] = node.attributes[name].replace(
                  /url\((.*?)\)/gi,
                  (match, url) => {
                    const prefixed = prefixReference(prefix, url);
                    if (prefixed == null) {
                      return match;
                    }
                    return `url(${prefixed})`;
                  }
                );
              }
            }
            for (const name of ["begin", "end"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
                  if (val.endsWith(".end") || val.endsWith(".start")) {
                    const [id, postfix] = val.split(".");
                    return `${prefixId(prefix, id)}.${postfix}`;
                  }
                  return val;
                });
                node.attributes[name] = parts.join("; ");
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeAttributesBySelector.js
var require_removeAttributesBySelector = __commonJS({
  "node_modules/svgo/plugins/removeAttributesBySelector.js"(exports) {
    "use strict";
    var { querySelectorAll } = require_xast();
    exports.name = "removeAttributesBySelector";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes attributes of elements that match a css selector";
    exports.fn = (root, params) => {
      const selectors = Array.isArray(params.selectors) ? params.selectors : [params];
      for (const { selector, attributes } of selectors) {
        const nodes = querySelectorAll(root, selector);
        for (const node of nodes) {
          if (node.type === "element") {
            if (Array.isArray(attributes)) {
              for (const name of attributes) {
                delete node.attributes[name];
              }
            } else {
              delete node.attributes[attributes];
            }
          }
        }
      }
      return {};
    };
  }
});

// node_modules/svgo/plugins/removeAttrs.js
var require_removeAttrs = __commonJS({
  "node_modules/svgo/plugins/removeAttrs.js"(exports) {
    "use strict";
    exports.name = "removeAttrs";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes specified attributes";
    var DEFAULT_SEPARATOR = ":";
    var ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;
    exports.fn = (root, params) => {
      if (typeof params.attrs == "undefined") {
        console.warn(ENOATTRS);
        return null;
      }
      const elemSeparator = typeof params.elemSeparator == "string" ? params.elemSeparator : DEFAULT_SEPARATOR;
      const preserveCurrentColor = typeof params.preserveCurrentColor == "boolean" ? params.preserveCurrentColor : false;
      const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];
      return {
        element: {
          enter: (node) => {
            for (let pattern of attrs) {
              if (pattern.includes(elemSeparator) === false) {
                pattern = [".*", elemSeparator, pattern, elemSeparator, ".*"].join(
                  ""
                );
              } else if (pattern.split(elemSeparator).length < 3) {
                pattern = [pattern, elemSeparator, ".*"].join("");
              }
              const list = pattern.split(elemSeparator).map((value) => {
                if (value === "*") {
                  value = ".*";
                }
                return new RegExp(["^", value, "$"].join(""), "i");
              });
              if (list[0].test(node.name)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  const isFillCurrentColor = preserveCurrentColor && name == "fill" && value == "currentColor";
                  const isStrokeCurrentColor = preserveCurrentColor && name == "stroke" && value == "currentColor";
                  if (!isFillCurrentColor && !isStrokeCurrentColor && list[1].test(name) && list[2].test(value)) {
                    delete node.attributes[name];
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDimensions.js
var require_removeDimensions = __commonJS({
  "node_modules/svgo/plugins/removeDimensions.js"(exports) {
    "use strict";
    exports.name = "removeDimensions";
    exports.type = "perItem";
    exports.active = false;
    exports.description = "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
    exports.fn = function(item) {
      if (item.type === "element" && item.name === "svg") {
        if (item.attributes.viewBox != null) {
          delete item.attributes.width;
          delete item.attributes.height;
        } else if (item.attributes.width != null && item.attributes.height != null && Number.isNaN(Number(item.attributes.width)) === false && Number.isNaN(Number(item.attributes.height)) === false) {
          const width = Number(item.attributes.width);
          const height = Number(item.attributes.height);
          item.attributes.viewBox = `0 0 ${width} ${height}`;
          delete item.attributes.width;
          delete item.attributes.height;
        }
      }
    };
  }
});

// node_modules/svgo/plugins/removeElementsByAttr.js
var require_removeElementsByAttr = __commonJS({
  "node_modules/svgo/plugins/removeElementsByAttr.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeElementsByAttr";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes arbitrary elements by ID or className (disabled by default)";
    exports.fn = (root, params) => {
      const ids = params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
      const classes = params.class == null ? [] : Array.isArray(params.class) ? params.class : [params.class];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null && ids.length !== 0) {
              if (ids.includes(node.attributes.id)) {
                detachNodeFromParent(node, parentNode);
              }
            }
            if (node.attributes.class && classes.length !== 0) {
              const classList = node.attributes.class.split(" ");
              for (const item of classes) {
                if (classList.includes(item)) {
                  detachNodeFromParent(node, parentNode);
                  break;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeOffCanvasPaths.js
var require_removeOffCanvasPaths = __commonJS({
  "node_modules/svgo/plugins/removeOffCanvasPaths.js"(exports) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { parsePathData } = require_path2();
    var { intersects } = require_path3();
    exports.type = "visitor";
    exports.name = "removeOffCanvasPaths";
    exports.active = false;
    exports.description = "removes elements that are drawn outside of the viewbox (disabled by default)";
    exports.fn = () => {
      let viewBoxData = null;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              let viewBox = "";
              if (node.attributes.viewBox != null) {
                viewBox = node.attributes.viewBox;
              } else if (node.attributes.height != null && node.attributes.width != null) {
                viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
              }
              viewBox = viewBox.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
              const m2 = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
                viewBox
              );
              if (m2 == null) {
                return;
              }
              const left = Number.parseFloat(m2[1]);
              const top = Number.parseFloat(m2[2]);
              const width = Number.parseFloat(m2[3]);
              const height = Number.parseFloat(m2[4]);
              viewBoxData = {
                left,
                top,
                right: left + width,
                bottom: top + height,
                width,
                height
              };
            }
            if (node.attributes.transform != null) {
              return visitSkip;
            }
            if (node.name === "path" && node.attributes.d != null && viewBoxData != null) {
              const pathData = parsePathData(node.attributes.d);
              let visible = false;
              for (const pathDataItem of pathData) {
                if (pathDataItem.command === "M") {
                  const [x2, y2] = pathDataItem.args;
                  if (x2 >= viewBoxData.left && x2 <= viewBoxData.right && y2 >= viewBoxData.top && y2 <= viewBoxData.bottom) {
                    visible = true;
                  }
                }
              }
              if (visible) {
                return;
              }
              if (pathData.length === 2) {
                pathData.push({ command: "z", args: [] });
              }
              const { left, top, width, height } = viewBoxData;
              const viewBoxPathData = [
                { command: "M", args: [left, top] },
                { command: "h", args: [width] },
                { command: "v", args: [height] },
                { command: "H", args: [left] },
                { command: "z", args: [] }
              ];
              if (intersects(viewBoxPathData, pathData) === false) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeRasterImages.js
var require_removeRasterImages = __commonJS({
  "node_modules/svgo/plugins/removeRasterImages.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeRasterImages";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes raster images (disabled by default)";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "image" && node.attributes["xlink:href"] != null && /(\.|image\/)(jpg|png|gif)/.test(node.attributes["xlink:href"])) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeScriptElement.js
var require_removeScriptElement = __commonJS({
  "node_modules/svgo/plugins/removeScriptElement.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeScriptElement";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes <script> elements (disabled by default)";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "script") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeStyleElement.js
var require_removeStyleElement = __commonJS({
  "node_modules/svgo/plugins/removeStyleElement.js"(exports) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports.name = "removeStyleElement";
    exports.type = "visitor";
    exports.active = false;
    exports.description = "removes <style> element (disabled by default)";
    exports.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLNS.js
var require_removeXMLNS = __commonJS({
  "node_modules/svgo/plugins/removeXMLNS.js"(exports) {
    "use strict";
    exports.name = "removeXMLNS";
    exports.type = "perItem";
    exports.active = false;
    exports.description = "removes xmlns attribute (for inline svg, disabled by default)";
    exports.fn = function(item) {
      if (item.type === "element" && item.name === "svg") {
        delete item.attributes.xmlns;
        delete item.attributes["xmlns:xlink"];
      }
    };
  }
});

// node_modules/svgo/plugins/reusePaths.js
var require_reusePaths = __commonJS({
  "node_modules/svgo/plugins/reusePaths.js"(exports) {
    "use strict";
    var JSAPI = require_jsAPI();
    exports.type = "visitor";
    exports.name = "reusePaths";
    exports.active = false;
    exports.description = "Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.";
    exports.fn = () => {
      const paths = /* @__PURE__ */ new Map();
      return {
        element: {
          enter: (node) => {
            if (node.name === "path" && node.attributes.d != null) {
              const d2 = node.attributes.d;
              const fill = node.attributes.fill || "";
              const stroke = node.attributes.stroke || "";
              const key = d2 + ";s:" + stroke + ";f:" + fill;
              let list = paths.get(key);
              if (list == null) {
                list = [];
                paths.set(key, list);
              }
              list.push(node);
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              const rawDefs = {
                type: "element",
                name: "defs",
                attributes: {},
                children: []
              };
              const defsTag = new JSAPI(rawDefs, node);
              let index = 0;
              for (const list of paths.values()) {
                if (list.length > 1) {
                  const rawPath = {
                    type: "element",
                    name: "path",
                    attributes: { ...list[0].attributes },
                    children: []
                  };
                  delete rawPath.attributes.transform;
                  let id;
                  if (rawPath.attributes.id == null) {
                    id = "reuse-" + index;
                    index += 1;
                    rawPath.attributes.id = id;
                  } else {
                    id = rawPath.attributes.id;
                    delete list[0].attributes.id;
                  }
                  const reusablePath = new JSAPI(rawPath, defsTag);
                  defsTag.children.push(reusablePath);
                  for (const pathNode of list) {
                    pathNode.name = "use";
                    pathNode.attributes["xlink:href"] = "#" + id;
                    delete pathNode.attributes.d;
                    delete pathNode.attributes.stroke;
                    delete pathNode.attributes.fill;
                  }
                }
              }
              if (defsTag.children.length !== 0) {
                if (node.attributes["xmlns:xlink"] == null) {
                  node.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
                }
                node.children.unshift(defsTag);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortAttrs.js
var require_sortAttrs = __commonJS({
  "node_modules/svgo/plugins/sortAttrs.js"(exports) {
    "use strict";
    exports.type = "visitor";
    exports.name = "sortAttrs";
    exports.active = false;
    exports.description = "Sort element attributes for better compression";
    exports.fn = (_root, params) => {
      const {
        order = [
          "id",
          "width",
          "height",
          "x",
          "x1",
          "x2",
          "y",
          "y1",
          "y2",
          "cx",
          "cy",
          "r",
          "fill",
          "stroke",
          "marker",
          "d",
          "points"
        ],
        xmlnsOrder = "front"
      } = params;
      const getNsPriority = (name) => {
        if (xmlnsOrder === "front") {
          if (name === "xmlns") {
            return 3;
          }
          if (name.startsWith("xmlns:")) {
            return 2;
          }
        }
        if (name.includes(":")) {
          return 1;
        }
        return 0;
      };
      const compareAttrs = ([aName], [bName]) => {
        const aPriority = getNsPriority(aName);
        const bPriority = getNsPriority(bName);
        const priorityNs = bPriority - aPriority;
        if (priorityNs !== 0) {
          return priorityNs;
        }
        const [aPart] = aName.split("-");
        const [bPart] = bName.split("-");
        if (aPart !== bPart) {
          const aInOrderFlag = order.includes(aPart) ? 1 : 0;
          const bInOrderFlag = order.includes(bPart) ? 1 : 0;
          if (aInOrderFlag === 1 && bInOrderFlag === 1) {
            return order.indexOf(aPart) - order.indexOf(bPart);
          }
          const priorityOrder = bInOrderFlag - aInOrderFlag;
          if (priorityOrder !== 0) {
            return priorityOrder;
          }
        }
        return aName < bName ? -1 : 1;
      };
      return {
        element: {
          enter: (node) => {
            const attrs = Object.entries(node.attributes);
            attrs.sort(compareAttrs);
            const sortedAttributes = {};
            for (const [name, value] of attrs) {
              sortedAttributes[name] = value;
            }
            node.attributes = sortedAttributes;
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/plugins.js
var require_plugins2 = __commonJS({
  "node_modules/svgo/plugins/plugins.js"(exports) {
    "use strict";
    exports["preset-default"] = require_preset_default();
    exports.addAttributesToSVGElement = require_addAttributesToSVGElement();
    exports.addClassesToSVGElement = require_addClassesToSVGElement();
    exports.cleanupAttrs = require_cleanupAttrs();
    exports.cleanupEnableBackground = require_cleanupEnableBackground();
    exports.cleanupIDs = require_cleanupIDs();
    exports.cleanupListOfValues = require_cleanupListOfValues();
    exports.cleanupNumericValues = require_cleanupNumericValues();
    exports.collapseGroups = require_collapseGroups();
    exports.convertColors = require_convertColors();
    exports.convertEllipseToCircle = require_convertEllipseToCircle();
    exports.convertPathData = require_convertPathData();
    exports.convertShapeToPath = require_convertShapeToPath();
    exports.convertStyleToAttrs = require_convertStyleToAttrs();
    exports.convertTransform = require_convertTransform();
    exports.mergeStyles = require_mergeStyles();
    exports.inlineStyles = require_inlineStyles();
    exports.mergePaths = require_mergePaths();
    exports.minifyStyles = require_minifyStyles();
    exports.moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
    exports.moveGroupAttrsToElems = require_moveGroupAttrsToElems();
    exports.prefixIds = require_prefixIds();
    exports.removeAttributesBySelector = require_removeAttributesBySelector();
    exports.removeAttrs = require_removeAttrs();
    exports.removeComments = require_removeComments();
    exports.removeDesc = require_removeDesc();
    exports.removeDimensions = require_removeDimensions();
    exports.removeDoctype = require_removeDoctype();
    exports.removeEditorsNSData = require_removeEditorsNSData();
    exports.removeElementsByAttr = require_removeElementsByAttr();
    exports.removeEmptyAttrs = require_removeEmptyAttrs();
    exports.removeEmptyContainers = require_removeEmptyContainers();
    exports.removeEmptyText = require_removeEmptyText();
    exports.removeHiddenElems = require_removeHiddenElems();
    exports.removeMetadata = require_removeMetadata();
    exports.removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
    exports.removeOffCanvasPaths = require_removeOffCanvasPaths();
    exports.removeRasterImages = require_removeRasterImages();
    exports.removeScriptElement = require_removeScriptElement();
    exports.removeStyleElement = require_removeStyleElement();
    exports.removeTitle = require_removeTitle();
    exports.removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
    exports.removeUnusedNS = require_removeUnusedNS();
    exports.removeUselessDefs = require_removeUselessDefs();
    exports.removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
    exports.removeViewBox = require_removeViewBox();
    exports.removeXMLNS = require_removeXMLNS();
    exports.removeXMLProcInst = require_removeXMLProcInst();
    exports.reusePaths = require_reusePaths();
    exports.sortAttrs = require_sortAttrs();
    exports.sortDefsChildren = require_sortDefsChildren();
  }
});

// node_modules/svgo/lib/svgo/config.js
var require_config = __commonJS({
  "node_modules/svgo/lib/svgo/config.js"(exports) {
    "use strict";
    var pluginsMap = require_plugins2();
    var pluginsOrder = [
      "removeDoctype",
      "removeXMLProcInst",
      "removeComments",
      "removeMetadata",
      "removeXMLNS",
      "removeEditorsNSData",
      "cleanupAttrs",
      "mergeStyles",
      "inlineStyles",
      "minifyStyles",
      "convertStyleToAttrs",
      "cleanupIDs",
      "prefixIds",
      "removeRasterImages",
      "removeUselessDefs",
      "cleanupNumericValues",
      "cleanupListOfValues",
      "convertColors",
      "removeUnknownsAndDefaults",
      "removeNonInheritableGroupAttrs",
      "removeUselessStrokeAndFill",
      "removeViewBox",
      "cleanupEnableBackground",
      "removeHiddenElems",
      "removeEmptyText",
      "convertShapeToPath",
      "convertEllipseToCircle",
      "moveElemsAttrsToGroup",
      "moveGroupAttrsToElems",
      "collapseGroups",
      "convertPathData",
      "convertTransform",
      "removeEmptyAttrs",
      "removeEmptyContainers",
      "mergePaths",
      "removeUnusedNS",
      "sortAttrs",
      "sortDefsChildren",
      "removeTitle",
      "removeDesc",
      "removeDimensions",
      "removeAttrs",
      "removeAttributesBySelector",
      "removeElementsByAttr",
      "addClassesToSVGElement",
      "removeStyleElement",
      "removeScriptElement",
      "addAttributesToSVGElement",
      "removeOffCanvasPaths",
      "reusePaths"
    ];
    var defaultPlugins = pluginsOrder.filter((name) => pluginsMap[name].active);
    exports.defaultPlugins = defaultPlugins;
    var extendDefaultPlugins = (plugins) => {
      console.warn(
        `
"extendDefaultPlugins" utility is deprecated.
Use "preset-default" plugin with overrides instead.
For example:
{
  name: 'preset-default',
  params: {
    overrides: {
      // customize plugin options
      convertShapeToPath: {
        convertArcs: true
      },
      // disable plugins
      convertPathData: false
    }
  }
}
`
      );
      const extendedPlugins = pluginsOrder.map((name) => ({
        name,
        active: pluginsMap[name].active
      }));
      for (const plugin of plugins) {
        const resolvedPlugin = resolvePluginConfig(plugin);
        const index = pluginsOrder.indexOf(resolvedPlugin.name);
        if (index === -1) {
          extendedPlugins.push(plugin);
        } else {
          extendedPlugins[index] = plugin;
        }
      }
      return extendedPlugins;
    };
    exports.extendDefaultPlugins = extendDefaultPlugins;
    var resolvePluginConfig = (plugin) => {
      let configParams = {};
      if (typeof plugin === "string") {
        const pluginConfig = pluginsMap[plugin];
        if (pluginConfig == null) {
          throw Error(`Unknown builtin plugin "${plugin}" specified.`);
        }
        return {
          ...pluginConfig,
          name: plugin,
          active: true,
          params: { ...pluginConfig.params, ...configParams }
        };
      }
      if (typeof plugin === "object" && plugin != null) {
        if (plugin.name == null) {
          throw Error(`Plugin name should be specified`);
        }
        if (plugin.fn) {
          return {
            active: true,
            ...plugin,
            params: { ...configParams, ...plugin.params }
          };
        } else {
          const pluginConfig = pluginsMap[plugin.name];
          if (pluginConfig == null) {
            throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
          }
          return {
            ...pluginConfig,
            active: true,
            ...plugin,
            params: { ...pluginConfig.params, ...configParams, ...plugin.params }
          };
        }
      }
      return null;
    };
    exports.resolvePluginConfig = resolvePluginConfig;
  }
});

// node_modules/@trysound/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@trysound/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o2) {
          function F() {
          }
          F.prototype = o2;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o2) {
          var a2 = [];
          for (var i2 in o2)
            if (o2.hasOwnProperty(i2))
              a2.push(i2);
          return a2;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace2(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      function isQuote2(c2) {
        return c2 === '"' || c2 === "'";
      }
      function isAttribEnd(c2) {
        return c2 === ">" || isWhitespace2(c2);
      }
      function isMatch(regex, c2) {
        return regex.test(c2);
      }
      function notMatch(regex, c2) {
        return !isMatch(regex, c2);
      }
      var S2 = 0;
      sax.STATE = {
        BEGIN: S2++,
        BEGIN_WHITESPACE: S2++,
        TEXT: S2++,
        TEXT_ENTITY: S2++,
        OPEN_WAKA: S2++,
        SGML_DECL: S2++,
        SGML_DECL_QUOTED: S2++,
        DOCTYPE: S2++,
        DOCTYPE_QUOTED: S2++,
        DOCTYPE_DTD: S2++,
        DOCTYPE_DTD_QUOTED: S2++,
        COMMENT_STARTING: S2++,
        COMMENT: S2++,
        COMMENT_ENDING: S2++,
        COMMENT_ENDED: S2++,
        CDATA: S2++,
        CDATA_ENDING: S2++,
        CDATA_ENDING_2: S2++,
        PROC_INST: S2++,
        PROC_INST_BODY: S2++,
        PROC_INST_ENDING: S2++,
        OPEN_TAG: S2++,
        OPEN_TAG_SLASH: S2++,
        ATTRIB: S2++,
        ATTRIB_NAME: S2++,
        ATTRIB_NAME_SAW_WHITE: S2++,
        ATTRIB_VALUE: S2++,
        ATTRIB_VALUE_QUOTED: S2++,
        ATTRIB_VALUE_CLOSED: S2++,
        ATTRIB_VALUE_UNQUOTED: S2++,
        ATTRIB_VALUE_ENTITY_Q: S2++,
        ATTRIB_VALUE_ENTITY_U: S2++,
        CLOSE_TAG: S2++,
        CLOSE_TAG_SAW_WHITE: S2++,
        SCRIPT: S2++,
        SCRIPT_ENDING: S2++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e2 = sax.ENTITIES[key];
        var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax.ENTITIES[key] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S2 = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, reason) {
        closeText(parser);
        const message = reason + "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        const error2 = new Error(message);
        error2.reason = reason;
        error2.line = parser.line;
        error2.column = parser.column;
        parser.error = error2;
        emit(parser, "onerror", error2);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              emitNode(parser, "onopennamespace", {
                prefix: p2,
                uri: tag.ns[p2]
              });
            });
          }
          for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a2 = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a2.uri = prefix;
            }
            parser.tag.attributes[name] = a2;
            emitNode(parser, "onattribute", a2);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t2 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close = parser.tags[t2];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s3 = parser.tags.length;
        while (s3-- > t2) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag.ns) {
            x2[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              var n2 = tag.ns[p2];
              emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
            });
          }
        }
        if (t2 === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c2) {
        if (c2 === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace2(c2)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c2;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c2 = "";
        while (true) {
          c2 = charAt(chunk, i2++);
          parser.c = c2;
          if (!c2) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c2 === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c2);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c2);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = charAt(chunk, i2++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace2(c2) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c2 === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c2;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c2 === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c2;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c2;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c2 === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace2(c2)) {
              } else if (isMatch(nameStart, c2)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c2;
              } else if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                parser.textNode += "<" + c2;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c2 === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c2 === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote2(c2)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c2;
              } else {
                parser.sgmlDecl += c2;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c2 === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c2;
              continue;
            case S2.DOCTYPE:
              if (c2 === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c2;
                if (c2 === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote2(c2)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c2;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              parser.doctype += c2;
              if (c2 === "]") {
                parser.state = S2.DOCTYPE;
              } else if (isQuote2(c2)) {
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c2;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c2;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c2;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c2 !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c2;
                parser.state = S2.COMMENT;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c2;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c2 === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c2 === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace2(c2)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c2;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace2(c2)) {
                continue;
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c2;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c2 === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c2;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else {
                newTag(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace2(c2)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c2 === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace2(c2)) {
                continue;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c2 === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace2(c2)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c2)) {
                parser.attribName += c2;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace2(c2)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c2 === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace2(c2)) {
                continue;
              } else if (isQuote2(c2)) {
                parser.q = c2;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c2;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c2 !== parser.q) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace2(c2)) {
                parser.state = S2.ATTRIB;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c2)) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              if (c2 === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace2(c2)) {
                  continue;
                } else if (notMatch(nameStart, c2)) {
                  if (parser.script) {
                    parser.script += "</" + c2;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c2;
                }
              } else if (c2 === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace2(c2)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace2(c2)) {
                continue;
              }
              if (c2 === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c2 === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.state === S2.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== "&" + parser.entity + ";") {
                  chunk = chunk.slice(0, i2) + parsedEntity + chunk.slice(i2);
                } else {
                  parser[buffer] += parsedEntity;
                }
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                parser.entity += c2;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c2;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/svgo/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/svgo/lib/parser.js"(exports) {
    "use strict";
    var SAX = require_sax();
    var JSAPI = require_jsAPI();
    var { textElems } = require_collections();
    var SvgoParserError = class extends Error {
      constructor(message, line, column, source, file) {
        super(message);
        this.name = "SvgoParserError";
        this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
        this.reason = message;
        this.line = line;
        this.column = column;
        this.source = source;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, SvgoParserError);
        }
      }
      toString() {
        const lines = this.source.split(/\r?\n/);
        const startLine = Math.max(this.line - 3, 0);
        const endLine = Math.min(this.line + 2, lines.length);
        const lineNumberWidth = String(endLine).length;
        const startColumn = Math.max(this.column - 54, 0);
        const endColumn = Math.max(this.column + 20, 80);
        const code = lines.slice(startLine, endLine).map((line, index) => {
          const lineSlice = line.slice(startColumn, endColumn);
          let ellipsisPrefix = "";
          let ellipsisSuffix = "";
          if (startColumn !== 0) {
            ellipsisPrefix = startColumn > line.length - 1 ? " " : "\u2026";
          }
          if (endColumn < line.length - 1) {
            ellipsisSuffix = "\u2026";
          }
          const number = startLine + 1 + index;
          const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
          if (number === this.line) {
            const gutterSpacing = gutter.replace(/[^|]/g, " ");
            const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\t]/g, " ");
            const spacing = gutterSpacing + lineSpacing;
            return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}
 ${spacing}^`;
          }
          return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
        }).join("\n");
        return `${this.name}: ${this.message}

${code}
`;
      }
    };
    var entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
    var config = {
      strict: true,
      trim: false,
      normalize: false,
      lowercase: true,
      xmlns: true,
      position: true
    };
    var parseSvg = (data, from) => {
      const sax = SAX.parser(config.strict, config);
      const root = new JSAPI({ type: "root", children: [] });
      let current = root;
      const stack = [root];
      const pushToContent = (node) => {
        const wrapped = new JSAPI(node, current);
        current.children.push(wrapped);
        return wrapped;
      };
      sax.ondoctype = (doctype) => {
        const node = {
          type: "doctype",
          name: "svg",
          data: {
            doctype
          }
        };
        pushToContent(node);
        const subsetStart = doctype.indexOf("[");
        if (subsetStart >= 0) {
          entityDeclaration.lastIndex = subsetStart;
          let entityMatch = entityDeclaration.exec(data);
          while (entityMatch != null) {
            sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
            entityMatch = entityDeclaration.exec(data);
          }
        }
      };
      sax.onprocessinginstruction = (data2) => {
        const node = {
          type: "instruction",
          name: data2.name,
          value: data2.body
        };
        pushToContent(node);
      };
      sax.oncomment = (comment) => {
        const node = {
          type: "comment",
          value: comment.trim()
        };
        pushToContent(node);
      };
      sax.oncdata = (cdata) => {
        const node = {
          type: "cdata",
          value: cdata
        };
        pushToContent(node);
      };
      sax.onopentag = (data2) => {
        let element = {
          type: "element",
          name: data2.name,
          attributes: {},
          children: []
        };
        for (const [name, attr] of Object.entries(data2.attributes)) {
          element.attributes[name] = attr.value;
        }
        element = pushToContent(element);
        current = element;
        stack.push(element);
      };
      sax.ontext = (text) => {
        if (current.type === "element") {
          if (textElems.includes(current.name)) {
            const node = {
              type: "text",
              value: text
            };
            pushToContent(node);
          } else if (/\S/.test(text)) {
            const node = {
              type: "text",
              value: text.trim()
            };
            pushToContent(node);
          }
        }
      };
      sax.onclosetag = () => {
        stack.pop();
        current = stack[stack.length - 1];
      };
      sax.onerror = (e2) => {
        const error = new SvgoParserError(
          e2.reason,
          e2.line + 1,
          e2.column,
          data,
          from
        );
        if (e2.message.indexOf("Unexpected end") === -1) {
          throw error;
        }
      };
      sax.write(data).close();
      return root;
    };
    exports.parseSvg = parseSvg;
  }
});

// node_modules/svgo/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/svgo/lib/stringifier.js"(exports) {
    "use strict";
    var { textElems } = require_collections();
    var encodeEntity = (char) => {
      return entities[char];
    };
    var defaults = {
      doctypeStart: "<!DOCTYPE",
      doctypeEnd: ">",
      procInstStart: "<?",
      procInstEnd: "?>",
      tagOpenStart: "<",
      tagOpenEnd: ">",
      tagCloseStart: "</",
      tagCloseEnd: ">",
      tagShortStart: "<",
      tagShortEnd: "/>",
      attrStart: '="',
      attrEnd: '"',
      commentStart: "<!--",
      commentEnd: "-->",
      cdataStart: "<![CDATA[",
      cdataEnd: "]]>",
      textStart: "",
      textEnd: "",
      indent: 4,
      regEntities: /[&'"<>]/g,
      regValEntities: /[&"<>]/g,
      encodeEntity,
      pretty: false,
      useShortTags: true,
      eol: "lf",
      finalNewline: false
    };
    var entities = {
      "&": "&amp;",
      "'": "&apos;",
      '"': "&quot;",
      ">": "&gt;",
      "<": "&lt;"
    };
    var stringifySvg = (data, userOptions = {}) => {
      const config = { ...defaults, ...userOptions };
      const indent = config.indent;
      let newIndent = "    ";
      if (typeof indent === "number" && Number.isNaN(indent) === false) {
        newIndent = indent < 0 ? "	" : " ".repeat(indent);
      } else if (typeof indent === "string") {
        newIndent = indent;
      }
      const state = {
        width: void 0,
        height: void 0,
        indent: newIndent,
        textContext: null,
        indentLevel: 0
      };
      const eol = config.eol === "crlf" ? "\r\n" : "\n";
      if (config.pretty) {
        config.doctypeEnd += eol;
        config.procInstEnd += eol;
        config.commentEnd += eol;
        config.cdataEnd += eol;
        config.tagShortEnd += eol;
        config.tagOpenEnd += eol;
        config.tagCloseEnd += eol;
        config.textEnd += eol;
      }
      let svg = stringifyNode(data, config, state);
      if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== "\n") {
        svg += eol;
      }
      return {
        data: svg,
        info: {
          width: state.width,
          height: state.height
        }
      };
    };
    exports.stringifySvg = stringifySvg;
    var stringifyNode = (data, config, state) => {
      let svg = "";
      state.indentLevel += 1;
      for (const item of data.children) {
        if (item.type === "element") {
          svg += stringifyElement(item, config, state);
        }
        if (item.type === "text") {
          svg += stringifyText(item, config, state);
        }
        if (item.type === "doctype") {
          svg += stringifyDoctype(item, config);
        }
        if (item.type === "instruction") {
          svg += stringifyInstruction(item, config);
        }
        if (item.type === "comment") {
          svg += stringifyComment(item, config);
        }
        if (item.type === "cdata") {
          svg += stringifyCdata(item, config, state);
        }
      }
      state.indentLevel -= 1;
      return svg;
    };
    var createIndent = (config, state) => {
      let indent = "";
      if (config.pretty && state.textContext == null) {
        indent = state.indent.repeat(state.indentLevel - 1);
      }
      return indent;
    };
    var stringifyDoctype = (node, config) => {
      return config.doctypeStart + node.data.doctype + config.doctypeEnd;
    };
    var stringifyInstruction = (node, config) => {
      return config.procInstStart + node.name + " " + node.value + config.procInstEnd;
    };
    var stringifyComment = (node, config) => {
      return config.commentStart + node.value + config.commentEnd;
    };
    var stringifyCdata = (node, config, state) => {
      return createIndent(config, state) + config.cdataStart + node.value + config.cdataEnd;
    };
    var stringifyElement = (node, config, state) => {
      if (node.name === "svg" && node.attributes.width != null && node.attributes.height != null) {
        state.width = node.attributes.width;
        state.height = node.attributes.height;
      }
      if (node.children.length === 0) {
        if (config.useShortTags) {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagShortEnd;
        } else {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagOpenEnd + config.tagCloseStart + node.name + config.tagCloseEnd;
        }
      } else {
        let tagOpenStart = config.tagOpenStart;
        let tagOpenEnd = config.tagOpenEnd;
        let tagCloseStart = config.tagCloseStart;
        let tagCloseEnd = config.tagCloseEnd;
        let openIndent = createIndent(config, state);
        let closeIndent = createIndent(config, state);
        if (state.textContext) {
          tagOpenStart = defaults.tagOpenStart;
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          tagCloseEnd = defaults.tagCloseEnd;
          openIndent = "";
        } else if (textElems.includes(node.name)) {
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          closeIndent = "";
          state.textContext = node;
        }
        const children = stringifyNode(node, config, state);
        if (state.textContext === node) {
          state.textContext = null;
        }
        return openIndent + tagOpenStart + node.name + stringifyAttributes(node, config) + tagOpenEnd + children + closeIndent + tagCloseStart + node.name + tagCloseEnd;
      }
    };
    var stringifyAttributes = (node, config) => {
      let attrs = "";
      for (const [name, value] of Object.entries(node.attributes)) {
        if (value !== void 0) {
          const encodedValue = value.toString().replace(config.regValEntities, config.encodeEntity);
          attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
        } else {
          attrs += " " + name;
        }
      }
      return attrs;
    };
    var stringifyText = (node, config, state) => {
      return createIndent(config, state) + config.textStart + node.value.replace(config.regEntities, config.encodeEntity) + (state.textContext ? "" : config.textEnd);
    };
  }
});

// node_modules/svgo/lib/svgo.js
var require_svgo = __commonJS({
  "node_modules/svgo/lib/svgo.js"(exports) {
    "use strict";
    var {
      defaultPlugins,
      resolvePluginConfig,
      extendDefaultPlugins
    } = require_config();
    var { parseSvg } = require_parser2();
    var { stringifySvg } = require_stringifier();
    var { invokePlugins } = require_plugins();
    var JSAPI = require_jsAPI();
    var { encodeSVGDatauri } = require_tools();
    exports.extendDefaultPlugins = extendDefaultPlugins;
    var optimize = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      const maxPassCount = config.multipass ? 10 : 1;
      let prevResultSize = Number.POSITIVE_INFINITY;
      let svgjs = null;
      const info = {};
      if (config.path != null) {
        info.path = config.path;
      }
      for (let i2 = 0; i2 < maxPassCount; i2 += 1) {
        info.multipassCount = i2;
        try {
          svgjs = parseSvg(input, config.path);
        } catch (error) {
          return { error: error.toString(), modernError: error };
        }
        if (svgjs.error != null) {
          if (config.path != null) {
            svgjs.path = config.path;
          }
          return svgjs;
        }
        const plugins = config.plugins || defaultPlugins;
        if (Array.isArray(plugins) === false) {
          throw Error(
            "Invalid plugins list. Provided 'plugins' in config should be an array."
          );
        }
        const resolvedPlugins = plugins.map(resolvePluginConfig);
        const globalOverrides = {};
        if (config.floatPrecision != null) {
          globalOverrides.floatPrecision = config.floatPrecision;
        }
        svgjs = invokePlugins(svgjs, info, resolvedPlugins, null, globalOverrides);
        svgjs = stringifySvg(svgjs, config.js2svg);
        if (svgjs.data.length < prevResultSize) {
          input = svgjs.data;
          prevResultSize = svgjs.data.length;
        } else {
          if (config.datauri) {
            svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
          }
          if (config.path != null) {
            svgjs.path = config.path;
          }
          return svgjs;
        }
      }
      return svgjs;
    };
    exports.optimize = optimize;
    var createContentItem = (data) => {
      return new JSAPI(data);
    };
    exports.createContentItem = createContentItem;
  }
});

// node_modules/svgo/lib/svgo-node.js
var require_svgo_node = __commonJS({
  "node_modules/svgo/lib/svgo-node.js"(exports) {
    "use strict";
    var os = require_os();
    var fs = require_fs();
    var { pathToFileURL } = require_url();
    var path = require_path();
    var {
      extendDefaultPlugins,
      optimize: optimizeAgnostic,
      createContentItem
    } = require_svgo();
    exports.extendDefaultPlugins = extendDefaultPlugins;
    exports.createContentItem = createContentItem;
    var importConfig = async (configFile) => {
      let config;
      if (configFile.endsWith(".cjs")) {
        config = __require(configFile);
      } else {
        try {
          const { default: imported } = await import(pathToFileURL(configFile));
          config = imported;
        } catch (importError) {
          try {
            config = __require(configFile);
          } catch (requireError) {
            if (requireError.code === "ERR_REQUIRE_ESM") {
              throw importError;
            } else {
              throw requireError;
            }
          }
        }
      }
      if (config == null || typeof config !== "object" || Array.isArray(config)) {
        throw Error(`Invalid config file "${configFile}"`);
      }
      return config;
    };
    var isFile = async (file) => {
      try {
        const stats = await fs.promises.stat(file);
        return stats.isFile();
      } catch {
        return false;
      }
    };
    var loadConfig = async (configFile, cwd = process.cwd()) => {
      if (configFile != null) {
        if (path.isAbsolute(configFile)) {
          return await importConfig(configFile);
        } else {
          return await importConfig(path.join(cwd, configFile));
        }
      }
      let dir = cwd;
      while (true) {
        const js = path.join(dir, "svgo.config.js");
        if (await isFile(js)) {
          return await importConfig(js);
        }
        const mjs = path.join(dir, "svgo.config.mjs");
        if (await isFile(mjs)) {
          return await importConfig(mjs);
        }
        const cjs = path.join(dir, "svgo.config.cjs");
        if (await isFile(cjs)) {
          return await importConfig(cjs);
        }
        const parent = path.dirname(dir);
        if (dir === parent) {
          return null;
        }
        dir = parent;
      }
    };
    exports.loadConfig = loadConfig;
    var optimize = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      return optimizeAgnostic(input, {
        ...config,
        js2svg: {
          eol: os.EOL === "\r\n" ? "crlf" : "lf",
          ...config.js2svg
        }
      });
    };
    exports.optimize = optimize;
  }
});

// node_modules/postcss-svgo/src/lib/url.js
var require_url2 = __commonJS({
  "node_modules/postcss-svgo/src/lib/url.js"(exports, module) {
    "use strict";
    function encode(data) {
      return data.replace(/"/g, "'").replace(/%/g, "%25").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/&/g, "%26").replace(/#/g, "%23").replace(/\s+/g, " ");
    }
    var decode = decodeURIComponent;
    module.exports = { encode, decode };
  }
});

// node_modules/postcss-svgo/src/index.js
var require_src5 = __commonJS({
  "node_modules/postcss-svgo/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var { optimize } = require_svgo_node();
    var { encode, decode } = require_url2();
    var PLUGIN = "postcss-svgo";
    var dataURI = /data:image\/svg\+xml(;((charset=)?utf-8|base64))?,/i;
    var dataURIBase64 = /data:image\/svg\+xml;base64,/i;
    var escapedQuotes = /\b([\w-]+)\s*=\s*\\"([\S\s]+?)\\"/g;
    function minifySVG(input, opts) {
      let svg = input;
      let decodedUri, isUriEncoded;
      try {
        decodedUri = decode(input);
        isUriEncoded = decodedUri !== input;
      } catch (e2) {
        isUriEncoded = false;
      }
      if (isUriEncoded) {
        svg = decodedUri;
      }
      if (opts.encode !== void 0) {
        isUriEncoded = opts.encode;
      }
      svg = svg.replace(escapedQuotes, '$1="$2"');
      const result = optimize(svg, opts);
      if (result.error) {
        throw new Error(result.error);
      }
      return {
        result: result.data,
        isUriEncoded
      };
    }
    function minify(decl, opts, postcssResult) {
      const parsed = valueParser(decl.value);
      const minified = parsed.walk((node) => {
        if (node.type !== "function" || node.value.toLowerCase() !== "url" || !node.nodes.length) {
          return;
        }
        let { value, quote } = node.nodes[0];
        let optimizedValue;
        try {
          if (dataURIBase64.test(value)) {
            const url = new URL(value);
            const base64String = `${url.protocol}${url.pathname}`.replace(
              dataURI,
              ""
            );
            const svg = Buffer.from(base64String, "base64").toString("utf8");
            const { result } = minifySVG(svg, opts);
            const data = Buffer.from(result).toString("base64");
            optimizedValue = "data:image/svg+xml;base64," + data + url.hash;
          } else if (dataURI.test(value)) {
            const svg = value.replace(dataURI, "");
            const { result, isUriEncoded } = minifySVG(svg, opts);
            let data = isUriEncoded ? encode(result) : result;
            data = data.replace(/#/g, "%23");
            optimizedValue = "data:image/svg+xml;charset=utf-8," + data;
            quote = isUriEncoded ? '"' : "'";
          } else {
            return;
          }
        } catch (error) {
          decl.warn(postcssResult, `${error}`);
          return;
        }
        node.nodes[0] = Object.assign({}, node.nodes[0], {
          value: optimizedValue,
          quote,
          type: "string",
          before: "",
          after: ""
        });
        return false;
      });
      decl.value = minified.toString();
    }
    function pluginCreator(opts = {}) {
      return {
        postcssPlugin: PLUGIN,
        OnceExit(css, { result }) {
          css.walkDecls((decl) => {
            if (!dataURI.test(decl.value)) {
              return;
            }
            minify(decl, opts, result);
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-reduce-transforms/src/index.js
var require_src6 = __commonJS({
  "node_modules/postcss-reduce-transforms/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    function getValues(list, node, index) {
      if (index % 2 === 0) {
        let value = NaN;
        if (node.type === "function" && (node.value === "var" || node.value === "env") && node.nodes.length === 1) {
          value = valueParser.stringify(node.nodes);
        } else if (node.type === "word") {
          value = parseFloat(node.value);
        }
        return [...list, value];
      }
      return list;
    }
    function matrix3d(node, values) {
      if (values.length !== 16) {
        return;
      }
      if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {
        const { nodes } = node;
        node.value = "matrix";
        node.nodes = [
          nodes[0],
          nodes[1],
          nodes[2],
          nodes[3],
          nodes[8],
          nodes[9],
          nodes[10],
          nodes[11],
          nodes[24],
          nodes[25],
          nodes[26]
        ];
      }
    }
    var rotate3dMappings = /* @__PURE__ */ new Map([
      [[1, 0, 0].toString(), "rotateX"],
      [[0, 1, 0].toString(), "rotateY"],
      [[0, 0, 1].toString(), "rotate"]
    ]);
    function rotate3d(node, values) {
      if (values.length !== 4) {
        return;
      }
      const { nodes } = node;
      const match = rotate3dMappings.get(values.slice(0, 3).toString());
      if (match) {
        node.value = match;
        node.nodes = [nodes[6]];
      }
    }
    function rotateZ(node, values) {
      if (values.length !== 1) {
        return;
      }
      node.value = "rotate";
    }
    function scale(node, values) {
      if (values.length !== 2) {
        return;
      }
      const { nodes } = node;
      const [first, second] = values;
      if (first === second) {
        node.nodes = [nodes[0]];
        return;
      }
      if (second === 1) {
        node.value = "scaleX";
        node.nodes = [nodes[0]];
        return;
      }
      if (first === 1) {
        node.value = "scaleY";
        node.nodes = [nodes[2]];
        return;
      }
    }
    function scale3d(node, values) {
      if (values.length !== 3) {
        return;
      }
      const { nodes } = node;
      const [first, second, third] = values;
      if (second === 1 && third === 1) {
        node.value = "scaleX";
        node.nodes = [nodes[0]];
        return;
      }
      if (first === 1 && third === 1) {
        node.value = "scaleY";
        node.nodes = [nodes[2]];
        return;
      }
      if (first === 1 && second === 1) {
        node.value = "scaleZ";
        node.nodes = [nodes[4]];
        return;
      }
    }
    function translate(node, values) {
      if (values.length !== 2) {
        return;
      }
      const { nodes } = node;
      if (values[1] === 0) {
        node.nodes = [nodes[0]];
        return;
      }
      if (values[0] === 0) {
        node.value = "translateY";
        node.nodes = [nodes[2]];
        return;
      }
    }
    function translate3d(node, values) {
      if (values.length !== 3) {
        return;
      }
      const { nodes } = node;
      if (values[0] === 0 && values[1] === 0) {
        node.value = "translateZ";
        node.nodes = [nodes[4]];
      }
    }
    var reducers = /* @__PURE__ */ new Map([
      ["matrix3d", matrix3d],
      ["rotate3d", rotate3d],
      ["rotateZ", rotateZ],
      ["scale", scale],
      ["scale3d", scale3d],
      ["translate", translate],
      ["translate3d", translate3d]
    ]);
    function normalizeReducerName(name) {
      const lowerCasedName = name.toLowerCase();
      if (lowerCasedName === "rotatez") {
        return "rotateZ";
      }
      return lowerCasedName;
    }
    function reduce(node) {
      if (node.type === "function") {
        const normalizedReducerName = normalizeReducerName(node.value);
        const reducer = reducers.get(normalizedReducerName);
        if (reducer !== void 0) {
          reducer(node, node.nodes.reduce(getValues, []));
        }
      }
      return false;
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-reduce-transforms",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkDecls(/transform$/i, (decl) => {
                const value = decl.value;
                if (!value) {
                  return;
                }
                if (cache.has(value)) {
                  decl.value = cache.get(value);
                  return;
                }
                const result = valueParser(value).walk(reduce).toString();
                decl.value = result;
                cache.set(value, result);
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-convert-values/src/lib/convert.js
var require_convert = __commonJS({
  "node_modules/postcss-convert-values/src/lib/convert.js"(exports, module) {
    "use strict";
    var lengthConv = /* @__PURE__ */ new Map([
      ["in", 96],
      ["px", 1],
      ["pt", 4 / 3],
      ["pc", 16]
    ]);
    var timeConv = /* @__PURE__ */ new Map([
      ["s", 1e3],
      ["ms", 1]
    ]);
    var angleConv = /* @__PURE__ */ new Map([
      ["turn", 360],
      ["deg", 1]
    ]);
    function dropLeadingZero(number) {
      const value = String(number);
      if (number % 1) {
        if (value[0] === "0") {
          return value.slice(1);
        }
        if (value[0] === "-" && value[1] === "0") {
          return "-" + value.slice(2);
        }
      }
      return value;
    }
    function transform(number, originalUnit, conversions) {
      let conversionUnits = [...conversions.keys()].filter((u2) => {
        return originalUnit !== u2;
      });
      const base = number * conversions.get(originalUnit);
      return conversionUnits.map(
        (u2) => dropLeadingZero(base / conversions.get(u2)) + u2
      ).reduce((a2, b2) => a2.length < b2.length ? a2 : b2);
    }
    module.exports = function(number, unit, { time, length, angle }) {
      let value = dropLeadingZero(number) + (unit ? unit : "");
      let converted;
      const lowerCaseUnit = unit.toLowerCase();
      if (length !== false && lengthConv.has(lowerCaseUnit)) {
        converted = transform(number, lowerCaseUnit, lengthConv);
      }
      if (time !== false && timeConv.has(lowerCaseUnit)) {
        converted = transform(number, lowerCaseUnit, timeConv);
      }
      if (angle !== false && angleConv.has(lowerCaseUnit)) {
        converted = transform(number, lowerCaseUnit, angleConv);
      }
      if (converted && converted.length < value.length) {
        value = converted;
      }
      return value;
    };
  }
});

// node_modules/postcss-convert-values/src/index.js
var require_src7 = __commonJS({
  "node_modules/postcss-convert-values/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var browserslist = require_browserslist();
    var convert = require_convert();
    var LENGTH_UNITS = /* @__PURE__ */ new Set([
      "em",
      "ex",
      "ch",
      "rem",
      "vw",
      "vh",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px"
    ]);
    var notALength = /* @__PURE__ */ new Set([
      "descent-override",
      "ascent-override",
      "font-stretch",
      "size-adjust",
      "line-gap-override"
    ]);
    var keepWhenZero = /* @__PURE__ */ new Set([
      "stroke-dashoffset",
      "stroke-width",
      "line-height"
    ]);
    var keepZeroPercent = /* @__PURE__ */ new Set(["max-height", "height", "min-width"]);
    function stripLeadingDot(item) {
      if (item.charCodeAt(0) === ".".charCodeAt(0)) {
        return item.slice(1);
      } else {
        return item;
      }
    }
    function parseWord(node, opts, keepZeroUnit) {
      const pair = valueParser.unit(node.value);
      if (pair) {
        const num = Number(pair.number);
        const u2 = stripLeadingDot(pair.unit);
        if (num === 0) {
          node.value = 0 + (keepZeroUnit || !LENGTH_UNITS.has(u2.toLowerCase()) && u2 !== "%" ? u2 : "");
        } else {
          node.value = convert(num, u2, opts);
          if (typeof opts.precision === "number" && u2.toLowerCase() === "px" && pair.number.includes(".")) {
            const precision = Math.pow(10, opts.precision);
            node.value = Math.round(parseFloat(node.value) * precision) / precision + u2;
          }
        }
      }
    }
    function clampOpacity(node) {
      const pair = valueParser.unit(node.value);
      if (!pair) {
        return;
      }
      let num = Number(pair.number);
      if (num > 1) {
        node.value = pair.unit === "%" ? num + pair.unit : 1 + pair.unit;
      } else if (num < 0) {
        node.value = 0 + pair.unit;
      }
    }
    function shouldKeepZeroUnit(decl, browsers) {
      const { parent } = decl;
      const lowerCasedProp = decl.prop.toLowerCase();
      return decl.value.includes("%") && keepZeroPercent.has(lowerCasedProp) && browsers.includes("ie 11") || parent && parent.parent && parent.parent.type === "atrule" && parent.parent.name.toLowerCase() === "keyframes" && lowerCasedProp === "stroke-dasharray" || keepWhenZero.has(lowerCasedProp);
    }
    function transform(opts, browsers, decl) {
      const lowerCasedProp = decl.prop.toLowerCase();
      if (lowerCasedProp.includes("flex") || lowerCasedProp.indexOf("--") === 0 || notALength.has(lowerCasedProp)) {
        return;
      }
      decl.value = valueParser(decl.value).walk((node) => {
        const lowerCasedValue = node.value.toLowerCase();
        if (node.type === "word") {
          parseWord(node, opts, shouldKeepZeroUnit(decl, browsers));
          if (lowerCasedProp === "opacity" || lowerCasedProp === "shape-image-threshold") {
            clampOpacity(node);
          }
        } else if (node.type === "function") {
          if (lowerCasedValue === "calc" || lowerCasedValue === "min" || lowerCasedValue === "max" || lowerCasedValue === "clamp" || lowerCasedValue === "hsl" || lowerCasedValue === "hsla") {
            valueParser.walk(node.nodes, (n2) => {
              if (n2.type === "word") {
                parseWord(n2, opts, true);
              }
            });
            return false;
          }
          if (lowerCasedValue === "url") {
            return false;
          }
        }
      }).toString();
    }
    var plugin = "postcss-convert-values";
    function pluginCreator(opts = { precision: false }) {
      const browsers = browserslist(null, {
        stats: opts.stats,
        path: __dirname,
        env: opts.env
      });
      return {
        postcssPlugin: plugin,
        OnceExit(css) {
          css.walkDecls((decl) => transform(opts, browsers, decl));
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex = "";
      var spaceTerminated = false;
      for (var i2 = 0; i2 < 6 && lower[i2] !== void 0; i2++) {
        var code = lower.charCodeAt(i2);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex += lower[i2];
      }
      if (hex.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i2 = 0; i2 < str.length; i2++) {
        if (str[i2] === "\\") {
          var gobbled = gobbleHex(str.slice(i2 + 1, i2 + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i2 += gobbled[1];
            continue;
          }
          if (str[i2 + 1] === "\\") {
            ret += "\\";
            i2++;
            continue;
          }
          if (str.length === i2 + 1) {
            ret += str[i2];
          }
          continue;
        }
        ret += str[i2];
      }
      return ret;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = stripComments;
    function stripComments(str) {
      var s2 = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s2 = s2 + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s2;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s2 = s2 + str.slice(lastEnd);
      return s2;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/index.js
var require_util2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node3 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _util = require_util2();
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i2 in obj) {
        if (!obj.hasOwnProperty(i2)) {
          continue;
        }
        var value = obj[i2];
        var type = typeof value;
        if (i2 === "parent" && type === "object") {
          if (parent) {
            cloned[i2] = parent;
          }
        } else if (value instanceof Array) {
          cloned[i2] = value.map(function(j2) {
            return cloneNode2(j2, cloned);
          });
        } else {
          cloned[i2] = cloneNode2(value, cloned);
        }
      }
      return cloned;
    };
    var Node4 = function() {
      function Node5(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node5.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index in arguments) {
            this.parent.insertBefore(this, arguments[index]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value;
        if (originalEscaped || valueEscaped !== value) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass2(Node5, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set2(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set2(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node5;
    }();
    exports["default"] = Node4;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
    var TAG = "tag";
    exports.TAG = TAG;
    var STRING = "string";
    exports.STRING = STRING;
    var SELECTOR = "selector";
    exports.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports.NESTING = NESTING;
    var ID = "id";
    exports.ID = ID;
    var COMMENT = "comment";
    exports.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports.UNIVERSAL = UNIVERSAL;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var types = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          return function() {
            if (i2 >= o2.length)
              return { done: true };
            return { done: false, value: o2[i2++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o2[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray2(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray2(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray2(o2, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Container = function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container2.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index) {
        return this.nodes[index];
      };
      _proto.index = function index(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (oldIndex <= index) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index <= oldIndex) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index, result;
        while (this.indexes[id] < this.length) {
          index = this.indexes[id];
          result = callback(this.at(index), index);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk(callback) {
        return this.each(function(node, i2) {
          var result = callback(node, i2);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node, index) {
          var split2 = callback.call(_this11, node);
          current.push(node);
          if (split2) {
            memo.push(current);
            current = [];
          } else if (index === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map2(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass2(Container2, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container2;
    }(_node["default"]);
    exports["default"] = Container;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Root = function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass2(Root2, [{
        key: "errorGenerator",
        set: function set2(handler) {
          this._error = handler;
        }
      }]);
      return Root2;
    }(_container["default"]);
    exports["default"] = Root;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Selector = function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports["default"] = Selector;
    module.exports = exports.default;
  }
});

// node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "node_modules/cssesc/cssesc.js"(exports, module) {
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty2.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string2, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string2.charAt(0);
      var output = "";
      var counter = 0;
      var length = string2.length;
      while (counter < length) {
        var character = string2.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module.exports = cssesc;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util2();
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var ClassName = function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass2(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set2(v2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped !== v2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v2;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports["default"] = ClassName;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Comment2 = function(_Node) {
      _inheritsLoose(Comment3, _Node);
      function Comment3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment3;
    }(_node["default"]);
    exports["default"] = Comment2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var ID = function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports["default"] = ID;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util2();
    var _node = _interopRequireDefault(require_node3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Namespace = function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
          return this.namespaceString + "|" + value;
        } else {
          return value;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass2(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set2(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set2(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports["default"] = Namespace;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Tag = function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports["default"] = Tag;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var String2 = function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports["default"] = String2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Pseudo = function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports["default"] = Pseudo;
    module.exports = exports.default;
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned2 = false;
      function deprecated() {
        if (!warned2) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned2 = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.unescapeValue = unescapeValue;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var deprecate = require_browser2();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value;
      var m2 = unescaped.match(WRAPPED_IN_QUOTES);
      if (m2) {
        quoteMark = m2[1];
        unescaped = m2[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v2 = this.value;
        var numSingleQuotes = v2.replace(/[^']/g, "").length;
        var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v2, {
            isIdentifier: true
          });
          if (escaped === v2) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v2, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value, {
            isIdentifier: true
          });
          if (escaped !== value) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
          return value ? count : -1;
        }
        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass2(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set2(value) {
          warnOfDeprecatedQuotedAssignment();
        }
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set2(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set2(v2) {
          if (this._constructed) {
            var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
            if (deprecatedUsage) {
              warnOfDeprecatedValueAssignment();
            }
            if (unescaped === this._value && quoteMark === this._quoteMark) {
              return;
            }
            this._value = unescaped;
            this._quoteMark = quoteMark;
            this._syncRawValue();
          } else {
            this._value = v2;
          }
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set2(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Universal = function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports["default"] = Universal;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Combinator = function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports["default"] = Combinator;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o2, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf2(o2, p2);
    }
    var Nesting = function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports["default"] = Nesting;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = sortAscending;
    function sortAscending(list) {
      return list.sort(function(a2, b2) {
        return a2 - b2;
      });
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
    var ampersand = 38;
    exports.ampersand = ampersand;
    var asterisk = 42;
    exports.asterisk = asterisk;
    var at = 64;
    exports.at = at;
    var comma = 44;
    exports.comma = comma;
    var colon = 58;
    exports.colon = colon;
    var semicolon = 59;
    exports.semicolon = semicolon;
    var openParenthesis = 40;
    exports.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports.openSquare = openSquare;
    var closeSquare = 93;
    exports.closeSquare = closeSquare;
    var dollar = 36;
    exports.dollar = dollar;
    var tilde = 126;
    exports.tilde = tilde;
    var caret = 94;
    exports.caret = caret;
    var plus = 43;
    exports.plus = plus;
    var equals = 61;
    exports.equals = equals;
    var pipe = 124;
    exports.pipe = pipe;
    var greaterThan = 62;
    exports.greaterThan = greaterThan;
    var space = 32;
    exports.space = space;
    var singleQuote = 39;
    exports.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports.doubleQuote = doubleQuote;
    var slash = 47;
    exports.slash = slash;
    var bang = 33;
    exports.bang = bang;
    var backslash = 92;
    exports.backslash = backslash;
    var cr = 13;
    exports.cr = cr;
    var feed = 12;
    exports.feed = feed;
    var newline = 10;
    exports.newline = newline;
    var tab = 9;
    exports.tab = tab;
    var str = singleQuote;
    exports.str = str;
    var comment = -1;
    exports.comment = comment;
    var word = -2;
    exports.word = word;
    var combinator = -3;
    exports.combinator = combinator;
  }
});

// node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = tokenize;
    exports.FIELDS = void 0;
    var t2 = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t2.tab] = true, _unescapable[t2.newline] = true, _unescapable[t2.cr] = true, _unescapable[t2.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t2.space] = true, _wordDelimiters[t2.tab] = true, _wordDelimiters[t2.newline] = true, _wordDelimiters[t2.cr] = true, _wordDelimiters[t2.feed] = true, _wordDelimiters[t2.ampersand] = true, _wordDelimiters[t2.asterisk] = true, _wordDelimiters[t2.bang] = true, _wordDelimiters[t2.comma] = true, _wordDelimiters[t2.colon] = true, _wordDelimiters[t2.semicolon] = true, _wordDelimiters[t2.openParenthesis] = true, _wordDelimiters[t2.closeParenthesis] = true, _wordDelimiters[t2.openSquare] = true, _wordDelimiters[t2.closeSquare] = true, _wordDelimiters[t2.singleQuote] = true, _wordDelimiters[t2.doubleQuote] = true, _wordDelimiters[t2.plus] = true, _wordDelimiters[t2.pipe] = true, _wordDelimiters[t2.tilde] = true, _wordDelimiters[t2.greaterThan] = true, _wordDelimiters[t2.equals] = true, _wordDelimiters[t2.dollar] = true, _wordDelimiters[t2.caret] = true, _wordDelimiters[t2.slash] = true, _wordDelimiters);
    var hex = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i2 = 0; i2 < hexChars.length; i2++) {
      hex[hexChars.charCodeAt(i2)] = true;
    }
    var i2;
    function consumeWord(css, start) {
      var next = start;
      var code;
      do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
          return next - 1;
        } else if (code === t2.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code = css.charCodeAt(next + 1);
      if (unescapable[code]) {
      } else if (hex[code]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code = css.charCodeAt(next + 1);
        } while (hex[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t2.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports.FIELDS = FIELDS;
    function tokenize(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length = _css.length;
      var offset = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset, start);
        }
      }
      while (start < length) {
        code = css.charCodeAt(start);
        if (code === t2.newline) {
          offset = start;
          line += 1;
        }
        switch (code) {
          case t2.space:
          case t2.tab:
          case t2.newline:
          case t2.cr:
          case t2.feed:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === t2.newline) {
                offset = next;
                line += 1;
              }
            } while (code === t2.space || code === t2.newline || code === t2.tab || code === t2.cr || code === t2.feed);
            tokenType = t2.space;
            endLine = line;
            endColumn = next - offset - 1;
            end = next;
            break;
          case t2.plus:
          case t2.greaterThan:
          case t2.tilde:
          case t2.pipe:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === t2.plus || code === t2.greaterThan || code === t2.tilde || code === t2.pipe);
            tokenType = t2.combinator;
            endLine = line;
            endColumn = start - offset;
            end = next;
            break;
          case t2.asterisk:
          case t2.ampersand:
          case t2.bang:
          case t2.comma:
          case t2.equals:
          case t2.dollar:
          case t2.caret:
          case t2.openSquare:
          case t2.closeSquare:
          case t2.colon:
          case t2.semicolon:
          case t2.openParenthesis:
          case t2.closeParenthesis:
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          case t2.singleQuote:
          case t2.doubleQuote:
            quote = code === t2.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t2.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t2.str;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          default:
            if (code === t2.slash && css.charCodeAt(start + 1) === t2.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              tokenType = t2.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code === t2.slash) {
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t2.word;
              endLine = line;
              endColumn = next - offset;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          line,
          start - offset,
          endLine,
          endColumn,
          start,
          end
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// node_modules/postcss-selector-parser/dist/parser.js
var require_parser3 = __commonJS({
  "node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector2());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo2());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types = _interopRequireWildcard(require_types());
    var _util = require_util2();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value = node[prop];
      if (typeof value !== "string") {
        return;
      }
      if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i2 = -1;
      var indexes = [];
      while ((i2 = array.indexOf(item, i2 + 1)) !== -1) {
        indexes.push(i2);
      }
      return indexes;
    }
    function uniqs() {
      var list = Array.prototype.concat.apply([], arguments);
      return list.filter(function(item, i2) {
        return i2 === list.indexOf(item);
      });
    }
    var Parser = function() {
      function Parser2(rule, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser2.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n2) {
          var spaceBefore = _this2.lossySpace(n2.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n2.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n2.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n2.value + _this2.lossySpace(n2.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position) {
        if (position === void 0) {
          position = this.position;
        }
        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n2) {
                return _this3.newNode(n2);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string2() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i2) {
          var escapedDot = word[i2 - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i2) {
          return word[i2 - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i2) {
          var index = indices[i2 + 1] || word.length;
          var value = word.slice(ind, index);
          if (i2 === 0 && firstCallback) {
            return firstCallback.call(_this5, value, indices.length);
          }
          var node;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse4(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass2(Parser2, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser2;
    }();
    exports["default"] = Parser;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/processor.js
var require_processor = __commonJS({
  "node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor = function() {
      function Processor2(func, options) {
        this.func = func || function noop() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor2.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var parser = new _parser["default"](rule, this._parseOptions(options));
        return parser.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve27, reject) {
          try {
            var root = _this._root(rule, options);
            Promise.resolve(_this.func(root)).then(function(transform) {
              var string2 = void 0;
              if (_this._shouldUpdateSelector(rule, options)) {
                string2 = root.toString();
                rule.selector = string2;
              }
              return {
                transform,
                root,
                string: string2
              };
            }).then(resolve27, reject);
          } catch (e2) {
            reject(e2);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string2 = void 0;
        if (options.updateSelector && typeof rule !== "string") {
          string2 = root.toString();
          rule.selector = string2;
        }
        return {
          transform,
          root,
          string: string2
        };
      };
      _proto.ast = function ast(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
      };
      _proto.transform = function transform(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
      };
      _proto.process = function process2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
      };
      return Processor2;
    }();
    exports["default"] = Processor;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo2());
    var _root = _interopRequireDefault(require_root());
    var _selector = _interopRequireDefault(require_selector2());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    exports.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    exports.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports.selector = selector;
    var string2 = function string3(opts) {
      return new _string["default"](opts);
    };
    exports.string = string2;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports.universal = universal;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.isNode = isNode;
    exports.isPseudoElement = isPseudoElement;
    exports.isPseudoClass = isPseudoClass;
    exports.isContainer = isContainer;
    exports.isNamespace = isNamespace;
    exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    exports.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports.isUniversal = isUniversal;
    function isPseudoElement(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement(node);
    }
    function isContainer(node) {
      return !!(isNode(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      exports[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _constructors[key])
        return;
      exports[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _guards[key])
        return;
      exports[key] = _guards[key];
    });
  }
});

// node_modules/postcss-selector-parser/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser = function parser2(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser, selectors);
    delete parser.__esModule;
    var _default = parser;
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/postcss-calc/src/parser.js
var require_parser4 = __commonJS({
  "node_modules/postcss-calc/src/parser.js"(exports) {
    var parser = function() {
      function JisonParserError(msg, hash) {
        Object.defineProperty(this, "name", {
          enumerable: false,
          writable: false,
          value: "JisonParserError"
        });
        if (msg == null)
          msg = "???";
        Object.defineProperty(this, "message", {
          enumerable: false,
          writable: true,
          value: msg
        });
        this.hash = hash;
        var stacktrace;
        if (hash && hash.exception instanceof Error) {
          var ex2 = hash.exception;
          this.message = ex2.message || msg;
          stacktrace = ex2.stack;
        }
        if (!stacktrace) {
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            stacktrace = new Error(msg).stack;
          }
        }
        if (stacktrace) {
          Object.defineProperty(this, "stack", {
            enumerable: false,
            writable: false,
            value: stacktrace
          });
        }
      }
      if (typeof Object.setPrototypeOf === "function") {
        Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
      } else {
        JisonParserError.prototype = Object.create(Error.prototype);
      }
      JisonParserError.prototype.constructor = JisonParserError;
      JisonParserError.prototype.name = "JisonParserError";
      function bp(s3) {
        var rv = [];
        var p2 = s3.pop;
        var r2 = s3.rule;
        for (var i2 = 0, l2 = p2.length; i2 < l2; i2++) {
          rv.push([
            p2[i2],
            r2[i2]
          ]);
        }
        return rv;
      }
      function bda(s3) {
        var rv = {};
        var d2 = s3.idx;
        var g2 = s3.goto;
        for (var i2 = 0, l2 = d2.length; i2 < l2; i2++) {
          var j2 = d2[i2];
          rv[j2] = g2[i2];
        }
        return rv;
      }
      function bt(s3) {
        var rv = [];
        var d2 = s3.len;
        var y2 = s3.symbol;
        var t2 = s3.type;
        var a2 = s3.state;
        var m2 = s3.mode;
        var g2 = s3.goto;
        for (var i2 = 0, l2 = d2.length; i2 < l2; i2++) {
          var n2 = d2[i2];
          var q = {};
          for (var j2 = 0; j2 < n2; j2++) {
            var z = y2.shift();
            switch (t2.shift()) {
              case 2:
                q[z] = [
                  m2.shift(),
                  g2.shift()
                ];
                break;
              case 0:
                q[z] = a2.shift();
                break;
              default:
                q[z] = [
                  3
                ];
            }
          }
          rv.push(q);
        }
        return rv;
      }
      function s2(c3, l2, a2) {
        a2 = a2 || 0;
        for (var i2 = 0; i2 < l2; i2++) {
          this.push(c3);
          c3 += a2;
        }
      }
      function c2(i2, l2) {
        i2 = this.length - i2;
        for (l2 += i2; i2 < l2; i2++) {
          this.push(this[i2]);
        }
      }
      function u2(a2) {
        var rv = [];
        for (var i2 = 0, l2 = a2.length; i2 < l2; i2++) {
          var e2 = a2[i2];
          if (typeof e2 === "function") {
            i2++;
            e2.apply(rv, a2[i2]);
          } else {
            rv.push(e2);
          }
        }
        return rv;
      }
      var parser2 = {
        trace: function no_op_trace() {
        },
        JisonParserError,
        yy: {},
        options: {
          type: "lalr",
          hasPartialLrUpgradeOnConflict: true,
          errorRecoveryTokenDiscardCount: 3
        },
        symbols_: {
          "$accept": 0,
          "$end": 1,
          "ADD": 6,
          "ANGLE": 12,
          "CALC": 3,
          "CHS": 19,
          "DIV": 9,
          "EMS": 17,
          "EOF": 1,
          "EXS": 18,
          "FREQ": 14,
          "FUNCTION": 10,
          "LENGTH": 11,
          "LPAREN": 4,
          "MUL": 8,
          "NUMBER": 26,
          "PERCENTAGE": 25,
          "REMS": 20,
          "RES": 15,
          "RPAREN": 5,
          "SUB": 7,
          "TIME": 13,
          "UNKNOWN_DIMENSION": 16,
          "VHS": 21,
          "VMAXS": 24,
          "VMINS": 23,
          "VWS": 22,
          "dimension": 30,
          "error": 2,
          "expression": 27,
          "function": 29,
          "math_expression": 28,
          "number": 31
        },
        terminals_: {
          1: "EOF",
          2: "error",
          3: "CALC",
          4: "LPAREN",
          5: "RPAREN",
          6: "ADD",
          7: "SUB",
          8: "MUL",
          9: "DIV",
          10: "FUNCTION",
          11: "LENGTH",
          12: "ANGLE",
          13: "TIME",
          14: "FREQ",
          15: "RES",
          16: "UNKNOWN_DIMENSION",
          17: "EMS",
          18: "EXS",
          19: "CHS",
          20: "REMS",
          21: "VHS",
          22: "VWS",
          23: "VMINS",
          24: "VMAXS",
          25: "PERCENTAGE",
          26: "NUMBER"
        },
        TERROR: 2,
        EOF: 1,
        originalQuoteName: null,
        originalParseError: null,
        cleanupAfterParse: null,
        constructParseErrorInfo: null,
        yyMergeLocationInfo: null,
        __reentrant_call_depth: 0,
        __error_infos: [],
        __error_recovery_infos: [],
        quoteName: function parser_quoteName(id_str) {
          return '"' + id_str + '"';
        },
        getSymbolName: function parser_getSymbolName(symbol) {
          if (this.terminals_[symbol]) {
            return this.terminals_[symbol];
          }
          var s3 = this.symbols_;
          for (var key in s3) {
            if (s3[key] === symbol) {
              return key;
            }
          }
          return null;
        },
        describeSymbol: function parser_describeSymbol(symbol) {
          if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
            return this.terminal_descriptions_[symbol];
          } else if (symbol === this.EOF) {
            return "end of input";
          }
          var id = this.getSymbolName(symbol);
          if (id) {
            return this.quoteName(id);
          }
          return null;
        },
        collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
          var TERROR = this.TERROR;
          var tokenset = [];
          var check = {};
          if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
            return [
              this.state_descriptions_[state]
            ];
          }
          for (var p2 in this.table[state]) {
            p2 = +p2;
            if (p2 !== TERROR) {
              var d2 = do_not_describe ? p2 : this.describeSymbol(p2);
              if (d2 && !check[d2]) {
                tokenset.push(d2);
                check[d2] = true;
              }
            }
          }
          return tokenset;
        },
        productions_: bp({
          pop: u2([
            27,
            s2,
            [28, 9],
            29,
            s2,
            [30, 17],
            s2,
            [31, 3]
          ]),
          rule: u2([
            2,
            4,
            s2,
            [3, 5],
            s2,
            [1, 19],
            2,
            2,
            c2,
            [3, 3]
          ])
        }),
        performAction: function parser__PerformAction(yystate, yysp, yyvstack) {
          var yy = this.yy;
          var yyparser = yy.parser;
          var yylexer = yy.lexer;
          switch (yystate) {
            case 0:
              this.$ = yyvstack[yysp - 1];
              break;
            case 1:
              this.$ = yyvstack[yysp - 1];
              return yyvstack[yysp - 1];
              break;
            case 2:
              this.$ = yyvstack[yysp - 1];
              break;
            case 3:
            case 4:
            case 5:
            case 6:
              this.$ = { type: "MathExpression", operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
              break;
            case 7:
              this.$ = { type: "ParenthesizedExpression", content: yyvstack[yysp - 1] };
              break;
            case 8:
            case 9:
            case 10:
              this.$ = yyvstack[yysp];
              break;
            case 11:
              this.$ = { type: "Function", value: yyvstack[yysp] };
              break;
            case 12:
              this.$ = { type: "LengthValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 13:
              this.$ = { type: "AngleValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 14:
              this.$ = { type: "TimeValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 15:
              this.$ = { type: "FrequencyValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 16:
              this.$ = { type: "ResolutionValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 17:
              this.$ = { type: "UnknownDimension", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+$/i.exec(yyvstack[yysp])[0] };
              break;
            case 18:
              this.$ = { type: "EmValue", value: parseFloat(yyvstack[yysp]), unit: "em" };
              break;
            case 19:
              this.$ = { type: "ExValue", value: parseFloat(yyvstack[yysp]), unit: "ex" };
              break;
            case 20:
              this.$ = { type: "ChValue", value: parseFloat(yyvstack[yysp]), unit: "ch" };
              break;
            case 21:
              this.$ = { type: "RemValue", value: parseFloat(yyvstack[yysp]), unit: "rem" };
              break;
            case 22:
              this.$ = { type: "VhValue", value: parseFloat(yyvstack[yysp]), unit: "vh" };
              break;
            case 23:
              this.$ = { type: "VwValue", value: parseFloat(yyvstack[yysp]), unit: "vw" };
              break;
            case 24:
              this.$ = { type: "VminValue", value: parseFloat(yyvstack[yysp]), unit: "vmin" };
              break;
            case 25:
              this.$ = { type: "VmaxValue", value: parseFloat(yyvstack[yysp]), unit: "vmax" };
              break;
            case 26:
              this.$ = { type: "PercentageValue", value: parseFloat(yyvstack[yysp]), unit: "%" };
              break;
            case 27:
              var prev = yyvstack[yysp];
              this.$ = prev;
              break;
            case 28:
              var prev = yyvstack[yysp];
              prev.value *= -1;
              this.$ = prev;
              break;
            case 29:
            case 30:
              this.$ = { type: "Number", value: parseFloat(yyvstack[yysp]) };
              break;
            case 31:
              this.$ = { type: "Number", value: parseFloat(yyvstack[yysp]) * -1 };
              break;
          }
        },
        table: bt({
          len: u2([
            26,
            1,
            5,
            1,
            25,
            s2,
            [0, 19],
            19,
            19,
            0,
            0,
            s2,
            [25, 5],
            5,
            0,
            0,
            18,
            18,
            0,
            0,
            6,
            6,
            0,
            0,
            c2,
            [11, 3]
          ]),
          symbol: u2([
            3,
            4,
            6,
            7,
            s2,
            [10, 22, 1],
            1,
            1,
            s2,
            [6, 4, 1],
            4,
            c2,
            [33, 21],
            c2,
            [32, 4],
            6,
            7,
            c2,
            [22, 16],
            30,
            c2,
            [19, 19],
            c2,
            [63, 25],
            c2,
            [25, 100],
            s2,
            [5, 5, 1],
            c2,
            [149, 17],
            c2,
            [167, 18],
            30,
            1,
            c2,
            [42, 5],
            c2,
            [6, 6],
            c2,
            [5, 5]
          ]),
          type: u2([
            s2,
            [2, 21],
            s2,
            [0, 5],
            1,
            s2,
            [2, 27],
            s2,
            [0, 4],
            c2,
            [22, 19],
            c2,
            [19, 37],
            c2,
            [63, 25],
            c2,
            [25, 103],
            c2,
            [148, 19],
            c2,
            [18, 18]
          ]),
          state: u2([
            1,
            2,
            5,
            6,
            7,
            33,
            c2,
            [4, 3],
            34,
            38,
            40,
            c2,
            [6, 3],
            41,
            c2,
            [4, 3],
            42,
            c2,
            [4, 3],
            43,
            c2,
            [4, 3],
            44,
            c2,
            [22, 5]
          ]),
          mode: u2([
            s2,
            [1, 228],
            s2,
            [2, 4],
            c2,
            [6, 8],
            s2,
            [1, 5]
          ]),
          goto: u2([
            3,
            4,
            24,
            25,
            s2,
            [8, 16, 1],
            s2,
            [26, 7, 1],
            c2,
            [27, 21],
            36,
            37,
            c2,
            [18, 15],
            35,
            c2,
            [18, 17],
            39,
            c2,
            [57, 21],
            c2,
            [21, 84],
            45,
            c2,
            [168, 4],
            c2,
            [128, 17],
            c2,
            [17, 17],
            s2,
            [3, 4],
            30,
            31,
            s2,
            [4, 4],
            30,
            31,
            46,
            c2,
            [51, 4]
          ])
        }),
        defaultActions: bda({
          idx: u2([
            s2,
            [5, 19, 1],
            26,
            27,
            34,
            35,
            38,
            39,
            42,
            43,
            45,
            46
          ]),
          goto: u2([
            s2,
            [8, 19, 1],
            29,
            1,
            27,
            30,
            28,
            31,
            5,
            6,
            7,
            2
          ])
        }),
        parseError: function parseError(str, hash, ExceptionClass) {
          if (hash.recoverable) {
            if (typeof this.trace === "function") {
              this.trace(str);
            }
            hash.destroy();
          } else {
            if (typeof this.trace === "function") {
              this.trace(str);
            }
            if (!ExceptionClass) {
              ExceptionClass = this.JisonParserError;
            }
            throw new ExceptionClass(str, hash);
          }
        },
        parse: function parse4(input) {
          var self2 = this;
          var stack = new Array(128);
          var sstack = new Array(128);
          var vstack = new Array(128);
          var table = this.table;
          var sp = 0;
          var symbol = 0;
          var TERROR = this.TERROR;
          var EOF = this.EOF;
          var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;
          var NO_ACTION = [0, 47];
          var lexer2;
          if (this.__lexer__) {
            lexer2 = this.__lexer__;
          } else {
            lexer2 = this.__lexer__ = Object.create(this.lexer);
          }
          var sharedState_yy = {
            parseError: void 0,
            quoteName: void 0,
            lexer: void 0,
            parser: void 0,
            pre_parse: void 0,
            post_parse: void 0,
            pre_lex: void 0,
            post_lex: void 0
          };
          var ASSERT;
          if (typeof assert !== "function") {
            ASSERT = function JisonAssert(cond, msg) {
              if (!cond) {
                throw new Error("assertion failed: " + (msg || "***"));
              }
            };
          } else {
            ASSERT = assert;
          }
          this.yyGetSharedState = function yyGetSharedState() {
            return sharedState_yy;
          };
          function shallow_copy_noclobber(dst, src) {
            for (var k2 in src) {
              if (typeof dst[k2] === "undefined" && Object.prototype.hasOwnProperty.call(src, k2)) {
                dst[k2] = src[k2];
              }
            }
          }
          shallow_copy_noclobber(sharedState_yy, this.yy);
          sharedState_yy.lexer = lexer2;
          sharedState_yy.parser = this;
          if (typeof sharedState_yy.parseError === "function") {
            this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
              if (!ExceptionClass) {
                ExceptionClass = this.JisonParserError;
              }
              return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
            };
          } else {
            this.parseError = this.originalParseError;
          }
          if (typeof sharedState_yy.quoteName === "function") {
            this.quoteName = function quoteNameAlt(id_str) {
              return sharedState_yy.quoteName.call(this, id_str);
            };
          } else {
            this.quoteName = this.originalQuoteName;
          }
          this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
            var rv;
            if (invoke_post_methods) {
              var hash;
              if (sharedState_yy.post_parse || this.post_parse) {
                hash = this.constructParseErrorInfo(null, null, null, false);
              }
              if (sharedState_yy.post_parse) {
                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== "undefined")
                  resultValue = rv;
              }
              if (this.post_parse) {
                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
                if (typeof rv !== "undefined")
                  resultValue = rv;
              }
              if (hash && hash.destroy) {
                hash.destroy();
              }
            }
            if (this.__reentrant_call_depth > 1)
              return resultValue;
            if (lexer2.cleanupAfterLex) {
              lexer2.cleanupAfterLex(do_not_nuke_errorinfos);
            }
            if (sharedState_yy) {
              sharedState_yy.lexer = void 0;
              sharedState_yy.parser = void 0;
              if (lexer2.yy === sharedState_yy) {
                lexer2.yy = void 0;
              }
            }
            sharedState_yy = void 0;
            this.parseError = this.originalParseError;
            this.quoteName = this.originalQuoteName;
            stack.length = 0;
            sstack.length = 0;
            vstack.length = 0;
            sp = 0;
            if (!do_not_nuke_errorinfos) {
              for (var i2 = this.__error_infos.length - 1; i2 >= 0; i2--) {
                var el = this.__error_infos[i2];
                if (el && typeof el.destroy === "function") {
                  el.destroy();
                }
              }
              this.__error_infos.length = 0;
            }
            return resultValue;
          };
          this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected2, recoverable) {
            var pei = {
              errStr: msg,
              exception: ex,
              text: lexer2.match,
              value: lexer2.yytext,
              token: this.describeSymbol(symbol) || symbol,
              token_id: symbol,
              line: lexer2.yylineno,
              expected: expected2,
              recoverable,
              state,
              action,
              new_state: newState,
              symbol_stack: stack,
              state_stack: sstack,
              value_stack: vstack,
              stack_pointer: sp,
              yy: sharedState_yy,
              lexer: lexer2,
              parser: this,
              destroy: function destructParseErrorInfo() {
                var rec = !!this.recoverable;
                for (var key in this) {
                  if (this.hasOwnProperty(key) && typeof key === "object") {
                    this[key] = void 0;
                  }
                }
                this.recoverable = rec;
              }
            };
            this.__error_infos.push(pei);
            return pei;
          };
          function getNonTerminalFromCode(symbol2) {
            var tokenName = self2.getSymbolName(symbol2);
            if (!tokenName) {
              tokenName = symbol2;
            }
            return tokenName;
          }
          function stdLex() {
            var token = lexer2.lex();
            if (typeof token !== "number") {
              token = self2.symbols_[token] || token;
            }
            return token || EOF;
          }
          function fastLex() {
            var token = lexer2.fastLex();
            if (typeof token !== "number") {
              token = self2.symbols_[token] || token;
            }
            return token || EOF;
          }
          var lex = stdLex;
          var state, action, r2, t2;
          var yyval = {
            $: true,
            _$: void 0,
            yy: sharedState_yy
          };
          var p2;
          var yyrulelen;
          var this_production;
          var newState;
          var retval = false;
          try {
            this.__reentrant_call_depth++;
            lexer2.setInput(input, sharedState_yy);
            if (typeof lexer2.canIUse === "function") {
              var lexerInfo = lexer2.canIUse();
              if (lexerInfo.fastLex && typeof fastLex === "function") {
                lex = fastLex;
              }
            }
            vstack[sp] = null;
            sstack[sp] = 0;
            stack[sp] = 0;
            ++sp;
            if (this.pre_parse) {
              this.pre_parse.call(this, sharedState_yy);
            }
            if (sharedState_yy.pre_parse) {
              sharedState_yy.pre_parse.call(this, sharedState_yy);
            }
            newState = sstack[sp - 1];
            for (; ; ) {
              state = newState;
              if (this.defaultActions[state]) {
                action = 2;
                newState = this.defaultActions[state];
              } else {
                if (!symbol) {
                  symbol = lex();
                }
                t2 = table[state] && table[state][symbol] || NO_ACTION;
                newState = t2[1];
                action = t2[0];
                if (!action) {
                  var errStr;
                  var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                  var expected = this.collect_expected_token_set(state);
                  if (typeof lexer2.yylineno === "number") {
                    errStr = "Parse error on line " + (lexer2.yylineno + 1) + ": ";
                  } else {
                    errStr = "Parse error: ";
                  }
                  if (typeof lexer2.showPosition === "function") {
                    errStr += "\n" + lexer2.showPosition(79 - 10, 10) + "\n";
                  }
                  if (expected.length) {
                    errStr += "Expecting " + expected.join(", ") + ", got unexpected " + errSymbolDescr;
                  } else {
                    errStr += "Unexpected " + errSymbolDescr;
                  }
                  p2 = this.constructParseErrorInfo(errStr, null, expected, false);
                  r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                  if (typeof r2 !== "undefined") {
                    retval = r2;
                  }
                  break;
                }
              }
              switch (action) {
                default:
                  if (action instanceof Array) {
                    p2 = this.constructParseErrorInfo("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol, null, null, false);
                    r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                    if (typeof r2 !== "undefined") {
                      retval = r2;
                    }
                    break;
                  }
                  p2 = this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.", null, null, false);
                  r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                  if (typeof r2 !== "undefined") {
                    retval = r2;
                  }
                  break;
                case 1:
                  stack[sp] = symbol;
                  vstack[sp] = lexer2.yytext;
                  sstack[sp] = newState;
                  ++sp;
                  symbol = 0;
                  continue;
                case 2:
                  this_production = this.productions_[newState - 1];
                  yyrulelen = this_production[1];
                  r2 = this.performAction.call(yyval, newState, sp - 1, vstack);
                  if (typeof r2 !== "undefined") {
                    retval = r2;
                    break;
                  }
                  sp -= yyrulelen;
                  var ntsymbol = this_production[0];
                  stack[sp] = ntsymbol;
                  vstack[sp] = yyval.$;
                  newState = table[sstack[sp - 1]][ntsymbol];
                  sstack[sp] = newState;
                  ++sp;
                  continue;
                case 3:
                  if (sp !== -2) {
                    retval = true;
                    sp--;
                    if (typeof vstack[sp] !== "undefined") {
                      retval = vstack[sp];
                    }
                  }
                  break;
              }
              break;
            }
          } catch (ex) {
            if (ex instanceof this.JisonParserError) {
              throw ex;
            } else if (lexer2 && typeof lexer2.JisonLexerError === "function" && ex instanceof lexer2.JisonLexerError) {
              throw ex;
            }
            p2 = this.constructParseErrorInfo("Parsing aborted due to exception.", ex, null, false);
            retval = false;
            r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
            if (typeof r2 !== "undefined") {
              retval = r2;
            }
          } finally {
            retval = this.cleanupAfterParse(retval, true, true);
            this.__reentrant_call_depth--;
          }
          return retval;
        }
      };
      parser2.originalParseError = parser2.parseError;
      parser2.originalQuoteName = parser2.quoteName;
      var lexer = function() {
        function JisonLexerError(msg, hash) {
          Object.defineProperty(this, "name", {
            enumerable: false,
            writable: false,
            value: "JisonLexerError"
          });
          if (msg == null)
            msg = "???";
          Object.defineProperty(this, "message", {
            enumerable: false,
            writable: true,
            value: msg
          });
          this.hash = hash;
          var stacktrace;
          if (hash && hash.exception instanceof Error) {
            var ex2 = hash.exception;
            this.message = ex2.message || msg;
            stacktrace = ex2.stack;
          }
          if (!stacktrace) {
            if (Error.hasOwnProperty("captureStackTrace")) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              stacktrace = new Error(msg).stack;
            }
          }
          if (stacktrace) {
            Object.defineProperty(this, "stack", {
              enumerable: false,
              writable: false,
              value: stacktrace
            });
          }
        }
        if (typeof Object.setPrototypeOf === "function") {
          Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
        } else {
          JisonLexerError.prototype = Object.create(Error.prototype);
        }
        JisonLexerError.prototype.constructor = JisonLexerError;
        JisonLexerError.prototype.name = "JisonLexerError";
        var lexer2 = {
          EOF: 1,
          ERROR: 2,
          __currentRuleSet__: null,
          __error_infos: [],
          __decompressed: false,
          done: false,
          _backtrack: false,
          _input: "",
          _more: false,
          _signaled_error_token: false,
          conditionStack: [],
          match: "",
          matched: "",
          matches: false,
          yytext: "",
          offset: 0,
          yyleng: 0,
          yylineno: 0,
          yylloc: null,
          constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
            msg = "" + msg;
            if (show_input_position == void 0) {
              show_input_position = !(msg.indexOf("\n") > 0 && msg.indexOf("^") > 0);
            }
            if (this.yylloc && show_input_position) {
              if (typeof this.prettyPrintRange === "function") {
                var pretty_src = this.prettyPrintRange(this.yylloc);
                if (!/\n\s*$/.test(msg)) {
                  msg += "\n";
                }
                msg += "\n  Erroneous area:\n" + this.prettyPrintRange(this.yylloc);
              } else if (typeof this.showPosition === "function") {
                var pos_str = this.showPosition();
                if (pos_str) {
                  if (msg.length && msg[msg.length - 1] !== "\n" && pos_str[0] !== "\n") {
                    msg += "\n" + pos_str;
                  } else {
                    msg += pos_str;
                  }
                }
              }
            }
            var pei = {
              errStr: msg,
              recoverable: !!recoverable,
              text: this.match,
              token: null,
              line: this.yylineno,
              loc: this.yylloc,
              yy: this.yy,
              lexer: this,
              destroy: function destructLexErrorInfo() {
                var rec = !!this.recoverable;
                for (var key in this) {
                  if (this.hasOwnProperty(key) && typeof key === "object") {
                    this[key] = void 0;
                  }
                }
                this.recoverable = rec;
              }
            };
            this.__error_infos.push(pei);
            return pei;
          },
          parseError: function lexer_parseError(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
              ExceptionClass = this.JisonLexerError;
            }
            if (this.yy) {
              if (this.yy.parser && typeof this.yy.parser.parseError === "function") {
                return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
              } else if (typeof this.yy.parseError === "function") {
                return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
              }
            }
            throw new ExceptionClass(str, hash);
          },
          yyerror: function yyError(str) {
            var lineno_msg = "";
            if (this.yylloc) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p2 = this.constructLexErrorInfo(
              "Lexical error" + lineno_msg + ": " + str,
              this.options.lexerErrorsAreRecoverable
            );
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length) {
              p2.extra_error_attributes = args;
            }
            return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
          },
          cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
            this.setInput("", {});
            if (!do_not_nuke_errorinfos) {
              for (var i2 = this.__error_infos.length - 1; i2 >= 0; i2--) {
                var el = this.__error_infos[i2];
                if (el && typeof el.destroy === "function") {
                  el.destroy();
                }
              }
              this.__error_infos.length = 0;
            }
            return this;
          },
          clear: function lexer_clear() {
            this.yytext = "";
            this.yyleng = 0;
            this.match = "";
            this.matches = false;
            this._more = false;
            this._backtrack = false;
            var col = this.yylloc ? this.yylloc.last_column : 0;
            this.yylloc = {
              first_line: this.yylineno + 1,
              first_column: col,
              last_line: this.yylineno + 1,
              last_column: col,
              range: [this.offset, this.offset]
            };
          },
          setInput: function lexer_setInput(input, yy) {
            this.yy = yy || this.yy || {};
            if (!this.__decompressed) {
              var rules = this.rules;
              for (var i2 = 0, len = rules.length; i2 < len; i2++) {
                var rule_re = rules[i2];
                if (typeof rule_re === "number") {
                  rules[i2] = rules[rule_re];
                }
              }
              var conditions = this.conditions;
              for (var k2 in conditions) {
                var spec = conditions[k2];
                var rule_ids = spec.rules;
                var len = rule_ids.length;
                var rule_regexes = new Array(len + 1);
                var rule_new_ids = new Array(len + 1);
                for (var i2 = 0; i2 < len; i2++) {
                  var idx = rule_ids[i2];
                  var rule_re = rules[idx];
                  rule_regexes[i2 + 1] = rule_re;
                  rule_new_ids[i2 + 1] = idx;
                }
                spec.rules = rule_new_ids;
                spec.__rule_regexes = rule_regexes;
                spec.__rule_count = len;
              }
              this.__decompressed = true;
            }
            this._input = input || "";
            this.clear();
            this._signaled_error_token = false;
            this.done = false;
            this.yylineno = 0;
            this.matched = "";
            this.conditionStack = ["INITIAL"];
            this.__currentRuleSet__ = null;
            this.yylloc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0,
              range: [0, 0]
            };
            this.offset = 0;
            return this;
          },
          editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
            var rv = callback.call(this, this._input, cpsArg);
            if (typeof rv !== "string") {
              if (rv) {
                this._input = "" + rv;
              }
            } else {
              this._input = rv;
            }
            return this;
          },
          input: function lexer_input() {
            if (!this._input) {
              return null;
            }
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var slice_len = 1;
            var lines = false;
            if (ch === "\n") {
              lines = true;
            } else if (ch === "\r") {
              lines = true;
              var ch2 = this._input[1];
              if (ch2 === "\n") {
                slice_len++;
                ch += ch2;
                this.yytext += ch2;
                this.yyleng++;
                this.offset++;
                this.match += ch2;
                this.matched += ch2;
                this.yylloc.range[1]++;
              }
            }
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
              this.yylloc.last_column = 0;
            } else {
              this.yylloc.last_column++;
            }
            this.yylloc.range[1]++;
            this._input = this._input.slice(slice_len);
            return ch;
          },
          unput: function lexer_unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len);
            this.yyleng = this.yytext.length;
            this.offset -= len;
            this.match = this.match.substr(0, this.match.length - len);
            this.matched = this.matched.substr(0, this.matched.length - len);
            if (lines.length > 1) {
              this.yylineno -= lines.length - 1;
              this.yylloc.last_line = this.yylineno + 1;
              var pre = this.match;
              var pre_lines = pre.split(/(?:\r\n?|\n)/g);
              if (pre_lines.length === 1) {
                pre = this.matched;
                pre_lines = pre.split(/(?:\r\n?|\n)/g);
              }
              this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
            } else {
              this.yylloc.last_column -= len;
            }
            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
            this.done = false;
            return this;
          },
          more: function lexer_more() {
            this._more = true;
            return this;
          },
          reject: function lexer_reject() {
            if (this.options.backtrack_lexer) {
              this._backtrack = true;
            } else {
              var lineno_msg = "";
              if (this.yylloc) {
                lineno_msg = " on line " + (this.yylineno + 1);
              }
              var p2 = this.constructLexErrorInfo(
                "Lexical error" + lineno_msg + ": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).",
                false
              );
              this._signaled_error_token = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
            }
            return this;
          },
          less: function lexer_less(n2) {
            return this.unput(this.match.slice(n2));
          },
          pastInput: function lexer_pastInput(maxSize, maxLines) {
            var past = this.matched.substring(0, this.matched.length - this.match.length);
            if (maxSize < 0)
              maxSize = past.length;
            else if (!maxSize)
              maxSize = 20;
            if (maxLines < 0)
              maxLines = past.length;
            else if (!maxLines)
              maxLines = 1;
            past = past.substr(-maxSize * 2 - 2);
            var a2 = past.replace(/\r\n|\r/g, "\n").split("\n");
            a2 = a2.slice(-maxLines);
            past = a2.join("\n");
            if (past.length > maxSize) {
              past = "..." + past.substr(-maxSize);
            }
            return past;
          },
          upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
            var next = this.match;
            if (maxSize < 0)
              maxSize = next.length + this._input.length;
            else if (!maxSize)
              maxSize = 20;
            if (maxLines < 0)
              maxLines = maxSize;
            else if (!maxLines)
              maxLines = 1;
            if (next.length < maxSize * 2 + 2) {
              next += this._input.substring(0, maxSize * 2 + 2);
            }
            var a2 = next.replace(/\r\n|\r/g, "\n").split("\n");
            a2 = a2.slice(0, maxLines);
            next = a2.join("\n");
            if (next.length > maxSize) {
              next = next.substring(0, maxSize) + "...";
            }
            return next;
          },
          showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
            var pre = this.pastInput(maxPrefix).replace(/\s/g, " ");
            var c3 = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput(maxPostfix).replace(/\s/g, " ") + "\n" + c3 + "^";
          },
          deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
            var loc = {
              first_line: 1,
              first_column: 0,
              last_line: 1,
              last_column: 0,
              range: [0, 0]
            };
            if (actual) {
              loc.first_line = actual.first_line | 0;
              loc.last_line = actual.last_line | 0;
              loc.first_column = actual.first_column | 0;
              loc.last_column = actual.last_column | 0;
              if (actual.range) {
                loc.range[0] = actual.range[0] | 0;
                loc.range[1] = actual.range[1] | 0;
              }
            }
            if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
              if (loc.first_line <= 0 && preceding) {
                loc.first_line = preceding.last_line | 0;
                loc.first_column = preceding.last_column | 0;
                if (preceding.range) {
                  loc.range[0] = actual.range[1] | 0;
                }
              }
              if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
                loc.last_line = following.first_line | 0;
                loc.last_column = following.first_column | 0;
                if (following.range) {
                  loc.range[1] = actual.range[0] | 0;
                }
              }
              if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
                loc.first_line = current.first_line | 0;
                loc.first_column = current.first_column | 0;
                if (current.range) {
                  loc.range[0] = current.range[0] | 0;
                }
              }
              if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
                loc.last_line = current.last_line | 0;
                loc.last_column = current.last_column | 0;
                if (current.range) {
                  loc.range[1] = current.range[1] | 0;
                }
              }
            }
            if (loc.last_line <= 0) {
              if (loc.first_line <= 0) {
                loc.first_line = this.yylloc.first_line;
                loc.last_line = this.yylloc.last_line;
                loc.first_column = this.yylloc.first_column;
                loc.last_column = this.yylloc.last_column;
                loc.range[0] = this.yylloc.range[0];
                loc.range[1] = this.yylloc.range[1];
              } else {
                loc.last_line = this.yylloc.last_line;
                loc.last_column = this.yylloc.last_column;
                loc.range[1] = this.yylloc.range[1];
              }
            }
            if (loc.first_line <= 0) {
              loc.first_line = loc.last_line;
              loc.first_column = 0;
              loc.range[1] = loc.range[0];
            }
            if (loc.first_column < 0) {
              loc.first_column = 0;
            }
            if (loc.last_column < 0) {
              loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
            }
            return loc;
          },
          prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
            loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
            const CONTEXT = 3;
            const CONTEXT_TAIL = 1;
            const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
            var input = this.matched + this._input;
            var lines = input.split("\n");
            var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
            var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
            var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
            var ws_prefix = new Array(lineno_display_width).join(" ");
            var nonempty_line_indexes = [];
            var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
              var lno = index + l0;
              var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
              var rv2 = lno_pfx + ": " + line;
              var errpfx = new Array(lineno_display_width + 1).join("^");
              var offset = 2 + 1;
              var len = 0;
              if (lno === loc.first_line) {
                offset += loc.first_column;
                len = Math.max(
                  2,
                  (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1
                );
              } else if (lno === loc.last_line) {
                len = Math.max(2, loc.last_column + 1);
              } else if (lno > loc.first_line && lno < loc.last_line) {
                len = Math.max(2, line.length + 1);
              }
              if (len) {
                var lead = new Array(offset).join(".");
                var mark = new Array(len).join("^");
                rv2 += "\n" + errpfx + lead + mark;
                if (line.trim().length > 0) {
                  nonempty_line_indexes.push(index);
                }
              }
              rv2 = rv2.replace(/\t/g, " ");
              return rv2;
            });
            if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
              var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
              var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
              var intermediate_line = new Array(lineno_display_width + 1).join(" ") + "  (...continued...)";
              intermediate_line += "\n" + new Array(lineno_display_width + 1).join("-") + "  (---------------)";
              rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
            }
            return rv.join("\n");
          },
          describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
            var l1 = yylloc.first_line;
            var l2 = yylloc.last_line;
            var c1 = yylloc.first_column;
            var c22 = yylloc.last_column;
            var dl = l2 - l1;
            var dc = c22 - c1;
            var rv;
            if (dl === 0) {
              rv = "line " + l1 + ", ";
              if (dc <= 1) {
                rv += "column " + c1;
              } else {
                rv += "columns " + c1 + " .. " + c22;
              }
            } else {
              rv = "lines " + l1 + "(column " + c1 + ") .. " + l2 + "(column " + c22 + ")";
            }
            if (yylloc.range && display_range_too) {
              var r1 = yylloc.range[0];
              var r2 = yylloc.range[1] - 1;
              if (r2 <= r1) {
                rv += " {String Offset: " + r1 + "}";
              } else {
                rv += " {String Offset range: " + r1 + " .. " + r2 + "}";
              }
            }
            return rv;
          },
          test_match: function lexer_test_match(match, indexed_rule) {
            var token, lines, backup, match_str, match_str_len;
            if (this.options.backtrack_lexer) {
              backup = {
                yylineno: this.yylineno,
                yylloc: {
                  first_line: this.yylloc.first_line,
                  last_line: this.yylloc.last_line,
                  first_column: this.yylloc.first_column,
                  last_column: this.yylloc.last_column,
                  range: this.yylloc.range.slice(0)
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
              };
            }
            match_str = match[0];
            match_str_len = match_str.length;
            lines = match_str.split(/(?:\r\n?|\n)/g);
            if (lines.length > 1) {
              this.yylineno += lines.length - 1;
              this.yylloc.last_line = this.yylineno + 1;
              this.yylloc.last_column = lines[lines.length - 1].length;
            } else {
              this.yylloc.last_column += match_str_len;
            }
            this.yytext += match_str;
            this.match += match_str;
            this.matched += match_str;
            this.matches = match;
            this.yyleng = this.yytext.length;
            this.yylloc.range[1] += match_str_len;
            this.offset += match_str_len;
            this._more = false;
            this._backtrack = false;
            this._input = this._input.slice(match_str_len);
            token = this.performAction.call(
              this,
              this.yy,
              indexed_rule,
              this.conditionStack[this.conditionStack.length - 1]
            );
            if (this.done && this._input) {
              this.done = false;
            }
            if (token) {
              return token;
            } else if (this._backtrack) {
              for (var k2 in backup) {
                this[k2] = backup[k2];
              }
              this.__currentRuleSet__ = null;
              return false;
            } else if (this._signaled_error_token) {
              token = this._signaled_error_token;
              this._signaled_error_token = false;
              return token;
            }
            return false;
          },
          next: function lexer_next() {
            if (this.done) {
              this.clear();
              return this.EOF;
            }
            if (!this._input) {
              this.done = true;
            }
            var token, match, tempMatch, index;
            if (!this._more) {
              this.clear();
            }
            var spec = this.__currentRuleSet__;
            if (!spec) {
              spec = this.__currentRuleSet__ = this._currentRules();
              if (!spec || !spec.rules) {
                var lineno_msg = "";
                if (this.options.trackPosition) {
                  lineno_msg = " on line " + (this.yylineno + 1);
                }
                var p2 = this.constructLexErrorInfo(
                  "Internal lexer engine error" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
                  false
                );
                return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
              }
            }
            var rule_ids = spec.rules;
            var regexes = spec.__rule_regexes;
            var len = spec.__rule_count;
            for (var i2 = 1; i2 <= len; i2++) {
              tempMatch = this._input.match(regexes[i2]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i2;
                if (this.options.backtrack_lexer) {
                  token = this.test_match(tempMatch, rule_ids[i2]);
                  if (token !== false) {
                    return token;
                  } else if (this._backtrack) {
                    match = void 0;
                    continue;
                  } else {
                    return false;
                  }
                } else if (!this.options.flex) {
                  break;
                }
              }
            }
            if (match) {
              token = this.test_match(match, rule_ids[index]);
              if (token !== false) {
                return token;
              }
              return false;
            }
            if (!this._input) {
              this.done = true;
              this.clear();
              return this.EOF;
            } else {
              var lineno_msg = "";
              if (this.options.trackPosition) {
                lineno_msg = " on line " + (this.yylineno + 1);
              }
              var p2 = this.constructLexErrorInfo(
                "Lexical error" + lineno_msg + ": Unrecognized text.",
                this.options.lexerErrorsAreRecoverable
              );
              var pendingInput = this._input;
              var activeCondition = this.topState();
              var conditionStackDepth = this.conditionStack.length;
              token = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
              if (token === this.ERROR) {
                if (!this.matches && pendingInput === this._input && activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                  this.input();
                }
              }
              return token;
            }
          },
          lex: function lexer_lex() {
            var r2;
            if (typeof this.pre_lex === "function") {
              r2 = this.pre_lex.call(this, 0);
            }
            if (typeof this.options.pre_lex === "function") {
              r2 = this.options.pre_lex.call(this, r2) || r2;
            }
            if (this.yy && typeof this.yy.pre_lex === "function") {
              r2 = this.yy.pre_lex.call(this, r2) || r2;
            }
            while (!r2) {
              r2 = this.next();
            }
            if (this.yy && typeof this.yy.post_lex === "function") {
              r2 = this.yy.post_lex.call(this, r2) || r2;
            }
            if (typeof this.options.post_lex === "function") {
              r2 = this.options.post_lex.call(this, r2) || r2;
            }
            if (typeof this.post_lex === "function") {
              r2 = this.post_lex.call(this, r2) || r2;
            }
            return r2;
          },
          fastLex: function lexer_fastLex() {
            var r2;
            while (!r2) {
              r2 = this.next();
            }
            return r2;
          },
          canIUse: function lexer_canIUse() {
            var rv = {
              fastLex: !(typeof this.pre_lex === "function" || typeof this.options.pre_lex === "function" || this.yy && typeof this.yy.pre_lex === "function" || this.yy && typeof this.yy.post_lex === "function" || typeof this.options.post_lex === "function" || typeof this.post_lex === "function") && typeof this.fastLex === "function"
            };
            return rv;
          },
          begin: function lexer_begin(condition) {
            return this.pushState(condition);
          },
          pushState: function lexer_pushState(condition) {
            this.conditionStack.push(condition);
            this.__currentRuleSet__ = null;
            return this;
          },
          popState: function lexer_popState() {
            var n2 = this.conditionStack.length - 1;
            if (n2 > 0) {
              this.__currentRuleSet__ = null;
              return this.conditionStack.pop();
            } else {
              return this.conditionStack[0];
            }
          },
          topState: function lexer_topState(n2) {
            n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
            if (n2 >= 0) {
              return this.conditionStack[n2];
            } else {
              return "INITIAL";
            }
          },
          _currentRules: function lexer__currentRules() {
            if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
            } else {
              return this.conditions["INITIAL"];
            }
          },
          stateStackSize: function lexer_stateStackSize() {
            return this.conditionStack.length;
          },
          options: {
            trackPosition: true,
            caseInsensitive: true
          },
          JisonLexerError,
          performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
            var yy_ = this;
            var YYSTATE = YY_START;
            switch (yyrulenumber) {
              case 0:
                break;
              default:
                return this.simpleCaseActionClusters[yyrulenumber];
            }
          },
          simpleCaseActionClusters: {
            1: 3,
            2: 10,
            3: 8,
            4: 9,
            5: 6,
            6: 7,
            7: 17,
            8: 18,
            9: 19,
            10: 20,
            11: 22,
            12: 21,
            13: 23,
            14: 24,
            15: 11,
            16: 11,
            17: 11,
            18: 11,
            19: 11,
            20: 11,
            21: 11,
            22: 12,
            23: 12,
            24: 12,
            25: 12,
            26: 13,
            27: 13,
            28: 14,
            29: 14,
            30: 15,
            31: 15,
            32: 15,
            33: 25,
            34: 26,
            35: 16,
            36: 4,
            37: 5,
            38: 1
          },
          rules: [
            /^(?:\s+)/i,
            /^(?:(-(webkit|moz)-)?calc\b)/i,
            /^(?:[a-z][\d\-a-z]*\s*\((?:(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*')|\([^)]*\)|[^()]*)*\))/i,
            /^(?:\*)/i,
            /^(?:\/)/i,
            /^(?:\+)/i,
            /^(?:-)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)em\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ex\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ch\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rem\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vw\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vh\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmin\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)vmax\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)cm\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)mm\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Q\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)in\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pt\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)pc\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)px\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)deg\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)grad\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)rad\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)turn\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)s\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)ms\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)Hz\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)kHz\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpi\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dpcm\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)dppx\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)%)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)\b)/i,
            /^(?:((\d+(\.\d+)?|\.\d+)(e(\+|-)\d+)?)-?([^\W\d]|[ -ÿ]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))([\w\-]|[ -ÿ]|(\\[\dA-Fa-f]{1,6}(\r\n|[\t\n\f\r ])?|\\[^\d\n\f\rA-Fa-f]))*\b)/i,
            /^(?:\()/i,
            /^(?:\))/i,
            /^(?:$)/i
          ],
          conditions: {
            "INITIAL": {
              rules: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38
              ],
              inclusive: true
            }
          }
        };
        return lexer2;
      }();
      parser2.lexer = lexer;
      function Parser() {
        this.yy = {};
      }
      Parser.prototype = parser2;
      parser2.Parser = Parser;
      return new Parser();
    }();
    if (typeof __require !== "undefined" && typeof exports !== "undefined") {
      exports.parser = parser;
      exports.Parser = parser.Parser;
      exports.parse = function() {
        return parser.parse.apply(parser, arguments);
      };
    }
  }
});

// node_modules/postcss-calc/src/lib/convertUnit.js
var require_convertUnit = __commonJS({
  "node_modules/postcss-calc/src/lib/convertUnit.js"(exports, module) {
    "use strict";
    var conversions = {
      px: {
        px: 1,
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        q: 96 / 101.6,
        in: 96,
        pt: 96 / 72,
        pc: 16
      },
      cm: {
        px: 2.54 / 96,
        cm: 1,
        mm: 0.1,
        q: 0.025,
        in: 2.54,
        pt: 2.54 / 72,
        pc: 2.54 / 6
      },
      mm: {
        px: 25.4 / 96,
        cm: 10,
        mm: 1,
        q: 0.25,
        in: 25.4,
        pt: 25.4 / 72,
        pc: 25.4 / 6
      },
      q: {
        px: 101.6 / 96,
        cm: 40,
        mm: 4,
        q: 1,
        in: 101.6,
        pt: 101.6 / 72,
        pc: 101.6 / 6
      },
      in: {
        px: 1 / 96,
        cm: 1 / 2.54,
        mm: 1 / 25.4,
        q: 1 / 101.6,
        in: 1,
        pt: 1 / 72,
        pc: 1 / 6
      },
      pt: {
        px: 0.75,
        cm: 72 / 2.54,
        mm: 72 / 25.4,
        q: 72 / 101.6,
        in: 72,
        pt: 1,
        pc: 12
      },
      pc: {
        px: 0.0625,
        cm: 6 / 2.54,
        mm: 6 / 25.4,
        q: 6 / 101.6,
        in: 6,
        pt: 6 / 72,
        pc: 1
      },
      deg: {
        deg: 1,
        grad: 0.9,
        rad: 180 / Math.PI,
        turn: 360
      },
      grad: {
        deg: 400 / 360,
        grad: 1,
        rad: 200 / Math.PI,
        turn: 400
      },
      rad: {
        deg: Math.PI / 180,
        grad: Math.PI / 200,
        rad: 1,
        turn: Math.PI * 2
      },
      turn: {
        deg: 1 / 360,
        grad: 25e-4,
        rad: 0.5 / Math.PI,
        turn: 1
      },
      s: {
        s: 1,
        ms: 1e-3
      },
      ms: {
        s: 1e3,
        ms: 1
      },
      hz: {
        hz: 1,
        khz: 1e3
      },
      khz: {
        hz: 1e-3,
        khz: 1
      },
      dpi: {
        dpi: 1,
        dpcm: 1 / 2.54,
        dppx: 1 / 96
      },
      dpcm: {
        dpi: 2.54,
        dpcm: 1,
        dppx: 2.54 / 96
      },
      dppx: {
        dpi: 96,
        dpcm: 96 / 2.54,
        dppx: 1
      }
    };
    function convertUnit(value, sourceUnit, targetUnit, precision) {
      const sourceUnitNormalized = sourceUnit.toLowerCase();
      const targetUnitNormalized = targetUnit.toLowerCase();
      if (!conversions[targetUnitNormalized]) {
        throw new Error("Cannot convert to " + targetUnit);
      }
      if (!conversions[targetUnitNormalized][sourceUnitNormalized]) {
        throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
      }
      const converted = conversions[targetUnitNormalized][sourceUnitNormalized] * value;
      if (precision !== false) {
        precision = Math.pow(10, Math.ceil(precision) || 5);
        return Math.round(converted * precision) / precision;
      }
      return converted;
    }
    module.exports = convertUnit;
  }
});

// node_modules/postcss-calc/src/lib/reducer.js
var require_reducer = __commonJS({
  "node_modules/postcss-calc/src/lib/reducer.js"(exports, module) {
    "use strict";
    var convertUnit = require_convertUnit();
    function isValueType(node) {
      switch (node.type) {
        case "LengthValue":
        case "AngleValue":
        case "TimeValue":
        case "FrequencyValue":
        case "ResolutionValue":
        case "EmValue":
        case "ExValue":
        case "ChValue":
        case "RemValue":
        case "VhValue":
        case "VwValue":
        case "VminValue":
        case "VmaxValue":
        case "PercentageValue":
        case "Number":
          return true;
      }
      return false;
    }
    function flip(operator) {
      return operator === "+" ? "-" : "+";
    }
    function isAddSubOperator(operator) {
      return operator === "+" || operator === "-";
    }
    function collectAddSubItems(preOperator, node, collected, precision) {
      if (!isAddSubOperator(preOperator)) {
        throw new Error(`invalid operator ${preOperator}`);
      }
      if (isValueType(node)) {
        const itemIndex = collected.findIndex((x2) => x2.node.type === node.type);
        if (itemIndex >= 0) {
          if (node.value === 0) {
            return;
          }
          const otherValueNode = collected[itemIndex].node;
          const { left: reducedNode, right: current } = convertNodesUnits(
            otherValueNode,
            node,
            precision
          );
          if (collected[itemIndex].preOperator === "-") {
            collected[itemIndex].preOperator = "+";
            reducedNode.value *= -1;
          }
          if (preOperator === "+") {
            reducedNode.value += current.value;
          } else {
            reducedNode.value -= current.value;
          }
          if (reducedNode.value >= 0) {
            collected[itemIndex] = { node: reducedNode, preOperator: "+" };
          } else {
            reducedNode.value *= -1;
            collected[itemIndex] = { node: reducedNode, preOperator: "-" };
          }
        } else {
          if (node.value >= 0) {
            collected.push({ node, preOperator });
          } else {
            node.value *= -1;
            collected.push({ node, preOperator: flip(preOperator) });
          }
        }
      } else if (node.type === "MathExpression") {
        if (isAddSubOperator(node.operator)) {
          collectAddSubItems(preOperator, node.left, collected, precision);
          const collectRightOperator = preOperator === "-" ? flip(node.operator) : node.operator;
          collectAddSubItems(
            collectRightOperator,
            node.right,
            collected,
            precision
          );
        } else {
          const reducedNode = reduce(node, precision);
          if (reducedNode.type !== "MathExpression" || isAddSubOperator(reducedNode.operator)) {
            collectAddSubItems(preOperator, reducedNode, collected, precision);
          } else {
            collected.push({ node: reducedNode, preOperator });
          }
        }
      } else if (node.type === "ParenthesizedExpression") {
        collectAddSubItems(preOperator, node.content, collected, precision);
      } else {
        collected.push({ node, preOperator });
      }
    }
    function reduceAddSubExpression(node, precision) {
      const collected = [];
      collectAddSubItems("+", node, collected, precision);
      const withoutZeroItem = collected.filter(
        (item) => !(isValueType(item.node) && item.node.value === 0)
      );
      const firstNonZeroItem = withoutZeroItem[0];
      if (!firstNonZeroItem || firstNonZeroItem.preOperator === "-" && !isValueType(firstNonZeroItem.node)) {
        const firstZeroItem = collected.find(
          (item) => isValueType(item.node) && item.node.value === 0
        );
        if (firstZeroItem) {
          withoutZeroItem.unshift(firstZeroItem);
        }
      }
      if (withoutZeroItem[0].preOperator === "-" && isValueType(withoutZeroItem[0].node)) {
        withoutZeroItem[0].node.value *= -1;
        withoutZeroItem[0].preOperator = "+";
      }
      let root = withoutZeroItem[0].node;
      for (let i2 = 1; i2 < withoutZeroItem.length; i2++) {
        root = {
          type: "MathExpression",
          operator: withoutZeroItem[i2].preOperator,
          left: root,
          right: withoutZeroItem[i2].node
        };
      }
      return root;
    }
    function reduceDivisionExpression(node) {
      if (!isValueType(node.right)) {
        return node;
      }
      if (node.right.type !== "Number") {
        throw new Error(`Cannot divide by "${node.right.unit}", number expected`);
      }
      return applyNumberDivision(node.left, node.right.value);
    }
    function applyNumberDivision(node, divisor) {
      if (divisor === 0) {
        throw new Error("Cannot divide by zero");
      }
      if (isValueType(node)) {
        node.value /= divisor;
        return node;
      }
      if (node.type === "MathExpression" && isAddSubOperator(node.operator)) {
        return {
          type: "MathExpression",
          operator: node.operator,
          left: applyNumberDivision(node.left, divisor),
          right: applyNumberDivision(node.right, divisor)
        };
      }
      return {
        type: "MathExpression",
        operator: "/",
        left: node,
        right: {
          type: "Number",
          value: divisor
        }
      };
    }
    function reduceMultiplicationExpression(node) {
      if (node.right.type === "Number") {
        return applyNumberMultiplication(node.left, node.right.value);
      }
      if (node.left.type === "Number") {
        return applyNumberMultiplication(node.right, node.left.value);
      }
      return node;
    }
    function applyNumberMultiplication(node, multiplier) {
      if (isValueType(node)) {
        node.value *= multiplier;
        return node;
      }
      if (node.type === "MathExpression" && isAddSubOperator(node.operator)) {
        return {
          type: "MathExpression",
          operator: node.operator,
          left: applyNumberMultiplication(node.left, multiplier),
          right: applyNumberMultiplication(node.right, multiplier)
        };
      }
      return {
        type: "MathExpression",
        operator: "*",
        left: node,
        right: {
          type: "Number",
          value: multiplier
        }
      };
    }
    function convertNodesUnits(left, right, precision) {
      switch (left.type) {
        case "LengthValue":
        case "AngleValue":
        case "TimeValue":
        case "FrequencyValue":
        case "ResolutionValue":
          if (right.type === left.type && right.unit && left.unit) {
            const converted = convertUnit(
              right.value,
              right.unit,
              left.unit,
              precision
            );
            right = {
              type: left.type,
              value: converted,
              unit: left.unit
            };
          }
          return { left, right };
        default:
          return { left, right };
      }
    }
    function includesNoCssProperties(node) {
      return node.content.type !== "Function" && (node.content.type !== "MathExpression" || node.content.right.type !== "Function" && node.content.left.type !== "Function");
    }
    function reduce(node, precision) {
      if (node.type === "MathExpression") {
        if (isAddSubOperator(node.operator)) {
          return reduceAddSubExpression(node, precision);
        }
        node.left = reduce(node.left, precision);
        node.right = reduce(node.right, precision);
        switch (node.operator) {
          case "/":
            return reduceDivisionExpression(node);
          case "*":
            return reduceMultiplicationExpression(node);
        }
        return node;
      }
      if (node.type === "ParenthesizedExpression") {
        if (includesNoCssProperties(node)) {
          return reduce(node.content, precision);
        }
      }
      return node;
    }
    module.exports = reduce;
  }
});

// node_modules/postcss-calc/src/lib/stringifier.js
var require_stringifier2 = __commonJS({
  "node_modules/postcss-calc/src/lib/stringifier.js"(exports, module) {
    "use strict";
    var order = {
      "*": 0,
      "/": 0,
      "+": 1,
      "-": 1
    };
    function round(value, prec) {
      if (prec !== false) {
        const precision = Math.pow(10, prec);
        return Math.round(value * precision) / precision;
      }
      return value;
    }
    function stringify17(node, prec) {
      switch (node.type) {
        case "MathExpression": {
          const { left, right, operator: op } = node;
          let str = "";
          if (left.type === "MathExpression" && order[op] < order[left.operator]) {
            str += `(${stringify17(left, prec)})`;
          } else {
            str += stringify17(left, prec);
          }
          str += order[op] ? ` ${node.operator} ` : node.operator;
          if (right.type === "MathExpression" && order[op] < order[right.operator]) {
            str += `(${stringify17(right, prec)})`;
          } else {
            str += stringify17(right, prec);
          }
          return str;
        }
        case "Number":
          return round(node.value, prec).toString();
        case "Function":
          return node.value.toString();
        case "ParenthesizedExpression":
          return `(${stringify17(node.content, prec)})`;
        default:
          return round(node.value, prec) + node.unit;
      }
    }
    module.exports = function(calc, node, originalValue, options, result, item) {
      let str = stringify17(node, options.precision);
      const shouldPrintCalc = node.type === "MathExpression" || node.type === "Function";
      if (shouldPrintCalc) {
        str = `${calc}(${str})`;
        if (options.warnWhenCannotResolve) {
          result.warn("Could not reduce expression: " + originalValue, {
            plugin: "postcss-calc",
            node: item
          });
        }
      }
      return str;
    };
  }
});

// node_modules/postcss-calc/src/lib/transform.js
var require_transform = __commonJS({
  "node_modules/postcss-calc/src/lib/transform.js"(exports, module) {
    "use strict";
    var selectorParser = require_dist3();
    var valueParser = require_lib();
    var { parser } = require_parser4();
    var reducer = require_reducer();
    var stringifier = require_stringifier2();
    var MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;
    function transformValue(value, options, result, item) {
      return valueParser(value).walk((node) => {
        if (node.type !== "function" || !MATCH_CALC.test(node.value)) {
          return;
        }
        const contents = valueParser.stringify(node.nodes);
        const ast = parser.parse(contents);
        const reducedAst = reducer(ast, options.precision);
        node.type = "word";
        node.value = stringifier(
          node.value,
          reducedAst,
          value,
          options,
          result,
          item
        );
        return false;
      }).toString();
    }
    function transformSelector(value, options, result, item) {
      return selectorParser((selectors) => {
        selectors.walk((node) => {
          if (node.type === "attribute" && node.value) {
            node.setValue(transformValue(node.value, options, result, item));
          }
          if (node.type === "tag") {
            node.value = transformValue(node.value, options, result, item);
          }
          return;
        });
      }).processSync(value);
    }
    module.exports = (node, property, options, result) => {
      let value = node[property];
      try {
        value = property === "selector" ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node);
      } catch (error) {
        if (error instanceof Error) {
          result.warn(error.message, { node });
        } else {
          result.warn("Error", { node });
        }
        return;
      }
      if (options.preserve && node[property] !== value) {
        const clone = node.clone();
        clone[property] = value;
        node.parent.insertBefore(node, clone);
      } else {
        node[property] = value;
      }
    };
  }
});

// node_modules/postcss-calc/src/index.js
var require_src8 = __commonJS({
  "node_modules/postcss-calc/src/index.js"(exports, module) {
    "use strict";
    var transform = require_transform();
    function pluginCreator(opts) {
      const options = Object.assign(
        {
          precision: 5,
          preserve: false,
          warnWhenCannotResolve: false,
          mediaQueries: false,
          selectors: false
        },
        opts
      );
      return {
        postcssPlugin: "postcss-calc",
        OnceExit(css, { result }) {
          css.walk((node) => {
            const { type } = node;
            if (type === "decl") {
              transform(node, "value", options, result);
            }
            if (type === "atrule" && options.mediaQueries) {
              transform(node, "params", options, result);
            }
            if (type === "rule" && options.selectors) {
              transform(node, "selector", options, result);
            }
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/colord/plugins/minify.mjs
var minify_exports = {};
__export(minify_exports, {
  default: () => minify_default
});
function minify_default(t2) {
  var r2 = function(t3) {
    var r3, n3, e2, a2 = t3.toHex(), i2 = t3.alpha(), h2 = a2.split(""), s2 = h2[1], o2 = h2[2], u2 = h2[3], l2 = h2[4], p2 = h2[5], f2 = h2[6], g2 = h2[7], v2 = h2[8];
    if (i2 > 0 && i2 < 1 && (r3 = parseInt(g2 + v2, 16) / 255, void 0 === (n3 = 2) && (n3 = 0), void 0 === e2 && (e2 = Math.pow(10, n3)), Math.round(e2 * r3) / e2 + 0 !== i2))
      return null;
    if (s2 === o2 && u2 === l2 && p2 === f2) {
      if (1 === i2)
        return "#" + s2 + u2 + p2;
      if (g2 === v2)
        return "#" + s2 + u2 + p2 + g2;
    }
    return a2;
  }, n2 = function(t3) {
    return t3 > 0 && t3 < 1 ? t3.toString().replace("0.", ".") : t3;
  };
  t2.prototype.minify = function(t3) {
    void 0 === t3 && (t3 = {});
    var e2 = this.toRgb(), a2 = n2(e2.r), i2 = n2(e2.g), h2 = n2(e2.b), s2 = this.toHsl(), o2 = n2(s2.h), u2 = n2(s2.s), l2 = n2(s2.l), p2 = n2(this.alpha()), f2 = Object.assign({ hex: true, rgb: true, hsl: true }, t3), g2 = [];
    if (f2.hex && (1 === p2 || f2.alphaHex)) {
      var v2 = r2(this);
      v2 && g2.push(v2);
    }
    if (f2.rgb && g2.push(1 === p2 ? "rgb(" + a2 + "," + i2 + "," + h2 + ")" : "rgba(" + a2 + "," + i2 + "," + h2 + "," + p2 + ")"), f2.hsl && g2.push(1 === p2 ? "hsl(" + o2 + "," + u2 + "%," + l2 + "%)" : "hsla(" + o2 + "," + u2 + "%," + l2 + "%," + p2 + ")"), f2.transparent && 0 === a2 && 0 === i2 && 0 === h2 && 0 === p2)
      g2.push("transparent");
    else if (1 === p2 && f2.name && "function" == typeof this.toName) {
      var c2 = this.toName();
      c2 && g2.push(c2);
    }
    return function(t4) {
      for (var r3 = t4[0], n3 = 1; n3 < t4.length; n3++)
        t4[n3].length < r3.length && (r3 = t4[n3]);
      return r3;
    }(g2);
  };
}
var init_minify = __esm({
  "node_modules/colord/plugins/minify.mjs"() {
  }
});

// node_modules/postcss-colormin/src/minifyColor.js
var require_minifyColor = __commonJS({
  "node_modules/postcss-colormin/src/minifyColor.js"(exports, module) {
    "use strict";
    var { colord, extend } = (init_colord(), __toCommonJS(colord_exports));
    var namesPlugin = (init_names(), __toCommonJS(names_exports));
    var minifierPlugin = (init_minify(), __toCommonJS(minify_exports));
    extend([namesPlugin, minifierPlugin]);
    module.exports = function minifyColor(input, options = {}) {
      const instance = colord(input);
      if (instance.isValid()) {
        const minified = instance.minify(options);
        return minified.length < input.length ? minified : input.toLowerCase();
      } else {
        return input;
      }
    };
  }
});

// node_modules/postcss-colormin/src/index.js
var require_src9 = __commonJS({
  "node_modules/postcss-colormin/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var { isSupported } = require_dist2();
    var valueParser = require_lib();
    var minifyColor = require_minifyColor();
    function walk(parent, callback) {
      parent.nodes.forEach((node, index) => {
        const bubble = callback(node, index, parent);
        if (node.type === "function" && bubble !== false) {
          walk(node, callback);
        }
      });
    }
    var browsersWithTransparentBug = /* @__PURE__ */ new Set(["ie 8", "ie 9"]);
    var mathFunctions = /* @__PURE__ */ new Set(["calc", "min", "max", "clamp"]);
    function isMathFunctionNode(node) {
      if (node.type !== "function") {
        return false;
      }
      return mathFunctions.has(node.value.toLowerCase());
    }
    function transform(value, options) {
      const parsed = valueParser(value);
      walk(parsed, (node, index, parent) => {
        if (node.type === "function") {
          if (/^(rgb|hsl)a?$/i.test(node.value)) {
            const { value: originalValue } = node;
            node.value = minifyColor(valueParser.stringify(node), options);
            node.type = "word";
            const next = parent.nodes[index + 1];
            if (node.value !== originalValue && next && (next.type === "word" || next.type === "function")) {
              parent.nodes.splice(
                index + 1,
                0,
                {
                  type: "space",
                  value: " "
                }
              );
            }
          } else if (isMathFunctionNode(node)) {
            return false;
          }
        } else if (node.type === "word") {
          node.value = minifyColor(node.value, options);
        }
      });
      return parsed.toString();
    }
    function addPluginDefaults(options, browsers) {
      const defaults = {
        transparent: browsers.some((b2) => browsersWithTransparentBug.has(b2)) === false,
        alphaHex: isSupported("css-rrggbbaa", browsers),
        name: true
      };
      return { ...defaults, ...options };
    }
    function pluginCreator(config = {}) {
      return {
        postcssPlugin: "postcss-colormin",
        prepare(result) {
          const resultOptions = result.opts || {};
          const browsers = browserslist(null, {
            stats: resultOptions.stats,
            path: __dirname,
            env: resultOptions.env
          });
          const cache = /* @__PURE__ */ new Map();
          const options = addPluginDefaults(config, browsers);
          return {
            OnceExit(css) {
              css.walkDecls((decl) => {
                if (/^(composes|font|filter|-webkit-tap-highlight-color)/i.test(
                  decl.prop
                )) {
                  return;
                }
                const value = decl.value;
                if (!value) {
                  return;
                }
                const cacheKey = JSON.stringify({ value, options, browsers });
                if (cache.has(cacheKey)) {
                  decl.value = cache.get(cacheKey);
                  return;
                }
                const newValue = transform(value, options);
                decl.value = newValue;
                cache.set(cacheKey, newValue);
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-ordered-values/src/lib/joinGridValue.js
var require_joinGridValue = __commonJS({
  "node_modules/postcss-ordered-values/src/lib/joinGridValue.js"(exports, module) {
    "use strict";
    module.exports = function joinGridVal(grid) {
      return grid.join(" / ").trim();
    };
  }
});

// node_modules/postcss-ordered-values/src/rules/grid.js
var require_grid = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/grid.js"(exports, module) {
    "use strict";
    var joinGridValue = require_joinGridValue();
    var normalizeGridAutoFlow = (gridAutoFlow) => {
      let newValue = { front: "", back: "" };
      let shouldNormalize = false;
      gridAutoFlow.walk((node) => {
        if (node.value === "dense") {
          shouldNormalize = true;
          newValue.back = node.value;
        } else if (["row", "column"].includes(node.value.trim().toLowerCase())) {
          shouldNormalize = true;
          newValue.front = node.value;
        } else {
          shouldNormalize = false;
        }
      });
      if (shouldNormalize) {
        return `${newValue.front.trim()} ${newValue.back.trim()}`;
      }
      return gridAutoFlow;
    };
    var normalizeGridColumnRowGap = (gridGap) => {
      let newValue = { front: "", back: "" };
      let shouldNormalize = false;
      gridGap.walk((node) => {
        if (node.value === "normal") {
          shouldNormalize = true;
          newValue.front = node.value;
        } else {
          newValue.back = `${newValue.back} ${node.value}`;
        }
      });
      if (shouldNormalize) {
        return `${newValue.front.trim()} ${newValue.back.trim()}`;
      }
      return gridGap;
    };
    var normalizeGridColumnRow = (grid) => {
      let gridValue = grid.toString().split("/");
      if (gridValue.length > 1) {
        return joinGridValue(
          gridValue.map((gridLine) => {
            let normalizeValue = {
              front: "",
              back: ""
            };
            gridLine = gridLine.trim();
            gridLine.split(" ").forEach((node) => {
              if (node === "span") {
                normalizeValue.front = node;
              } else {
                normalizeValue.back = `${normalizeValue.back} ${node}`;
              }
            });
            return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;
          })
        );
      }
      return gridValue.map((gridLine) => {
        let normalizeValue = {
          front: "",
          back: ""
        };
        gridLine = gridLine.trim();
        gridLine.split(" ").forEach((node) => {
          if (node === "span") {
            normalizeValue.front = node;
          } else {
            normalizeValue.back = `${normalizeValue.back} ${node}`;
          }
        });
        return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;
      });
    };
    module.exports = {
      normalizeGridAutoFlow,
      normalizeGridColumnRowGap,
      normalizeGridColumnRow
    };
  }
});

// node_modules/postcss-ordered-values/src/lib/addSpace.js
var require_addSpace = __commonJS({
  "node_modules/postcss-ordered-values/src/lib/addSpace.js"(exports, module) {
    "use strict";
    module.exports = function addSpace() {
      return {
        type: "space",
        value: " "
      };
    };
  }
});

// node_modules/postcss-ordered-values/src/lib/getValue.js
var require_getValue = __commonJS({
  "node_modules/postcss-ordered-values/src/lib/getValue.js"(exports, module) {
    "use strict";
    var { stringify: stringify17 } = require_lib();
    module.exports = function getValue(values) {
      return stringify17(flatten(values));
    };
    function flatten(values) {
      const nodes = [];
      for (const [index, arg] of values.entries()) {
        arg.forEach((val, idx) => {
          if (idx === arg.length - 1 && index === values.length - 1 && val.type === "space") {
            return;
          }
          nodes.push(val);
        });
        if (index !== values.length - 1) {
          nodes[nodes.length - 1].type = "div";
          nodes[nodes.length - 1].value = ",";
        }
      }
      return nodes;
    }
  }
});

// node_modules/postcss-ordered-values/src/rules/animation.js
var require_animation = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/animation.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    var { getArguments } = require_src3();
    var addSpace = require_addSpace();
    var getValue = require_getValue();
    var functions = /* @__PURE__ */ new Set(["steps", "cubic-bezier", "frames"]);
    var keywords = /* @__PURE__ */ new Set([
      "ease",
      "ease-in",
      "ease-in-out",
      "ease-out",
      "linear",
      "step-end",
      "step-start"
    ]);
    var directions = /* @__PURE__ */ new Set([
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]);
    var fillModes = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
    var playStates = /* @__PURE__ */ new Set(["running", "paused"]);
    var timeUnits = /* @__PURE__ */ new Set(["ms", "s"]);
    var isTimingFunction = (value, type) => {
      return type === "function" && functions.has(value) || keywords.has(value);
    };
    var isDirection = (value) => {
      return directions.has(value);
    };
    var isFillMode = (value) => {
      return fillModes.has(value);
    };
    var isPlayState = (value) => {
      return playStates.has(value);
    };
    var isTime = (value) => {
      const quantity = unit(value);
      return quantity && timeUnits.has(quantity.unit);
    };
    var isIterationCount = (value) => {
      const quantity = unit(value);
      return value === "infinite" || quantity && !quantity.unit;
    };
    var stateConditions = [
      { property: "duration", delegate: isTime },
      { property: "timingFunction", delegate: isTimingFunction },
      { property: "delay", delegate: isTime },
      { property: "iterationCount", delegate: isIterationCount },
      { property: "direction", delegate: isDirection },
      { property: "fillMode", delegate: isFillMode },
      { property: "playState", delegate: isPlayState }
    ];
    function normalize(args) {
      const list = [];
      for (const arg of args) {
        const state = {
          name: [],
          duration: [],
          timingFunction: [],
          delay: [],
          iterationCount: [],
          direction: [],
          fillMode: [],
          playState: []
        };
        arg.forEach((node) => {
          let { type, value } = node;
          if (type === "space") {
            return;
          }
          value = value.toLowerCase();
          const hasMatch = stateConditions.some(({ property, delegate }) => {
            if (delegate(value, type) && !state[property].length) {
              state[property] = [node, addSpace()];
              return true;
            }
          });
          if (!hasMatch) {
            state.name = [...state.name, node, addSpace()];
          }
        });
        list.push([
          ...state.name,
          ...state.duration,
          ...state.timingFunction,
          ...state.delay,
          ...state.iterationCount,
          ...state.direction,
          ...state.fillMode,
          ...state.playState
        ]);
      }
      return list;
    }
    module.exports = function normalizeAnimation(parsed) {
      const values = normalize(getArguments(parsed));
      return getValue(values);
    };
  }
});

// node_modules/postcss-ordered-values/src/lib/mathfunctions.js
var require_mathfunctions = __commonJS({
  "node_modules/postcss-ordered-values/src/lib/mathfunctions.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Set(["calc", "clamp", "max", "min"]);
  }
});

// node_modules/postcss-ordered-values/src/rules/border.js
var require_border2 = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/border.js"(exports, module) {
    "use strict";
    var { unit, stringify: stringify17 } = require_lib();
    var mathFunctions = require_mathfunctions();
    var borderWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
    var borderStyles = /* @__PURE__ */ new Set([
      "none",
      "auto",
      "hidden",
      "dotted",
      "dashed",
      "solid",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset"
    ]);
    module.exports = function normalizeBorder(border) {
      const order = { width: "", style: "", color: "" };
      border.walk((node) => {
        const { type, value } = node;
        if (type === "word") {
          if (borderStyles.has(value.toLowerCase())) {
            order.style = value;
            return false;
          }
          if (borderWidths.has(value.toLowerCase()) || unit(value.toLowerCase())) {
            if (order.width !== "") {
              order.width = `${order.width} ${value}`;
              return false;
            }
            order.width = value;
            return false;
          }
          order.color = value;
          return false;
        }
        if (type === "function") {
          if (mathFunctions.has(value.toLowerCase())) {
            order.width = stringify17(node);
          } else {
            order.color = stringify17(node);
          }
          return false;
        }
      });
      return `${order.width} ${order.style} ${order.color}`.trim();
    };
  }
});

// node_modules/postcss-ordered-values/src/lib/vendorUnprefixed.js
var require_vendorUnprefixed = __commonJS({
  "node_modules/postcss-ordered-values/src/lib/vendorUnprefixed.js"(exports, module) {
    "use strict";
    function vendorUnprefixed(prop) {
      return prop.replace(/^-\w+-/, "");
    }
    module.exports = vendorUnprefixed;
  }
});

// node_modules/postcss-ordered-values/src/rules/boxShadow.js
var require_boxShadow = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/boxShadow.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    var { getArguments } = require_src3();
    var addSpace = require_addSpace();
    var getValue = require_getValue();
    var mathFunctions = require_mathfunctions();
    var vendorUnprefixed = require_vendorUnprefixed();
    module.exports = function normalizeBoxShadow(parsed) {
      let args = getArguments(parsed);
      const normalized = normalize(args);
      if (normalized === false) {
        return parsed.toString();
      }
      return getValue(normalized);
    };
    function normalize(args) {
      const list = [];
      let abort = false;
      for (const arg of args) {
        let val = [];
        let state = {
          inset: [],
          color: []
        };
        arg.forEach((node) => {
          const { type, value } = node;
          if (type === "function" && mathFunctions.has(vendorUnprefixed(value.toLowerCase()))) {
            abort = true;
            return;
          }
          if (type === "space") {
            return;
          }
          if (unit(value)) {
            val = [...val, node, addSpace()];
          } else if (value.toLowerCase() === "inset") {
            state.inset = [...state.inset, node, addSpace()];
          } else {
            state.color = [...state.color, node, addSpace()];
          }
        });
        if (abort) {
          return false;
        }
        list.push([...state.inset, ...val, ...state.color]);
      }
      return list;
    }
  }
});

// node_modules/postcss-ordered-values/src/rules/flexFlow.js
var require_flexFlow = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/flexFlow.js"(exports, module) {
    "use strict";
    var flexDirection = /* @__PURE__ */ new Set([
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ]);
    var flexWrap = /* @__PURE__ */ new Set(["nowrap", "wrap", "wrap-reverse"]);
    module.exports = function normalizeFlexFlow(flexFlow) {
      let order = {
        direction: "",
        wrap: ""
      };
      flexFlow.walk(({ value }) => {
        if (flexDirection.has(value.toLowerCase())) {
          order.direction = value;
          return;
        }
        if (flexWrap.has(value.toLowerCase())) {
          order.wrap = value;
          return;
        }
      });
      return `${order.direction} ${order.wrap}`.trim();
    };
  }
});

// node_modules/postcss-ordered-values/src/rules/transition.js
var require_transition = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/transition.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    var { getArguments } = require_src3();
    var addSpace = require_addSpace();
    var getValue = require_getValue();
    var timingFunctions = /* @__PURE__ */ new Set([
      "ease",
      "linear",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "step-start",
      "step-end"
    ]);
    function normalize(args) {
      const list = [];
      for (const arg of args) {
        let state = {
          timingFunction: [],
          property: [],
          time1: [],
          time2: []
        };
        arg.forEach((node) => {
          const { type, value } = node;
          if (type === "space") {
            return;
          }
          if (type === "function" && (/* @__PURE__ */ new Set(["steps", "cubic-bezier"])).has(value.toLowerCase())) {
            state.timingFunction = [...state.timingFunction, node, addSpace()];
          } else if (unit(value)) {
            if (!state.time1.length) {
              state.time1 = [...state.time1, node, addSpace()];
            } else {
              state.time2 = [...state.time2, node, addSpace()];
            }
          } else if (timingFunctions.has(value.toLowerCase())) {
            state.timingFunction = [...state.timingFunction, node, addSpace()];
          } else {
            state.property = [...state.property, node, addSpace()];
          }
        });
        list.push([
          ...state.property,
          ...state.time1,
          ...state.timingFunction,
          ...state.time2
        ]);
      }
      return list;
    }
    module.exports = function normalizeTransition(parsed) {
      const values = normalize(getArguments(parsed));
      return getValue(values);
    };
  }
});

// node_modules/postcss-ordered-values/src/rules/listStyleTypes.json
var require_listStyleTypes = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/listStyleTypes.json"(exports, module) {
    module.exports = {
      "list-style-type": [
        "afar",
        "amharic",
        "amharic-abegede",
        "arabic-indic",
        "armenian",
        "asterisks",
        "bengali",
        "binary",
        "cambodian",
        "circle",
        "cjk-decimal",
        "cjk-earthly-branch",
        "cjk-heavenly-stem",
        "cjk-ideographic",
        "decimal",
        "decimal-leading-zero",
        "devanagari",
        "disc",
        "disclosure-closed",
        "disclosure-open",
        "ethiopic",
        "ethiopic-abegede",
        "ethiopic-abegede-am-et",
        "ethiopic-abegede-gez",
        "ethiopic-abegede-ti-er",
        "ethiopic-abegede-ti-et",
        "ethiopic-halehame",
        "ethiopic-halehame-aa-er",
        "ethiopic-halehame-aa-et",
        "ethiopic-halehame-am",
        "ethiopic-halehame-am-et",
        "ethiopic-halehame-gez",
        "ethiopic-halehame-om-et",
        "ethiopic-halehame-sid-et",
        "ethiopic-halehame-so-et",
        "ethiopic-halehame-ti-er",
        "ethiopic-halehame-ti-et",
        "ethiopic-halehame-tig",
        "ethiopic-numeric",
        "footnotes",
        "georgian",
        "gujarati",
        "gurmukhi",
        "hangul",
        "hangul-consonant",
        "hebrew",
        "hiragana",
        "hiragana-iroha",
        "japanese-formal",
        "japanese-informal",
        "kannada",
        "katakana",
        "katakana-iroha",
        "khmer",
        "korean-hangul-formal",
        "korean-hanja-formal",
        "korean-hanja-informal",
        "lao",
        "lower-alpha",
        "lower-armenian",
        "lower-greek",
        "lower-hexadecimal",
        "lower-latin",
        "lower-norwegian",
        "lower-roman",
        "malayalam",
        "mongolian",
        "myanmar",
        "octal",
        "oriya",
        "oromo",
        "persian",
        "sidama",
        "simp-chinese-formal",
        "simp-chinese-informal",
        "somali",
        "square",
        "string",
        "symbols",
        "tamil",
        "telugu",
        "thai",
        "tibetan",
        "tigre",
        "tigrinya-er",
        "tigrinya-er-abegede",
        "tigrinya-et",
        "tigrinya-et-abegede",
        "trad-chinese-formal",
        "trad-chinese-informal",
        "upper-alpha",
        "upper-armenian",
        "upper-greek",
        "upper-hexadecimal",
        "upper-latin",
        "upper-norwegian",
        "upper-roman",
        "urdu"
      ]
    };
  }
});

// node_modules/postcss-ordered-values/src/rules/listStyle.js
var require_listStyle = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/listStyle.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var listStyleTypes = require_listStyleTypes();
    var definedTypes = new Set(listStyleTypes["list-style-type"]);
    var definedPosition = /* @__PURE__ */ new Set(["inside", "outside"]);
    module.exports = function listStyleNormalizer(listStyle) {
      const order = { type: "", position: "", image: "" };
      listStyle.walk((decl) => {
        if (decl.type === "word") {
          if (definedTypes.has(decl.value)) {
            order.type = `${order.type} ${decl.value}`;
          } else if (definedPosition.has(decl.value)) {
            order.position = `${order.position} ${decl.value}`;
          } else if (decl.value === "none") {
            if (order.type.split(" ").filter((e2) => e2 !== "" && e2 !== " ").includes("none")) {
              order.image = `${order.image} ${decl.value}`;
            } else {
              order.type = `${order.type} ${decl.value}`;
            }
          } else {
            order.type = `${order.type} ${decl.value}`;
          }
        }
        if (decl.type === "function") {
          order.image = `${order.image} ${valueParser.stringify(decl)}`;
        }
      });
      return `${order.type.trim()} ${order.position.trim()} ${order.image.trim()}`.trim();
    };
  }
});

// node_modules/postcss-ordered-values/src/rules/columns.js
var require_columns = __commonJS({
  "node_modules/postcss-ordered-values/src/rules/columns.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    function hasUnit(value) {
      const parsedVal = unit(value);
      return parsedVal && parsedVal.unit !== "";
    }
    module.exports = (columns) => {
      const widths = [];
      const other = [];
      columns.walk((node) => {
        const { type, value } = node;
        if (type === "word") {
          if (hasUnit(value)) {
            widths.push(value);
          } else {
            other.push(value);
          }
        }
      });
      if (other.length === 1 && widths.length === 1) {
        return `${widths[0].trimStart()} ${other[0].trimStart()}`;
      }
      return columns;
    };
  }
});

// node_modules/postcss-ordered-values/src/index.js
var require_src10 = __commonJS({
  "node_modules/postcss-ordered-values/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var {
      normalizeGridAutoFlow,
      normalizeGridColumnRowGap,
      normalizeGridColumnRow
    } = require_grid();
    var animation = require_animation();
    var border = require_border2();
    var boxShadow = require_boxShadow();
    var flexFlow = require_flexFlow();
    var transition = require_transition();
    var listStyle = require_listStyle();
    var column = require_columns();
    var vendorUnprefixed = require_vendorUnprefixed();
    var borderRules = [
      ["border", border],
      ["border-block", border],
      ["border-inline", border],
      ["border-block-end", border],
      ["border-block-start", border],
      ["border-inline-end", border],
      ["border-inline-start", border],
      ["border-top", border],
      ["border-right", border],
      ["border-bottom", border],
      ["border-left", border]
    ];
    var grid = [
      ["grid-auto-flow", normalizeGridAutoFlow],
      ["grid-column-gap", normalizeGridColumnRowGap],
      ["grid-row-gap", normalizeGridColumnRowGap],
      ["grid-column", normalizeGridColumnRow],
      ["grid-row", normalizeGridColumnRow],
      ["grid-row-start", normalizeGridColumnRow],
      ["grid-row-end", normalizeGridColumnRow],
      ["grid-column-start", normalizeGridColumnRow],
      ["grid-column-end", normalizeGridColumnRow]
    ];
    var columnRules = [
      ["column-rule", border],
      ["columns", column]
    ];
    var rules = new Map([
      ["animation", animation],
      ["outline", border],
      ["box-shadow", boxShadow],
      ["flex-flow", flexFlow],
      ["list-style", listStyle],
      ["transition", transition],
      ...borderRules,
      ...grid,
      ...columnRules
    ]);
    var variableFunctions = /* @__PURE__ */ new Set(["var", "env", "constant"]);
    function isVariableFunctionNode(node) {
      if (node.type !== "function") {
        return false;
      }
      return variableFunctions.has(node.value.toLowerCase());
    }
    function shouldAbort(parsed) {
      let abort = false;
      parsed.walk((node) => {
        if (node.type === "comment" || isVariableFunctionNode(node) || node.type === "word" && node.value.includes(`___CSS_LOADER_IMPORT___`)) {
          abort = true;
          return false;
        }
      });
      return abort;
    }
    function getValue(decl) {
      let { value, raws } = decl;
      if (raws && raws.value && raws.value.raw) {
        value = raws.value.raw;
      }
      return value;
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-ordered-values",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkDecls((decl) => {
                const lowerCasedProp = decl.prop.toLowerCase();
                const normalizedProp = vendorUnprefixed(lowerCasedProp);
                const processor = rules.get(normalizedProp);
                if (!processor) {
                  return;
                }
                const value = getValue(decl);
                if (cache.has(value)) {
                  decl.value = cache.get(value);
                  return;
                }
                const parsed = valueParser(value);
                if (parsed.nodes.length < 2 || shouldAbort(parsed)) {
                  cache.set(value, value);
                  return;
                }
                const result = processor(parsed);
                decl.value = result.toString();
                cache.set(value, result.toString());
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-minify-selectors/src/lib/canUnquote.js
var require_canUnquote = __commonJS({
  "node_modules/postcss-minify-selectors/src/lib/canUnquote.js"(exports, module) {
    "use strict";
    var escapes = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?/g;
    var range = /[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
    module.exports = function canUnquote(value) {
      if (value === "-" || value === "") {
        return false;
      }
      value = value.replace(escapes, "a").replace(/\\./g, "a");
      return !(range.test(value) || /^(?:-?\d|--)/.test(value));
    };
  }
});

// node_modules/postcss-minify-selectors/src/index.js
var require_src11 = __commonJS({
  "node_modules/postcss-minify-selectors/src/index.js"(exports, module) {
    "use strict";
    var parser = require_dist3();
    var canUnquote = require_canUnquote();
    var pseudoElements = /* @__PURE__ */ new Set([
      "::before",
      "::after",
      "::first-letter",
      "::first-line"
    ]);
    function attribute(selector) {
      if (selector.value) {
        if (selector.raws.value) {
          selector.raws.value = selector.raws.value.replace(/\\\n/g, "").trim();
        }
        if (canUnquote(selector.value)) {
          selector.quoteMark = null;
        }
        if (selector.operator) {
          selector.operator = selector.operator.trim();
        }
      }
      selector.rawSpaceBefore = "";
      selector.rawSpaceAfter = "";
      selector.spaces.attribute = { before: "", after: "" };
      selector.spaces.operator = { before: "", after: "" };
      selector.spaces.value = {
        before: "",
        after: selector.insensitive ? " " : ""
      };
      if (selector.raws.spaces) {
        selector.raws.spaces.attribute = {
          before: "",
          after: ""
        };
        selector.raws.spaces.operator = {
          before: "",
          after: ""
        };
        selector.raws.spaces.value = {
          before: "",
          after: selector.insensitive ? " " : ""
        };
        if (selector.insensitive) {
          selector.raws.spaces.insensitive = {
            before: "",
            after: ""
          };
        }
      }
      selector.attribute = selector.attribute.trim();
    }
    function combinator(selector) {
      const value = selector.value.trim();
      selector.spaces.before = "";
      selector.spaces.after = "";
      selector.rawSpaceBefore = "";
      selector.rawSpaceAfter = "";
      selector.value = value.length ? value : " ";
    }
    var pseudoReplacements = /* @__PURE__ */ new Map([
      [":nth-child", ":first-child"],
      [":nth-of-type", ":first-of-type"],
      [":nth-last-child", ":last-child"],
      [":nth-last-of-type", ":last-of-type"]
    ]);
    function pseudo(selector) {
      const value = selector.value.toLowerCase();
      if (selector.nodes.length === 1 && pseudoReplacements.has(value)) {
        const first = selector.at(0);
        const one = first.at(0);
        if (first.length === 1) {
          if (one.value === "1") {
            selector.replaceWith(
              parser.pseudo({
                value: pseudoReplacements.get(value)
              })
            );
          }
          if (one.value && one.value.toLowerCase() === "even") {
            one.value = "2n";
          }
        }
        if (first.length === 3) {
          const two = first.at(1);
          const three = first.at(2);
          if (one.value && one.value.toLowerCase() === "2n" && two.value === "+" && three.value === "1") {
            one.value = "odd";
            two.remove();
            three.remove();
          }
        }
        return;
      }
      selector.walk((child) => {
        if (child.type === "selector" && child.parent) {
          const uniques = /* @__PURE__ */ new Set();
          child.parent.each((sibling) => {
            const siblingStr = String(sibling);
            if (!uniques.has(siblingStr)) {
              uniques.add(siblingStr);
            } else {
              sibling.remove();
            }
          });
        }
      });
      if (pseudoElements.has(value)) {
        selector.value = selector.value.slice(1);
      }
    }
    var tagReplacements = /* @__PURE__ */ new Map([
      ["from", "0%"],
      ["100%", "to"]
    ]);
    function tag(selector) {
      const value = selector.value.toLowerCase();
      if (tagReplacements.has(value)) {
        selector.value = tagReplacements.get(value);
      }
    }
    function universal(selector) {
      const next = selector.next();
      if (next && next.type !== "combinator") {
        selector.remove();
      }
    }
    var reducers = /* @__PURE__ */ new Map(
      [
        ["attribute", attribute],
        ["combinator", combinator],
        ["pseudo", pseudo],
        ["tag", tag],
        ["universal", universal]
      ]
    );
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-minify-selectors",
        OnceExit(css) {
          const cache = /* @__PURE__ */ new Map();
          const processor = parser((selectors) => {
            const uniqueSelectors = /* @__PURE__ */ new Set();
            selectors.walk((sel) => {
              sel.spaces.before = sel.spaces.after = "";
              const reducer = reducers.get(sel.type);
              if (reducer !== void 0) {
                reducer(sel);
                return;
              }
              const toString = String(sel);
              if (sel.type === "selector" && sel.parent && sel.parent.type !== "pseudo") {
                if (!uniqueSelectors.has(toString)) {
                  uniqueSelectors.add(toString);
                } else {
                  sel.remove();
                }
              }
            });
            selectors.nodes.sort();
          });
          css.walkRules((rule) => {
            const selector = rule.raws.selector && rule.raws.selector.value === rule.selector ? rule.raws.selector.raw : rule.selector;
            if (selector[selector.length - 1] === ":") {
              return;
            }
            if (cache.has(selector)) {
              rule.selector = cache.get(selector);
              return;
            }
            const optimizedSelector = processor.processSync(selector);
            rule.selector = optimizedSelector;
            cache.set(selector, optimizedSelector);
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-minify-params/src/index.js
var require_src12 = __commonJS({
  "node_modules/postcss-minify-params/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var valueParser = require_lib();
    var { getArguments } = require_src3();
    function gcd(a2, b2) {
      return b2 ? gcd(b2, a2 % b2) : a2;
    }
    function aspectRatio(a2, b2) {
      const divisor = gcd(a2, b2);
      return [a2 / divisor, b2 / divisor];
    }
    function split(args) {
      return args.map((arg) => valueParser.stringify(arg)).join("");
    }
    function removeNode(node) {
      node.value = "";
      node.type = "word";
    }
    function sortAndDedupe(items) {
      const a2 = [...new Set(items)];
      a2.sort();
      return a2.join();
    }
    function transform(legacy, rule) {
      const ruleName = rule.name.toLowerCase();
      if (!rule.params || !["media", "supports"].includes(ruleName)) {
        return;
      }
      const params = valueParser(rule.params);
      params.walk((node, index) => {
        if (node.type === "div") {
          node.before = node.after = "";
        } else if (node.type === "function") {
          node.before = "";
          if (node.nodes[0] && node.nodes[0].type === "word" && node.nodes[0].value.startsWith("--") && node.nodes[2] === void 0) {
            node.after = " ";
          } else {
            node.after = "";
          }
          if (node.nodes[4] && node.nodes[0].value.toLowerCase().indexOf("-aspect-ratio") === 3) {
            const [a2, b2] = aspectRatio(
              Number(node.nodes[2].value),
              Number(node.nodes[4].value)
            );
            node.nodes[2].value = a2.toString();
            node.nodes[4].value = b2.toString();
          }
        } else if (node.type === "space") {
          node.value = " ";
        } else {
          const prevWord = params.nodes[index - 2];
          if (node.value.toLowerCase() === "all" && rule.name.toLowerCase() === "media" && !prevWord) {
            const nextWord = params.nodes[index + 2];
            if (!legacy || nextWord) {
              removeNode(node);
            }
            if (nextWord && nextWord.value.toLowerCase() === "and") {
              const nextSpace = params.nodes[index + 1];
              const secondSpace = params.nodes[index + 3];
              removeNode(nextWord);
              removeNode(nextSpace);
              removeNode(secondSpace);
            }
          }
        }
      }, true);
      rule.params = sortAndDedupe(getArguments(params).map(split));
      if (!rule.params.length) {
        rule.raws.afterName = "";
      }
    }
    var allBugBrowers = /* @__PURE__ */ new Set(["ie 10", "ie 11"]);
    function pluginCreator(options = {}) {
      const browsers = browserslist(null, {
        stats: options.stats,
        path: __dirname,
        env: options.env
      });
      const hasAllBug = browsers.some((browser) => allBugBrowers.has(browser));
      return {
        postcssPlugin: "postcss-minify-params",
        OnceExit(css) {
          css.walkAtRules((rule) => transform(hasAllBug, rule));
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-charset/src/index.js
var require_src13 = __commonJS({
  "node_modules/postcss-normalize-charset/src/index.js"(exports, module) {
    "use strict";
    var charset = "charset";
    var nonAscii = /[^\x00-\x7F]/;
    function pluginCreator(opts = {}) {
      return {
        postcssPlugin: "postcss-normalize-" + charset,
        OnceExit(css, { AtRule }) {
          let charsetRule;
          let nonAsciiNode;
          css.walk((node) => {
            if (node.type === "atrule" && node.name === charset) {
              if (!charsetRule) {
                charsetRule = node;
              }
              node.remove();
            } else if (!nonAsciiNode && node.parent === css && nonAscii.test(node.toString())) {
              nonAsciiNode = node;
            }
          });
          if (nonAsciiNode) {
            if (!charsetRule && opts.add !== false) {
              charsetRule = new AtRule({
                name: charset,
                params: '"utf-8"'
              });
            }
            if (charsetRule) {
              charsetRule.source = nonAsciiNode.source;
              css.prepend(charsetRule);
            }
          }
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-minify-font-values/src/lib/minify-weight.js
var require_minify_weight = __commonJS({
  "node_modules/postcss-minify-font-values/src/lib/minify-weight.js"(exports, module) {
    "use strict";
    module.exports = function(value) {
      const lowerCasedValue = value.toLowerCase();
      return lowerCasedValue === "normal" ? "400" : lowerCasedValue === "bold" ? "700" : value;
    };
  }
});

// node_modules/postcss-minify-font-values/src/lib/minify-family.js
var require_minify_family = __commonJS({
  "node_modules/postcss-minify-font-values/src/lib/minify-family.js"(exports, module) {
    "use strict";
    var { stringify: stringify17 } = require_lib();
    function uniqueFontFamilies(list) {
      return list.filter((item, i2) => {
        if (item.toLowerCase() === "monospace") {
          return true;
        }
        return i2 === list.indexOf(item);
      });
    }
    var globalKeywords = ["inherit", "initial", "unset"];
    var genericFontFamilykeywords = /* @__PURE__ */ new Set([
      "sans-serif",
      "serif",
      "fantasy",
      "cursive",
      "monospace",
      "system-ui"
    ]);
    function makeArray(value, length) {
      let array = [];
      while (length--) {
        array[length] = value;
      }
      return array;
    }
    var regexSimpleEscapeCharacters = /[ !"#$%&'()*+,.\/;<=>?@\[\\\]^`{|}~]/;
    function escape(string2, escapeForString) {
      let counter = 0;
      let character;
      let charCode;
      let value;
      let output = "";
      while (counter < string2.length) {
        character = string2.charAt(counter++);
        charCode = character.charCodeAt(0);
        if (!escapeForString && /[\t\n\v\f:]/.test(character)) {
          value = "\\" + charCode.toString(16) + " ";
        } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {
          value = "\\" + character;
        } else {
          value = character;
        }
        output += value;
      }
      if (!escapeForString) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        }
        const firstChar = string2.charAt(0);
        if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      return output;
    }
    var regexKeyword = new RegExp(
      [...genericFontFamilykeywords].concat(globalKeywords).join("|"),
      "i"
    );
    var regexInvalidIdentifier = /^(-?\d|--)/;
    var regexSpaceAtStart = /^\x20/;
    var regexWhitespace = /[\t\n\f\r\x20]/g;
    var regexIdentifierCharacter = /^[a-zA-Z\d\xa0-\uffff_-]+$/;
    var regexConsecutiveSpaces = /(\\(?:[a-fA-F0-9]{1,6}\x20|\x20))?(\x20{2,})/g;
    var regexTrailingEscape = /\\[a-fA-F0-9]{0,6}\x20$/;
    var regexTrailingSpace = /\x20$/;
    function escapeIdentifierSequence(string2) {
      let identifiers = string2.split(regexWhitespace);
      let index = 0;
      let result = [];
      let escapeResult;
      while (index < identifiers.length) {
        let subString = identifiers[index++];
        if (subString === "") {
          result.push(subString);
          continue;
        }
        escapeResult = escape(subString, false);
        if (regexIdentifierCharacter.test(subString)) {
          if (regexInvalidIdentifier.test(subString)) {
            if (index === 1) {
              result.push(escapeResult);
            } else {
              result[index - 2] += "\\";
              result.push(escape(subString, true));
            }
          } else {
            result.push(escapeResult);
          }
        } else {
          result.push(escapeResult);
        }
      }
      result = result.join(" ").replace(regexConsecutiveSpaces, ($0, $1, $2) => {
        const spaceCount = $2.length;
        const escapesNeeded = Math.floor(spaceCount / 2);
        const array = makeArray("\\ ", escapesNeeded);
        if (spaceCount % 2) {
          array[escapesNeeded - 1] += "\\ ";
        }
        return ($1 || "") + " " + array.join(" ");
      });
      if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {
        result = result.replace(regexTrailingSpace, "\\ ");
      }
      if (regexSpaceAtStart.test(result)) {
        result = "\\ " + result.slice(1);
      }
      return result;
    }
    module.exports = function(nodes, opts) {
      const family = [];
      let last = null;
      let i2, max;
      nodes.forEach((node, index, arr) => {
        if (node.type === "string" || node.type === "function") {
          family.push(node);
        } else if (node.type === "word") {
          if (!last) {
            last = {
              type: "word",
              value: ""
            };
            family.push(last);
          }
          last.value += node.value;
        } else if (node.type === "space") {
          if (last && index !== arr.length - 1) {
            last.value += " ";
          }
        } else {
          last = null;
        }
      });
      let normalizedFamilies = family.map((node) => {
        if (node.type === "string") {
          const isKeyword = regexKeyword.test(node.value);
          if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {
            return stringify17(node);
          }
          let escaped = escapeIdentifierSequence(node.value);
          if (escaped.length < node.value.length + 2) {
            return escaped;
          }
        }
        return stringify17(node);
      });
      if (opts.removeAfterKeyword) {
        for (i2 = 0, max = normalizedFamilies.length; i2 < max; i2 += 1) {
          if (genericFontFamilykeywords.has(normalizedFamilies[i2].toLowerCase())) {
            normalizedFamilies = normalizedFamilies.slice(0, i2 + 1);
            break;
          }
        }
      }
      if (opts.removeDuplicates) {
        normalizedFamilies = uniqueFontFamilies(normalizedFamilies);
      }
      return [
        {
          type: "word",
          value: normalizedFamilies.join()
        }
      ];
    };
  }
});

// node_modules/postcss-minify-font-values/src/lib/keywords.js
var require_keywords = __commonJS({
  "node_modules/postcss-minify-font-values/src/lib/keywords.js"(exports, module) {
    "use strict";
    module.exports = {
      style: /* @__PURE__ */ new Set(["italic", "oblique"]),
      variant: /* @__PURE__ */ new Set(["small-caps"]),
      weight: /* @__PURE__ */ new Set([
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900",
        "bold",
        "lighter",
        "bolder"
      ]),
      stretch: /* @__PURE__ */ new Set([
        "ultra-condensed",
        "extra-condensed",
        "condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded"
      ]),
      size: /* @__PURE__ */ new Set([
        "xx-small",
        "x-small",
        "small",
        "medium",
        "large",
        "x-large",
        "xx-large",
        "larger",
        "smaller"
      ])
    };
  }
});

// node_modules/postcss-minify-font-values/src/lib/minify-font.js
var require_minify_font = __commonJS({
  "node_modules/postcss-minify-font-values/src/lib/minify-font.js"(exports, module) {
    "use strict";
    var { unit } = require_lib();
    var keywords = require_keywords();
    var minifyFamily = require_minify_family();
    var minifyWeight = require_minify_weight();
    module.exports = function(nodes, opts) {
      let i2, max, node, family;
      let familyStart = NaN;
      let hasSize = false;
      for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
        node = nodes[i2];
        if (node.type === "word") {
          if (hasSize) {
            continue;
          }
          const value = node.value.toLowerCase();
          if (value === "normal" || value === "inherit" || value === "initial" || value === "unset") {
            familyStart = i2;
          } else if (keywords.style.has(value) || unit(value)) {
            familyStart = i2;
          } else if (keywords.variant.has(value)) {
            familyStart = i2;
          } else if (keywords.weight.has(value)) {
            node.value = minifyWeight(value);
            familyStart = i2;
          } else if (keywords.stretch.has(value)) {
            familyStart = i2;
          } else if (keywords.size.has(value) || unit(value)) {
            familyStart = i2;
            hasSize = true;
          }
        } else if (node.type === "function" && nodes[i2 + 1] && nodes[i2 + 1].type === "space") {
          familyStart = i2;
        } else if (node.type === "div" && node.value === "/") {
          familyStart = i2 + 1;
          break;
        }
      }
      familyStart += 2;
      family = minifyFamily(nodes.slice(familyStart), opts);
      return nodes.slice(0, familyStart).concat(family);
    };
  }
});

// node_modules/postcss-minify-font-values/src/index.js
var require_src14 = __commonJS({
  "node_modules/postcss-minify-font-values/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var minifyWeight = require_minify_weight();
    var minifyFamily = require_minify_family();
    var minifyFont = require_minify_font();
    function hasVariableFunction(value) {
      const lowerCasedValue = value.toLowerCase();
      return lowerCasedValue.includes("var(") || lowerCasedValue.includes("env(");
    }
    function transform(prop, value, opts) {
      let lowerCasedProp = prop.toLowerCase();
      if (lowerCasedProp === "font-weight" && !hasVariableFunction(value)) {
        return minifyWeight(value);
      } else if (lowerCasedProp === "font-family" && !hasVariableFunction(value)) {
        const tree = valueParser(value);
        tree.nodes = minifyFamily(tree.nodes, opts);
        return tree.toString();
      } else if (lowerCasedProp === "font") {
        const tree = valueParser(value);
        tree.nodes = minifyFont(tree.nodes, opts);
        return tree.toString();
      }
      return value;
    }
    function pluginCreator(opts) {
      opts = Object.assign(
        {},
        {
          removeAfterKeyword: false,
          removeDuplicates: true,
          removeQuotes: true
        },
        opts
      );
      return {
        postcssPlugin: "postcss-minify-font-values",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkDecls(/font/i, (decl) => {
                const value = decl.value;
                if (!value) {
                  return;
                }
                const prop = decl.prop;
                const cacheKey = `${prop}|${value}`;
                if (cache.has(cacheKey)) {
                  decl.value = cache.get(cacheKey);
                  return;
                }
                const newValue = transform(prop, value, opts);
                decl.value = newValue;
                cache.set(cacheKey, newValue);
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/normalize-url/index.js
var require_normalize_url = __commonJS({
  "node_modules/normalize-url/index.js"(exports, module) {
    "use strict";
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters) => {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    };
    var normalizeDataURL = (urlString, { stripHash }) => {
      const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      let { type, data, hash } = match.groups;
      const mediaType = type.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        isBase64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes = mediaType.map((attribute) => {
        let [key, value = ""] = attribute.split("=").map((string2) => string2.trim());
        if (key === "charset") {
          value = value.toLowerCase();
          if (value === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value ? `=${value}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes
      ];
      if (isBase64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = {
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripTextFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeSingleSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true,
        ...options
      };
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      if (/^view-source:/i.test(urlString)) {
        throw new Error("`view-source:` is not supported as it is a non-standard protocol");
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URL(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      } else if (options.stripTextFragment) {
        urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(new RegExp("(?<!\\b(?:[a-z][a-z\\d+\\-.]{1,50}:))\\/{2,}", "g"), "/");
      }
      if (urlObj.pathname) {
        try {
          urlObj.pathname = decodeURI(urlObj.pathname);
        } catch (_) {
        }
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.removeQueryParameters === true) {
        urlObj.search = "";
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      const oldUrlString = urlString;
      urlString = urlObj.toString();
      if (!options.removeSingleSlash && urlObj.pathname === "/" && !oldUrlString.endsWith("/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "" && options.removeSingleSlash) {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module.exports = normalizeUrl;
  }
});

// node_modules/postcss-normalize-url/src/index.js
var require_src15 = __commonJS({
  "node_modules/postcss-normalize-url/src/index.js"(exports, module) {
    "use strict";
    var path = require_path();
    var valueParser = require_lib();
    var normalize = require_normalize_url();
    var multiline = /\\[\r\n]/;
    var escapeChars = /([\s\(\)"'])/g;
    var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
    var WINDOWS_PATH_REGEX = /^[a-zA-Z]:\\/;
    function isAbsolute(url) {
      if (WINDOWS_PATH_REGEX.test(url)) {
        return false;
      }
      return ABSOLUTE_URL_REGEX.test(url);
    }
    function convert(url, options) {
      if (isAbsolute(url) || url.startsWith("//")) {
        let normalizedURL;
        try {
          normalizedURL = normalize(url, options);
        } catch (e2) {
          normalizedURL = url;
        }
        return normalizedURL;
      }
      return path.normalize(url).replace(new RegExp("\\" + path.sep, "g"), "/");
    }
    function transformNamespace(rule) {
      rule.params = valueParser(rule.params).walk((node) => {
        if (node.type === "function" && node.value.toLowerCase() === "url" && node.nodes.length) {
          node.type = "string";
          node.quote = node.nodes[0].type === "string" ? node.nodes[0].quote : '"';
          node.value = node.nodes[0].value;
        }
        if (node.type === "string") {
          node.value = node.value.trim();
        }
        return false;
      }).toString();
    }
    function transformDecl(decl, opts) {
      decl.value = valueParser(decl.value).walk((node) => {
        if (node.type !== "function" || node.value.toLowerCase() !== "url") {
          return false;
        }
        node.before = node.after = "";
        if (!node.nodes.length) {
          return false;
        }
        let url = node.nodes[0];
        let escaped;
        url.value = url.value.trim().replace(multiline, "");
        if (url.value.length === 0) {
          url.quote = "";
          return false;
        }
        if (/^data:(.*)?,/i.test(url.value)) {
          return false;
        }
        if (!/^.+-extension:\//i.test(url.value)) {
          url.value = convert(url.value, opts);
        }
        if (escapeChars.test(url.value) && url.type === "string") {
          escaped = url.value.replace(escapeChars, "\\$1");
          if (escaped.length < url.value.length + 2) {
            url.value = escaped;
            url.type = "word";
          }
        } else {
          url.type = "word";
        }
        return false;
      }).toString();
    }
    function pluginCreator(opts) {
      opts = Object.assign(
        {},
        {
          normalizeProtocol: false,
          sortQueryParameters: false,
          stripHash: false,
          stripWWW: false,
          stripTextFragment: false
        },
        opts
      );
      return {
        postcssPlugin: "postcss-normalize-url",
        OnceExit(css) {
          css.walk((node) => {
            if (node.type === "decl") {
              return transformDecl(node, opts);
            } else if (node.type === "atrule" && node.name.toLowerCase() === "namespace") {
              return transformNamespace(node);
            }
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/stylehacks/src/exists.js
var require_exists = __commonJS({
  "node_modules/stylehacks/src/exists.js"(exports, module) {
    "use strict";
    module.exports = function exists(selector, index, value) {
      const node = selector.at(index);
      return node && node.value && node.value.toLowerCase() === value;
    };
  }
});

// node_modules/stylehacks/src/isMixin.js
var require_isMixin = __commonJS({
  "node_modules/stylehacks/src/isMixin.js"(exports, module) {
    "use strict";
    module.exports = function isMixin(node) {
      const { selector } = node;
      if (!selector || selector[selector.length - 1] === ":") {
        return true;
      }
      return false;
    };
  }
});

// node_modules/stylehacks/src/plugin.js
var require_plugin = __commonJS({
  "node_modules/stylehacks/src/plugin.js"(exports, module) {
    "use strict";
    module.exports = class BasePlugin {
      constructor(targets, nodeTypes, result) {
        this.nodes = [];
        this.targets = new Set(targets);
        this.nodeTypes = new Set(nodeTypes);
        this.result = result;
      }
      push(node, metadata) {
        node._stylehacks = Object.assign(
          {},
          metadata,
          {
            message: `Bad ${metadata.identifier}: ${metadata.hack}`,
            browsers: this.targets
          }
        );
        this.nodes.push(node);
      }
      any(node) {
        if (this.nodeTypes.has(node.type)) {
          this.detect(node);
          return node._stylehacks !== void 0;
        }
        return false;
      }
      detectAndResolve(node) {
        this.nodes = [];
        this.detect(node);
        return this.resolve();
      }
      detectAndWarn(node) {
        this.nodes = [];
        this.detect(node);
        return this.warn();
      }
      detect(node) {
        throw new Error("You need to implement this method in a subclass.");
      }
      resolve() {
        return this.nodes.forEach((node) => node.remove());
      }
      warn() {
        return this.nodes.forEach((node) => {
          const { message, browsers, identifier, hack } = node._stylehacks;
          return node.warn(
            this.result,
            message + JSON.stringify({ browsers, identifier, hack })
          );
        });
      }
    };
  }
});

// node_modules/stylehacks/src/dictionary/browsers.js
var require_browsers = __commonJS({
  "node_modules/stylehacks/src/dictionary/browsers.js"(exports, module) {
    "use strict";
    var FF_2 = "firefox 2";
    var IE_5_5 = "ie 5.5";
    var IE_6 = "ie 6";
    var IE_7 = "ie 7";
    var IE_8 = "ie 8";
    var OP_9 = "opera 9";
    module.exports = { FF_2, IE_5_5, IE_6, IE_7, IE_8, OP_9 };
  }
});

// node_modules/stylehacks/src/dictionary/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/stylehacks/src/dictionary/identifiers.js"(exports, module) {
    "use strict";
    var MEDIA_QUERY = "media query";
    var PROPERTY = "property";
    var SELECTOR = "selector";
    var VALUE = "value";
    module.exports = { MEDIA_QUERY, PROPERTY, SELECTOR, VALUE };
  }
});

// node_modules/stylehacks/src/dictionary/postcss.js
var require_postcss2 = __commonJS({
  "node_modules/stylehacks/src/dictionary/postcss.js"(exports, module) {
    "use strict";
    var ATRULE = "atrule";
    var DECL = "decl";
    var RULE = "rule";
    module.exports = { ATRULE, DECL, RULE };
  }
});

// node_modules/stylehacks/src/dictionary/tags.js
var require_tags = __commonJS({
  "node_modules/stylehacks/src/dictionary/tags.js"(exports, module) {
    "use strict";
    var BODY = "body";
    var HTML = "html";
    module.exports = { BODY, HTML };
  }
});

// node_modules/stylehacks/src/plugins/bodyEmpty.js
var require_bodyEmpty = __commonJS({
  "node_modules/stylehacks/src/plugins/bodyEmpty.js"(exports, module) {
    "use strict";
    var parser = require_dist3();
    var exists = require_exists();
    var isMixin = require_isMixin();
    var BasePlugin = require_plugin();
    var { FF_2 } = require_browsers();
    var { SELECTOR } = require_identifiers();
    var { RULE } = require_postcss2();
    var { BODY } = require_tags();
    module.exports = class BodyEmpty extends BasePlugin {
      constructor(result) {
        super([FF_2], [RULE], result);
      }
      detect(rule) {
        if (isMixin(rule)) {
          return;
        }
        parser(this.analyse(rule)).processSync(rule.selector);
      }
      analyse(rule) {
        return (selectors) => {
          selectors.each((selector) => {
            if (exists(selector, 0, BODY) && exists(selector, 1, ":empty") && exists(selector, 2, " ") && selector.at(3)) {
              this.push(rule, {
                identifier: SELECTOR,
                hack: selector.toString()
              });
            }
          });
        };
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/htmlCombinatorCommentBody.js
var require_htmlCombinatorCommentBody = __commonJS({
  "node_modules/stylehacks/src/plugins/htmlCombinatorCommentBody.js"(exports, module) {
    "use strict";
    var parser = require_dist3();
    var exists = require_exists();
    var isMixin = require_isMixin();
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6, IE_7 } = require_browsers();
    var { SELECTOR } = require_identifiers();
    var { RULE } = require_postcss2();
    var { BODY, HTML } = require_tags();
    module.exports = class HtmlCombinatorCommentBody extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7], [RULE], result);
      }
      detect(rule) {
        if (isMixin(rule)) {
          return;
        }
        if (rule.raws.selector && rule.raws.selector.raw) {
          parser(this.analyse(rule)).processSync(rule.raws.selector.raw);
        }
      }
      analyse(rule) {
        return (selectors) => {
          selectors.each((selector) => {
            if (exists(selector, 0, HTML) && (exists(selector, 1, ">") || exists(selector, 1, "~")) && selector.at(2) && selector.at(2).type === "comment" && exists(selector, 3, " ") && exists(selector, 4, BODY) && exists(selector, 5, " ") && selector.at(6)) {
              this.push(rule, {
                identifier: SELECTOR,
                hack: selector.toString()
              });
            }
          });
        };
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/htmlFirstChild.js
var require_htmlFirstChild = __commonJS({
  "node_modules/stylehacks/src/plugins/htmlFirstChild.js"(exports, module) {
    "use strict";
    var parser = require_dist3();
    var exists = require_exists();
    var isMixin = require_isMixin();
    var BasePlugin = require_plugin();
    var { OP_9 } = require_browsers();
    var { SELECTOR } = require_identifiers();
    var { RULE } = require_postcss2();
    var { HTML } = require_tags();
    module.exports = class HtmlFirstChild extends BasePlugin {
      constructor(result) {
        super([OP_9], [RULE], result);
      }
      detect(rule) {
        if (isMixin(rule)) {
          return;
        }
        parser(this.analyse(rule)).processSync(rule.selector);
      }
      analyse(rule) {
        return (selectors) => {
          selectors.each((selector) => {
            if (exists(selector, 0, HTML) && exists(selector, 1, ":first-child") && exists(selector, 2, " ") && selector.at(3)) {
              this.push(rule, {
                identifier: SELECTOR,
                hack: selector.toString()
              });
            }
          });
        };
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/important.js
var require_important = __commonJS({
  "node_modules/stylehacks/src/plugins/important.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6, IE_7 } = require_browsers();
    var { DECL } = require_postcss2();
    module.exports = class Important extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7], [DECL], result);
      }
      detect(decl) {
        const match = decl.value.match(/!\w/);
        if (match && match.index) {
          const hack = decl.value.substr(match.index, decl.value.length - 1);
          this.push(decl, {
            identifier: "!important",
            hack
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/leadingStar.js
var require_leadingStar = __commonJS({
  "node_modules/stylehacks/src/plugins/leadingStar.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6, IE_7 } = require_browsers();
    var { PROPERTY } = require_identifiers();
    var { ATRULE, DECL } = require_postcss2();
    var hacks = "!_$_&_*_)_=_%_+_,_._/_`_]_#_~_?_:_|".split("_");
    module.exports = class LeadingStar extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7], [ATRULE, DECL], result);
      }
      detect(node) {
        if (node.type === DECL) {
          hacks.forEach((hack) => {
            if (!node.prop.indexOf(hack)) {
              this.push(node, {
                identifier: PROPERTY,
                hack: node.prop
              });
            }
          });
          const { before } = node.raws;
          if (!before) {
            return;
          }
          hacks.forEach((hack) => {
            if (before.includes(hack)) {
              this.push(node, {
                identifier: PROPERTY,
                hack: `${before.trim()}${node.prop}`
              });
            }
          });
        } else {
          const { name } = node;
          const len = name.length - 1;
          if (name.lastIndexOf(":") === len) {
            this.push(node, {
              identifier: PROPERTY,
              hack: `@${name.substr(0, len)}`
            });
          }
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/leadingUnderscore.js
var require_leadingUnderscore = __commonJS({
  "node_modules/stylehacks/src/plugins/leadingUnderscore.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_6 } = require_browsers();
    var { PROPERTY } = require_identifiers();
    var { DECL } = require_postcss2();
    function vendorPrefix(prop) {
      let match = prop.match(/^(-\w+-)/);
      if (match) {
        return match[0];
      }
      return "";
    }
    module.exports = class LeadingUnderscore extends BasePlugin {
      constructor(result) {
        super([IE_6], [DECL], result);
      }
      detect(decl) {
        const { before } = decl.raws;
        if (before && before.includes("_")) {
          this.push(decl, {
            identifier: PROPERTY,
            hack: `${before.trim()}${decl.prop}`
          });
        }
        if (decl.prop[0] === "-" && decl.prop[1] !== "-" && vendorPrefix(decl.prop) === "") {
          this.push(decl, {
            identifier: PROPERTY,
            hack: decl.prop
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/mediaSlash0.js
var require_mediaSlash0 = __commonJS({
  "node_modules/stylehacks/src/plugins/mediaSlash0.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_8 } = require_browsers();
    var { MEDIA_QUERY } = require_identifiers();
    var { ATRULE } = require_postcss2();
    module.exports = class MediaSlash0 extends BasePlugin {
      constructor(result) {
        super([IE_8], [ATRULE], result);
      }
      detect(rule) {
        const params = rule.params.trim();
        if (params.toLowerCase() === "\\0screen") {
          this.push(rule, {
            identifier: MEDIA_QUERY,
            hack: params
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/mediaSlash0Slash9.js
var require_mediaSlash0Slash9 = __commonJS({
  "node_modules/stylehacks/src/plugins/mediaSlash0Slash9.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6, IE_7, IE_8 } = require_browsers();
    var { MEDIA_QUERY } = require_identifiers();
    var { ATRULE } = require_postcss2();
    module.exports = class MediaSlash0Slash9 extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7, IE_8], [ATRULE], result);
      }
      detect(rule) {
        const params = rule.params.trim();
        if (params.toLowerCase() === "\\0screen\\,screen\\9") {
          this.push(rule, {
            identifier: MEDIA_QUERY,
            hack: params
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/mediaSlash9.js
var require_mediaSlash9 = __commonJS({
  "node_modules/stylehacks/src/plugins/mediaSlash9.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6, IE_7 } = require_browsers();
    var { MEDIA_QUERY } = require_identifiers();
    var { ATRULE } = require_postcss2();
    module.exports = class MediaSlash9 extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7], [ATRULE], result);
      }
      detect(rule) {
        const params = rule.params.trim();
        if (params.toLowerCase() === "screen\\9") {
          this.push(rule, {
            identifier: MEDIA_QUERY,
            hack: params
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/slash9.js
var require_slash9 = __commonJS({
  "node_modules/stylehacks/src/plugins/slash9.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var { IE_6, IE_7, IE_8 } = require_browsers();
    var { VALUE } = require_identifiers();
    var { DECL } = require_postcss2();
    module.exports = class Slash9 extends BasePlugin {
      constructor(result) {
        super([IE_6, IE_7, IE_8], [DECL], result);
      }
      detect(decl) {
        let v2 = decl.value;
        if (v2 && v2.length > 2 && v2.indexOf("\\9") === v2.length - 2) {
          this.push(decl, {
            identifier: VALUE,
            hack: v2
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/starHtml.js
var require_starHtml = __commonJS({
  "node_modules/stylehacks/src/plugins/starHtml.js"(exports, module) {
    "use strict";
    var parser = require_dist3();
    var exists = require_exists();
    var isMixin = require_isMixin();
    var BasePlugin = require_plugin();
    var { IE_5_5, IE_6 } = require_browsers();
    var { SELECTOR } = require_identifiers();
    var { RULE } = require_postcss2();
    var { HTML } = require_tags();
    module.exports = class StarHtml extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6], [RULE], result);
      }
      detect(rule) {
        if (isMixin(rule)) {
          return;
        }
        parser(this.analyse(rule)).processSync(rule.selector);
      }
      analyse(rule) {
        return (selectors) => {
          selectors.each((selector) => {
            if (exists(selector, 0, "*") && exists(selector, 1, " ") && exists(selector, 2, HTML) && exists(selector, 3, " ") && selector.at(4)) {
              this.push(rule, {
                identifier: SELECTOR,
                hack: selector.toString()
              });
            }
          });
        };
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/trailingSlashComma.js
var require_trailingSlashComma = __commonJS({
  "node_modules/stylehacks/src/plugins/trailingSlashComma.js"(exports, module) {
    "use strict";
    var BasePlugin = require_plugin();
    var isMixin = require_isMixin();
    var { IE_5_5, IE_6, IE_7 } = require_browsers();
    var { SELECTOR } = require_identifiers();
    var { RULE } = require_postcss2();
    module.exports = class TrailingSlashComma extends BasePlugin {
      constructor(result) {
        super([IE_5_5, IE_6, IE_7], [RULE], result);
      }
      detect(rule) {
        if (isMixin(rule)) {
          return;
        }
        const { selector } = rule;
        const trim = selector.trim();
        if (trim.lastIndexOf(",") === selector.length - 1 || trim.lastIndexOf("\\") === selector.length - 1) {
          this.push(rule, {
            identifier: SELECTOR,
            hack: selector
          });
        }
      }
    };
  }
});

// node_modules/stylehacks/src/plugins/index.js
var require_plugins3 = __commonJS({
  "node_modules/stylehacks/src/plugins/index.js"(exports, module) {
    "use strict";
    var bodyEmpty = require_bodyEmpty();
    var htmlCombinatorCommentBody = require_htmlCombinatorCommentBody();
    var htmlFirstChild = require_htmlFirstChild();
    var important = require_important();
    var leadingStar = require_leadingStar();
    var leadingUnderscore = require_leadingUnderscore();
    var mediaSlash0 = require_mediaSlash0();
    var mediaSlash0Slash9 = require_mediaSlash0Slash9();
    var mediaSlash9 = require_mediaSlash9();
    var slash9 = require_slash9();
    var starHtml = require_starHtml();
    var trailingSlashComma = require_trailingSlashComma();
    module.exports = [
      bodyEmpty,
      htmlCombinatorCommentBody,
      htmlFirstChild,
      important,
      leadingStar,
      leadingUnderscore,
      mediaSlash0,
      mediaSlash0Slash9,
      mediaSlash9,
      slash9,
      starHtml,
      trailingSlashComma
    ];
  }
});

// node_modules/stylehacks/src/index.js
var require_src16 = __commonJS({
  "node_modules/stylehacks/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var plugins = require_plugins3();
    function pluginCreator(opts = {}) {
      return {
        postcssPlugin: "stylehacks",
        OnceExit(css, { result }) {
          const resultOpts = result.opts || {};
          const browsers = browserslist(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
          });
          const processors = [];
          for (const Plugin of plugins) {
            const hack = new Plugin(result);
            if (!browsers.some((browser) => hack.targets.has(browser))) {
              processors.push(hack);
            }
          }
          css.walk((node) => {
            processors.forEach((proc) => {
              if (!proc.nodeTypes.has(node.type)) {
                return;
              }
              if (opts.lint) {
                return proc.detectAndWarn(node);
              }
              return proc.detectAndResolve(node);
            });
          });
        }
      };
    }
    pluginCreator.detect = (node) => {
      return plugins.some((Plugin) => {
        const hack = new Plugin();
        return hack.any(node);
      });
    };
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-merge-longhand/src/lib/insertCloned.js
var require_insertCloned = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/insertCloned.js"(exports, module) {
    "use strict";
    module.exports = function insertCloned(rule, decl, props) {
      const newNode = Object.assign(decl.clone(), props);
      rule.insertAfter(decl, newNode);
      return newNode;
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/parseTrbl.js
var require_parseTrbl = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/parseTrbl.js"(exports, module) {
    "use strict";
    var { list } = require_postcss();
    module.exports = (v2) => {
      const s2 = typeof v2 === "string" ? list.space(v2) : v2;
      return [
        s2[0],
        s2[1] || s2[0],
        s2[2] || s2[0],
        s2[3] || s2[1] || s2[0]
      ];
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/hasAllProps.js
var require_hasAllProps = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/hasAllProps.js"(exports, module) {
    "use strict";
    module.exports = (rule, ...props) => {
      return props.every(
        (p2) => rule.some((node) => node.prop && node.prop.toLowerCase().includes(p2))
      );
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/getDecls.js
var require_getDecls = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/getDecls.js"(exports, module) {
    "use strict";
    module.exports = function getDecls(rule, properties) {
      return rule.nodes.filter(
        (node) => node.type === "decl" && properties.includes(node.prop.toLowerCase())
      );
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/getLastNode.js
var require_getLastNode = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/getLastNode.js"(exports, module) {
    "use strict";
    module.exports = (rule, prop) => {
      return rule.filter((n2) => n2.type === "decl" && n2.prop.toLowerCase() === prop).pop();
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/getRules.js
var require_getRules = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/getRules.js"(exports, module) {
    "use strict";
    var getLastNode = require_getLastNode();
    module.exports = function getRules(props, properties) {
      return properties.map((property) => {
        return getLastNode(props, property);
      }).filter(Boolean);
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/getValue.js
var require_getValue2 = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/getValue.js"(exports, module) {
    "use strict";
    module.exports = function getValue({ value }) {
      return value;
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/mergeRules.js
var require_mergeRules = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/mergeRules.js"(exports, module) {
    "use strict";
    var hasAllProps = require_hasAllProps();
    var getDecls = require_getDecls();
    var getRules = require_getRules();
    function isConflictingProp(propA, propB) {
      if (!propB.prop || propB.important !== propA.important || propA.prop === propB.prop) {
        return false;
      }
      const partsA = propA.prop.split("-");
      const partsB = propB.prop.split("-");
      if (partsA[0] !== partsB[0]) {
        return false;
      }
      const partsASet = new Set(partsA);
      return partsB.every((partB) => partsASet.has(partB));
    }
    function hasConflicts(match, nodes) {
      const firstNode = Math.min(...match.map((n2) => nodes.indexOf(n2)));
      const lastNode = Math.max(...match.map((n2) => nodes.indexOf(n2)));
      const between = nodes.slice(firstNode + 1, lastNode);
      return match.some((a2) => between.some((b2) => isConflictingProp(a2, b2)));
    }
    module.exports = function mergeRules(rule, properties, callback) {
      let decls = getDecls(rule, properties);
      while (decls.length) {
        const last = decls[decls.length - 1];
        const props = decls.filter((node) => node.important === last.important);
        const rules = getRules(props, properties);
        if (hasAllProps(rules, ...properties) && !hasConflicts(
          rules,
          rule.nodes
        )) {
          if (callback(rules, last, props)) {
            decls = decls.filter((node) => !rules.includes(node));
          }
        }
        decls = decls.filter((node) => node !== last);
      }
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/minifyTrbl.js
var require_minifyTrbl = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/minifyTrbl.js"(exports, module) {
    "use strict";
    var parseTrbl = require_parseTrbl();
    module.exports = (v2) => {
      const value = parseTrbl(v2);
      if (value[3] === value[1]) {
        value.pop();
        if (value[2] === value[0]) {
          value.pop();
          if (value[0] === value[1]) {
            value.pop();
          }
        }
      }
      return value.join(" ");
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/colornames.js
var require_colornames = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/colornames.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Set([
      "aliceblue",
      "antiquewhite",
      "aqua",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "black",
      "blanchedalmond",
      "blue",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "fuchsia",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "gray",
      "green",
      "greenyellow",
      "grey",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "lime",
      "limegreen",
      "linen",
      "magenta",
      "maroon",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "navy",
      "oldlace",
      "olive",
      "olivedrab",
      "orange",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "purple",
      "rebeccapurple",
      "red",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "silver",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "teal",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "white",
      "whitesmoke",
      "yellow",
      "yellowgreen"
    ]);
  }
});

// node_modules/postcss-merge-longhand/src/lib/validateWsc.js
var require_validateWsc = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/validateWsc.js"(exports, module) {
    "use strict";
    var colors = require_colornames();
    var widths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
    var styles = /* @__PURE__ */ new Set([
      "none",
      "hidden",
      "dotted",
      "dashed",
      "solid",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset"
    ]);
    function isStyle(value) {
      return value !== void 0 && styles.has(value.toLowerCase());
    }
    function isWidth(value) {
      return value && widths.has(value.toLowerCase()) || /^(\d+(\.\d+)?|\.\d+)(\w+)?$/.test(value);
    }
    function isColor(value) {
      if (!value) {
        return false;
      }
      value = value.toLowerCase();
      if (/rgba?\(/.test(value)) {
        return true;
      }
      if (/hsla?\(/.test(value)) {
        return true;
      }
      if (/#([0-9a-z]{6}|[0-9a-z]{3})/.test(value)) {
        return true;
      }
      if (value === "transparent") {
        return true;
      }
      if (value === "currentcolor") {
        return true;
      }
      return colors.has(value);
    }
    function isValidWsc(wscs) {
      const validWidth = isWidth(wscs[0]);
      const validStyle = isStyle(wscs[1]);
      const validColor = isColor(wscs[2]);
      return validWidth && validStyle || validWidth && validColor || validStyle && validColor;
    }
    module.exports = { isStyle, isWidth, isColor, isValidWsc };
  }
});

// node_modules/postcss-merge-longhand/src/lib/parseWsc.js
var require_parseWsc = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/parseWsc.js"(exports, module) {
    "use strict";
    var { list } = require_postcss();
    var { isWidth, isStyle, isColor } = require_validateWsc();
    var none = /^\s*(none|medium)(\s+none(\s+(none|currentcolor))?)?\s*$/i;
    var varRE = /--(\w|-|[^\x00-\x7F])+/g;
    var toLower = (v2) => {
      let match;
      let lastIndex = 0;
      let result = "";
      varRE.lastIndex = 0;
      while ((match = varRE.exec(v2)) !== null) {
        if (match.index > lastIndex) {
          result += v2.substring(lastIndex, match.index).toLowerCase();
        }
        result += match[0];
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < v2.length) {
        result += v2.substring(lastIndex).toLowerCase();
      }
      if (result === "") {
        return v2;
      }
      return result;
    };
    module.exports = function parseWsc(value) {
      if (none.test(value)) {
        return ["medium", "none", "currentcolor"];
      }
      let width, style, color;
      const values = list.space(value);
      if (values.length > 1 && isStyle(values[1]) && values[0].toLowerCase() === "none") {
        values.unshift();
        width = "0";
      }
      const unknown = [];
      values.forEach((v2) => {
        if (isStyle(v2)) {
          style = toLower(v2);
        } else if (isWidth(v2)) {
          width = toLower(v2);
        } else if (isColor(v2)) {
          color = toLower(v2);
        } else {
          unknown.push(v2);
        }
      });
      if (unknown.length) {
        if (!width && style && color) {
          width = unknown.pop();
        }
        if (width && !style && color) {
          style = unknown.pop();
        }
        if (width && style && !color) {
          color = unknown.pop();
        }
      }
      return [width, style, color];
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/minifyWsc.js
var require_minifyWsc = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/minifyWsc.js"(exports, module) {
    "use strict";
    var parseWsc = require_parseWsc();
    var minifyTrbl = require_minifyTrbl();
    var { isValidWsc } = require_validateWsc();
    var defaults = ["medium", "none", "currentcolor"];
    module.exports = (v2) => {
      const values = parseWsc(v2);
      if (!isValidWsc(values)) {
        return minifyTrbl(v2);
      }
      const value = [...values, ""].reduceRight((prev, cur, i2, arr) => {
        if (cur === void 0 || cur.toLowerCase() === defaults[i2] && (!i2 || (arr[i2 - 1] || "").toLowerCase() !== cur.toLowerCase())) {
          return prev;
        }
        return cur + " " + prev;
      }).trim();
      return minifyTrbl(value || "none");
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/isCustomProp.js
var require_isCustomProp = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/isCustomProp.js"(exports, module) {
    "use strict";
    module.exports = (node) => node.value.search(/var\s*\(\s*--/i) !== -1;
  }
});

// node_modules/postcss-merge-longhand/src/lib/canMerge.js
var require_canMerge = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/canMerge.js"(exports, module) {
    "use strict";
    var isCustomProp = require_isCustomProp();
    var important = (node) => node.important;
    var unimportant = (node) => !node.important;
    var cssWideKeywords = ["inherit", "initial", "unset", "revert"];
    module.exports = (props, includeCustomProps = true) => {
      const uniqueProps = new Set(props.map((node) => node.value.toLowerCase()));
      if (uniqueProps.size > 1) {
        for (const unmergeable of cssWideKeywords) {
          if (uniqueProps.has(unmergeable)) {
            return false;
          }
        }
      }
      if (includeCustomProps && props.some(isCustomProp) && !props.every(isCustomProp)) {
        return false;
      }
      return props.every(unimportant) || props.every(important);
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/trbl.js
var require_trbl = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/trbl.js"(exports, module) {
    "use strict";
    module.exports = ["top", "right", "bottom", "left"];
  }
});

// node_modules/postcss-merge-longhand/src/lib/canExplode.js
var require_canExplode = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/canExplode.js"(exports, module) {
    "use strict";
    var isCustomProp = require_isCustomProp();
    var globalKeywords = /* @__PURE__ */ new Set(["inherit", "initial", "unset", "revert"]);
    module.exports = (prop, includeCustomProps = true) => {
      if (!prop.value || includeCustomProps && isCustomProp(prop) || prop.value && globalKeywords.has(prop.value.toLowerCase())) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/borders.js
var require_borders = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/borders.js"(exports, module) {
    "use strict";
    var { list } = require_postcss();
    var stylehacks = require_src16();
    var insertCloned = require_insertCloned();
    var parseTrbl = require_parseTrbl();
    var hasAllProps = require_hasAllProps();
    var getDecls = require_getDecls();
    var getRules = require_getRules();
    var getValue = require_getValue2();
    var mergeRules = require_mergeRules();
    var minifyTrbl = require_minifyTrbl();
    var minifyWsc = require_minifyWsc();
    var canMerge = require_canMerge();
    var trbl = require_trbl();
    var isCustomProp = require_isCustomProp();
    var canExplode = require_canExplode();
    var getLastNode = require_getLastNode();
    var parseWsc = require_parseWsc();
    var { isValidWsc } = require_validateWsc();
    var wsc = ["width", "style", "color"];
    var defaults = ["medium", "none", "currentcolor"];
    var colorMightRequireFallback = /(hsla|rgba|color|hwb|lab|lch|oklab|oklch)\(/i;
    function borderProperty(...parts) {
      return `border-${parts.join("-")}`;
    }
    function mapBorderProperty(value) {
      return borderProperty(value);
    }
    var directions = trbl.map(mapBorderProperty);
    var properties = wsc.map(mapBorderProperty);
    var directionalProperties = directions.reduce(
      (prev, curr) => prev.concat(wsc.map((prop) => `${curr}-${prop}`)),
      []
    );
    var precedence = [
      ["border"],
      directions.concat(properties),
      directionalProperties
    ];
    var allProperties = precedence.reduce((a2, b2) => a2.concat(b2));
    function getLevel(prop) {
      for (let i2 = 0; i2 < precedence.length; i2++) {
        if (precedence[i2].includes(prop.toLowerCase())) {
          return i2;
        }
      }
    }
    var isValueCustomProp = (value) => value !== void 0 && value.search(/var\s*\(\s*--/i) !== -1;
    function canMergeValues(values) {
      return !values.some(isValueCustomProp);
    }
    function getColorValue(decl) {
      if (decl.prop.substr(-5) === "color") {
        return decl.value;
      }
      return parseWsc(decl.value)[2] || defaults[2];
    }
    function diffingProps(values, nextValues) {
      return wsc.reduce((prev, curr, i2) => {
        if (values[i2] === nextValues[i2]) {
          return prev;
        }
        return [...prev, curr];
      }, []);
    }
    function mergeRedundant({ values, nextValues, decl, nextDecl, index }) {
      if (!canMerge([decl, nextDecl])) {
        return;
      }
      if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {
        return;
      }
      const diff = diffingProps(values, nextValues);
      if (diff.length !== 1) {
        return;
      }
      const prop = diff.pop();
      const position = wsc.indexOf(prop);
      const prop1 = `${nextDecl.prop}-${prop}`;
      const prop2 = `border-${prop}`;
      let props = parseTrbl(values[position]);
      props[index] = nextValues[position];
      const borderValue2 = values.filter((e2, i2) => i2 !== position).join(" ");
      const propValue2 = minifyTrbl(props);
      const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value).length;
      const newLength1 = decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;
      const newLength2 = borderValue2.length + prop2.length + propValue2.length;
      if (newLength1 < newLength2 && newLength1 < origLength) {
        nextDecl.prop = prop1;
        nextDecl.value = nextValues[position];
      }
      if (newLength2 < newLength1 && newLength2 < origLength) {
        decl.value = borderValue2;
        nextDecl.prop = prop2;
        nextDecl.value = propValue2;
      }
    }
    function isCloseEnough(mapped) {
      return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
    }
    function getDistinctShorthands(mapped) {
      return [...new Set(mapped)];
    }
    function explode(rule) {
      rule.walkDecls(/^border/i, (decl) => {
        if (!canExplode(decl, false)) {
          return;
        }
        if (stylehacks.detect(decl)) {
          return;
        }
        const prop = decl.prop.toLowerCase();
        if (prop === "border") {
          if (isValidWsc(parseWsc(decl.value))) {
            directions.forEach((direction) => {
              insertCloned(
                decl.parent,
                decl,
                { prop: direction }
              );
            });
            decl.remove();
          }
        }
        if (directions.some((direction) => prop === direction)) {
          let values = parseWsc(decl.value);
          if (isValidWsc(values)) {
            wsc.forEach((d2, i2) => {
              insertCloned(
                decl.parent,
                decl,
                {
                  prop: `${prop}-${d2}`,
                  value: values[i2] || defaults[i2]
                }
              );
            });
            decl.remove();
          }
        }
        wsc.some((style) => {
          if (prop !== borderProperty(style)) {
            return false;
          }
          if (isCustomProp(decl)) {
            decl.prop = decl.prop.toLowerCase();
            return false;
          }
          parseTrbl(decl.value).forEach((value, i2) => {
            insertCloned(
              decl.parent,
              decl,
              {
                prop: borderProperty(trbl[i2], style),
                value
              }
            );
          });
          return decl.remove();
        });
      });
    }
    function merge(rule) {
      trbl.forEach((direction) => {
        const prop = borderProperty(direction);
        mergeRules(
          rule,
          wsc.map((style) => borderProperty(direction, style)),
          (rules, lastNode) => {
            if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {
              insertCloned(
                lastNode.parent,
                lastNode,
                {
                  prop,
                  value: rules.map(getValue).join(" ")
                }
              );
              for (const node of rules) {
                node.remove();
              }
              return true;
            }
            return false;
          }
        );
      });
      wsc.forEach((style) => {
        const prop = borderProperty(style);
        mergeRules(
          rule,
          trbl.map((direction) => borderProperty(direction, style)),
          (rules, lastNode) => {
            if (canMerge(rules) && !rules.some(stylehacks.detect)) {
              insertCloned(
                lastNode.parent,
                lastNode,
                {
                  prop,
                  value: minifyTrbl(rules.map(getValue).join(" "))
                }
              );
              for (const node of rules) {
                node.remove();
              }
              return true;
            }
            return false;
          }
        );
      });
      mergeRules(rule, directions, (rules, lastNode) => {
        if (rules.some(stylehacks.detect)) {
          return false;
        }
        const values = rules.map(({ value }) => value);
        if (!canMergeValues(values)) {
          return false;
        }
        const parsed = values.map((value) => parseWsc(value));
        if (!parsed.every(isValidWsc)) {
          return false;
        }
        wsc.forEach((d2, i2) => {
          const value = parsed.map((v2) => v2[i2] || defaults[i2]);
          if (canMergeValues(value)) {
            insertCloned(
              lastNode.parent,
              lastNode,
              {
                prop: borderProperty(d2),
                value: minifyTrbl(
                  value
                )
              }
            );
          } else {
            insertCloned(
              lastNode.parent,
              lastNode
            );
          }
        });
        for (const node of rules) {
          node.remove();
        }
        return true;
      });
      mergeRules(rule, properties, (rules, lastNode) => {
        if (rules.some(stylehacks.detect)) {
          return false;
        }
        const values = rules.map((node) => parseTrbl(node.value));
        const mapped = [0, 1, 2, 3].map(
          (i2) => [values[0][i2], values[1][i2], values[2][i2]].join(" ")
        );
        if (!canMergeValues(mapped)) {
          return false;
        }
        const [width, style, color] = rules;
        const reduced = getDistinctShorthands(mapped);
        if (isCloseEnough(mapped) && canMerge(rules, false)) {
          const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);
          const border = insertCloned(
            lastNode.parent,
            lastNode,
            {
              prop: "border",
              value: first ? reduced[0] : reduced[1]
            }
          );
          if (reduced[1]) {
            const value = first ? reduced[1] : reduced[0];
            const prop = borderProperty(trbl[mapped.indexOf(value)]);
            rule.insertAfter(
              border,
              Object.assign(lastNode.clone(), {
                prop,
                value
              })
            );
          }
          for (const node of rules) {
            node.remove();
          }
          return true;
        } else if (reduced.length === 1) {
          rule.insertBefore(
            color,
            Object.assign(lastNode.clone(), {
              prop: "border",
              value: [width, style].map(getValue).join(" ")
            })
          );
          rules.filter((node) => node.prop.toLowerCase() !== properties[2]).forEach((node) => node.remove());
          return true;
        }
        return false;
      });
      mergeRules(rule, properties, (rules, lastNode) => {
        if (rules.some(stylehacks.detect)) {
          return false;
        }
        const values = rules.map((node) => parseTrbl(node.value));
        const mapped = [0, 1, 2, 3].map(
          (i2) => [values[0][i2], values[1][i2], values[2][i2]].join(" ")
        );
        const reduced = getDistinctShorthands(mapped);
        const none = "medium none currentcolor";
        if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
          const filtered = mapped.filter((p2) => p2 !== none);
          const mostCommon = reduced.sort(
            (a2, b2) => mapped.filter((v2) => v2 === b2).length - mapped.filter((v2) => v2 === a2).length
          )[0];
          const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;
          rule.insertBefore(
            lastNode,
            Object.assign(lastNode.clone(), {
              prop: "border",
              value: borderValue
            })
          );
          directions.forEach((dir, i2) => {
            if (mapped[i2] !== borderValue) {
              rule.insertBefore(
                lastNode,
                Object.assign(lastNode.clone(), {
                  prop: dir,
                  value: mapped[i2]
                })
              );
            }
          });
          for (const node of rules) {
            node.remove();
          }
          return true;
        }
        return false;
      });
      mergeRules(rule, directions, (rules, lastNode) => {
        if (rules.some(stylehacks.detect)) {
          return false;
        }
        const values = rules.map((node) => {
          const wscValue = parseWsc(node.value);
          if (!isValidWsc(wscValue)) {
            return node.value;
          }
          return wscValue.map((value, i2) => value || defaults[i2]).join(" ");
        });
        const reduced = getDistinctShorthands(values);
        if (isCloseEnough(values)) {
          const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);
          rule.insertBefore(
            lastNode,
            Object.assign(lastNode.clone(), {
              prop: "border",
              value: minifyWsc(first ? values[0] : values[1])
            })
          );
          if (reduced[1]) {
            const value = first ? reduced[1] : reduced[0];
            const prop = directions[values.indexOf(value)];
            rule.insertBefore(
              lastNode,
              Object.assign(lastNode.clone(), {
                prop,
                value: minifyWsc(value)
              })
            );
          }
          for (const node of rules) {
            node.remove();
          }
          return true;
        }
        return false;
      });
      directions.forEach((direction) => {
        wsc.forEach((style, i2) => {
          const prop = `${direction}-${style}`;
          mergeRules(rule, [direction, prop], (rules, lastNode) => {
            if (lastNode.prop !== direction) {
              return false;
            }
            const values = parseWsc(lastNode.value);
            if (!isValidWsc(values)) {
              return false;
            }
            const wscProp = rules.filter((r2) => r2 !== lastNode)[0];
            if (!isValueCustomProp(values[i2]) || isCustomProp(wscProp)) {
              return false;
            }
            const wscValue = values[i2];
            values[i2] = wscProp.value;
            if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {
              insertCloned(
                lastNode.parent,
                lastNode,
                {
                  prop,
                  value: wscValue
                }
              );
              lastNode.value = minifyWsc(values);
              wscProp.remove();
              return true;
            }
            return false;
          });
        });
      });
      wsc.forEach((style, i2) => {
        const prop = borderProperty(style);
        mergeRules(rule, ["border", prop], (rules, lastNode) => {
          if (lastNode.prop !== "border") {
            return false;
          }
          const values = parseWsc(lastNode.value);
          if (!isValidWsc(values)) {
            return false;
          }
          const wscProp = rules.filter((r2) => r2 !== lastNode)[0];
          if (!isValueCustomProp(values[i2]) || isCustomProp(wscProp)) {
            return false;
          }
          const wscValue = values[i2];
          values[i2] = wscProp.value;
          if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {
            insertCloned(
              lastNode.parent,
              lastNode,
              {
                prop,
                value: wscValue
              }
            );
            lastNode.value = minifyWsc(values);
            wscProp.remove();
            return true;
          }
          return false;
        });
      });
      let decls = getDecls(rule, directions);
      while (decls.length) {
        const lastNode = decls[decls.length - 1];
        wsc.forEach((d2, i2) => {
          const names = directions.filter((name) => name !== lastNode.prop).map((name) => `${name}-${d2}`);
          let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));
          const border = getLastNode(nodes, "border");
          if (border) {
            nodes = nodes.slice(nodes.indexOf(border));
          }
          const props = nodes.filter(
            (node) => node.type === "decl" && names.includes(node.prop) && node.important === lastNode.important
          );
          const rules = getRules(
            props,
            names
          );
          if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {
            const values = rules.map((node) => node ? node.value : null);
            const filteredValues = values.filter(Boolean);
            const lastNodeValue = list.space(lastNode.value)[i2];
            values[directions.indexOf(lastNode.prop)] = lastNodeValue;
            let value = minifyTrbl(values.join(" "));
            if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
              value = filteredValues[0];
            }
            let refNode = props[props.length - 1];
            if (value === lastNodeValue) {
              refNode = lastNode;
              let valueArray = list.space(lastNode.value);
              valueArray.splice(i2, 1);
              lastNode.value = valueArray.join(" ");
            }
            insertCloned(
              refNode.parent,
              refNode,
              {
                prop: borderProperty(d2),
                value
              }
            );
            decls = decls.filter((node) => !rules.includes(node));
            for (const node of rules) {
              node.remove();
            }
          }
        });
        decls = decls.filter((node) => node !== lastNode);
      }
      rule.walkDecls("border", (decl) => {
        const nextDecl = decl.next();
        if (!nextDecl || nextDecl.type !== "decl") {
          return false;
        }
        const index = directions.indexOf(nextDecl.prop);
        if (index === -1) {
          return;
        }
        const values = parseWsc(decl.value);
        const nextValues = parseWsc(nextDecl.value);
        if (!isValidWsc(values) || !isValidWsc(nextValues)) {
          return;
        }
        const config = {
          values,
          nextValues,
          decl,
          nextDecl,
          index
        };
        return mergeRedundant(config);
      });
      rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {
        let values = parseWsc(decl.value);
        if (!isValidWsc(values)) {
          return;
        }
        const position = directions.indexOf(decl.prop);
        let dirs = [...directions];
        dirs.splice(position, 1);
        wsc.forEach((d2, i2) => {
          const props = dirs.map((dir) => `${dir}-${d2}`);
          mergeRules(rule, [decl.prop, ...props], (rules) => {
            if (!rules.includes(decl)) {
              return false;
            }
            const longhands = rules.filter((p2) => p2 !== decl);
            if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && values[i2] !== void 0 && longhands[0].value.toLowerCase() === values[i2].toLowerCase()) {
              for (const node of longhands) {
                node.remove();
              }
              insertCloned(
                decl.parent,
                decl,
                {
                  prop: borderProperty(d2),
                  value: values[i2]
                }
              );
              values[i2] = null;
            }
            return false;
          });
          const newValue = values.join(" ");
          if (newValue) {
            decl.value = newValue;
          } else {
            decl.remove();
          }
        });
      });
      rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {
        decl.value = minifyWsc(decl.value);
      });
      rule.walkDecls(/^border-spacing$/i, (decl) => {
        const value = list.space(decl.value);
        if (value.length > 1 && value[0] === value[1]) {
          decl.value = value.slice(1).join(" ");
        }
      });
      decls = getDecls(rule, allProperties);
      while (decls.length) {
        const lastNode = decls[decls.length - 1];
        const lastPart = lastNode.prop.split("-").pop();
        const lesser = decls.filter(
          (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && !isCustomProp(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (node.prop.toLowerCase().includes(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart))
        );
        for (const node of lesser) {
          node.remove();
        }
        decls = decls.filter((node) => !lesser.includes(node));
        let duplicates = decls.filter(
          (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode))
        );
        if (duplicates.length) {
          if (colorMightRequireFallback.test(getColorValue(lastNode))) {
            const preserve = duplicates.filter(
              (node) => !colorMightRequireFallback.test(getColorValue(node))
            ).pop();
            duplicates = duplicates.filter((node) => node !== preserve);
          }
          for (const node of duplicates) {
            node.remove();
          }
        }
        decls = decls.filter(
          (node) => node !== lastNode && !duplicates.includes(node)
        );
      }
    }
    module.exports = {
      explode,
      merge
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/columns.js
var require_columns2 = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/columns.js"(exports, module) {
    "use strict";
    var { list } = require_postcss();
    var { unit } = require_lib();
    var stylehacks = require_src16();
    var canMerge = require_canMerge();
    var getDecls = require_getDecls();
    var getValue = require_getValue2();
    var mergeRules = require_mergeRules();
    var insertCloned = require_insertCloned();
    var isCustomProp = require_isCustomProp();
    var canExplode = require_canExplode();
    var properties = ["column-width", "column-count"];
    var auto = "auto";
    var inherit = "inherit";
    function normalize(values) {
      if (values[0].toLowerCase() === auto) {
        return values[1];
      }
      if (values[1].toLowerCase() === auto) {
        return values[0];
      }
      if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {
        return inherit;
      }
      return values.join(" ");
    }
    function explode(rule) {
      rule.walkDecls(/^columns$/i, (decl) => {
        if (!canExplode(decl)) {
          return;
        }
        if (stylehacks.detect(decl)) {
          return;
        }
        let values = list.space(decl.value);
        if (values.length === 1) {
          values.push(auto);
        }
        values.forEach((value, i2) => {
          let prop = properties[1];
          const dimension = unit(value);
          if (value.toLowerCase() === auto) {
            prop = properties[i2];
          } else if (dimension && dimension.unit !== "") {
            prop = properties[0];
          }
          insertCloned(decl.parent, decl, {
            prop,
            value
          });
        });
        decl.remove();
      });
    }
    function cleanup(rule) {
      let decls = getDecls(rule, ["columns"].concat(properties));
      while (decls.length) {
        const lastNode = decls[decls.length - 1];
        const lesser = decls.filter(
          (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === "columns" && node.prop !== lastNode.prop
        );
        for (const node of lesser) {
          node.remove();
        }
        decls = decls.filter((node) => !lesser.includes(node));
        let duplicates = decls.filter(
          (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode))
        );
        for (const node of duplicates) {
          node.remove();
        }
        decls = decls.filter(
          (node) => node !== lastNode && !duplicates.includes(node)
        );
      }
    }
    function merge(rule) {
      mergeRules(rule, properties, (rules, lastNode) => {
        if (canMerge(rules) && !rules.some(stylehacks.detect)) {
          insertCloned(
            lastNode.parent,
            lastNode,
            {
              prop: "columns",
              value: normalize(rules.map(getValue))
            }
          );
          for (const node of rules) {
            node.remove();
          }
          return true;
        }
        return false;
      });
      cleanup(rule);
    }
    module.exports = {
      explode,
      merge
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/mergeValues.js
var require_mergeValues = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/mergeValues.js"(exports, module) {
    "use strict";
    var getValue = require_getValue2();
    module.exports = (...rules) => rules.map(getValue).join(" ");
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/boxBase.js
var require_boxBase = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/boxBase.js"(exports, module) {
    "use strict";
    var stylehacks = require_src16();
    var canMerge = require_canMerge();
    var getDecls = require_getDecls();
    var minifyTrbl = require_minifyTrbl();
    var parseTrbl = require_parseTrbl();
    var insertCloned = require_insertCloned();
    var mergeRules = require_mergeRules();
    var mergeValues = require_mergeValues();
    var trbl = require_trbl();
    var isCustomProp = require_isCustomProp();
    var canExplode = require_canExplode();
    module.exports = (prop) => {
      const properties = trbl.map((direction) => `${prop}-${direction}`);
      const cleanup = (rule) => {
        let decls = getDecls(rule, [prop].concat(properties));
        while (decls.length) {
          const lastNode = decls[decls.length - 1];
          const lesser = decls.filter(
            (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop
          );
          for (const node of lesser) {
            node.remove();
          }
          decls = decls.filter((node) => !lesser.includes(node));
          let duplicates = decls.filter(
            (node) => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode))
          );
          for (const node of duplicates) {
            node.remove();
          }
          decls = decls.filter(
            (node) => node !== lastNode && !duplicates.includes(node)
          );
        }
      };
      const processor = {
        explode: (rule) => {
          rule.walkDecls(new RegExp("^" + prop + "$", "i"), (decl) => {
            if (!canExplode(decl)) {
              return;
            }
            if (stylehacks.detect(decl)) {
              return;
            }
            const values = parseTrbl(decl.value);
            trbl.forEach((direction, index) => {
              insertCloned(
                decl.parent,
                decl,
                {
                  prop: properties[index],
                  value: values[index]
                }
              );
            });
            decl.remove();
          });
        },
        merge: (rule) => {
          mergeRules(rule, properties, (rules, lastNode) => {
            if (canMerge(rules) && !rules.some(stylehacks.detect)) {
              insertCloned(
                lastNode.parent,
                lastNode,
                {
                  prop,
                  value: minifyTrbl(mergeValues(...rules))
                }
              );
              for (const node of rules) {
                node.remove();
              }
              return true;
            }
            return false;
          });
          cleanup(rule);
        }
      };
      return processor;
    };
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/margin.js
var require_margin = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/margin.js"(exports, module) {
    "use strict";
    var base = require_boxBase();
    module.exports = base("margin");
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/padding.js
var require_padding = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/padding.js"(exports, module) {
    "use strict";
    var base = require_boxBase();
    module.exports = base("padding");
  }
});

// node_modules/postcss-merge-longhand/src/lib/decl/index.js
var require_decl = __commonJS({
  "node_modules/postcss-merge-longhand/src/lib/decl/index.js"(exports, module) {
    "use strict";
    var borders = require_borders();
    var columns = require_columns2();
    var margin = require_margin();
    var padding = require_padding();
    module.exports = [borders, columns, margin, padding];
  }
});

// node_modules/postcss-merge-longhand/src/index.js
var require_src17 = __commonJS({
  "node_modules/postcss-merge-longhand/src/index.js"(exports, module) {
    "use strict";
    var processors = require_decl();
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-merge-longhand",
        OnceExit(css) {
          css.walkRules((rule) => {
            processors.forEach((p2) => {
              p2.explode(rule);
              p2.merge(rule);
            });
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-discard-duplicates/src/index.js
var require_src18 = __commonJS({
  "node_modules/postcss-discard-duplicates/src/index.js"(exports, module) {
    "use strict";
    function trimValue(value) {
      return value ? value.trim() : value;
    }
    function empty(node) {
      return !node.nodes.filter((child) => child.type !== "comment").length;
    }
    function equals(nodeA, nodeB) {
      const a2 = nodeA;
      const b2 = nodeB;
      if (a2.type !== b2.type) {
        return false;
      }
      if (a2.important !== b2.important) {
        return false;
      }
      if (a2.raws && !b2.raws || !a2.raws && b2.raws) {
        return false;
      }
      switch (a2.type) {
        case "rule":
          if (a2.selector !== b2.selector) {
            return false;
          }
          break;
        case "atrule":
          if (a2.name !== b2.name || a2.params !== b2.params) {
            return false;
          }
          if (a2.raws && trimValue(a2.raws.before) !== trimValue(b2.raws.before)) {
            return false;
          }
          if (a2.raws && trimValue(a2.raws.afterName) !== trimValue(b2.raws.afterName)) {
            return false;
          }
          break;
        case "decl":
          if (a2.prop !== b2.prop || a2.value !== b2.value) {
            return false;
          }
          if (a2.raws && trimValue(a2.raws.before) !== trimValue(b2.raws.before)) {
            return false;
          }
          break;
      }
      if (a2.nodes) {
        if (a2.nodes.length !== b2.nodes.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.nodes.length; i2++) {
          if (!equals(a2.nodes[i2], b2.nodes[i2])) {
            return false;
          }
        }
      }
      return true;
    }
    function dedupeRule(last, nodes) {
      let index = nodes.indexOf(last) - 1;
      while (index >= 0) {
        const node = nodes[index--];
        if (node && node.type === "rule" && node.selector === last.selector) {
          last.each((child) => {
            if (child.type === "decl") {
              dedupeNode(child, node.nodes);
            }
          });
          if (empty(node)) {
            node.remove();
          }
        }
      }
    }
    function dedupeNode(last, nodes) {
      let index = nodes.includes(last) ? nodes.indexOf(last) - 1 : nodes.length - 1;
      while (index >= 0) {
        const node = nodes[index--];
        if (node && equals(node, last)) {
          node.remove();
        }
      }
    }
    function dedupe(root) {
      const { nodes } = root;
      if (!nodes) {
        return;
      }
      let index = nodes.length - 1;
      while (index >= 0) {
        let last = nodes[index--];
        if (!last || !last.parent) {
          continue;
        }
        dedupe(last);
        if (last.type === "rule") {
          dedupeRule(last, nodes);
        } else if (last.type === "atrule" || last.type === "decl") {
          dedupeNode(last, nodes);
        }
      }
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-discard-duplicates",
        OnceExit(css) {
          dedupe(css);
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-discard-overridden/src/index.js
var require_src19 = __commonJS({
  "node_modules/postcss-discard-overridden/src/index.js"(exports, module) {
    "use strict";
    var OVERRIDABLE_RULES = /* @__PURE__ */ new Set(["keyframes", "counter-style"]);
    var SCOPE_RULES = /* @__PURE__ */ new Set(["media", "supports"]);
    function vendorUnprefixed(prop) {
      return prop.replace(/^-\w+-/, "");
    }
    function isOverridable(name) {
      return OVERRIDABLE_RULES.has(vendorUnprefixed(name.toLowerCase()));
    }
    function isScope(name) {
      return SCOPE_RULES.has(vendorUnprefixed(name.toLowerCase()));
    }
    function getScope(node) {
      let current = node.parent;
      const chain = [node.name.toLowerCase(), node.params];
      while (current) {
        if (current.type === "atrule" && isScope(current.name)) {
          chain.unshift(
            current.name + " " + current.params
          );
        }
        current = current.parent;
      }
      return chain.join("|");
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-discard-overridden",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          const rules = [];
          return {
            OnceExit(css) {
              css.walkAtRules((node) => {
                if (isOverridable(node.name)) {
                  const scope = getScope(node);
                  cache.set(scope, node);
                  rules.push({
                    node,
                    scope
                  });
                }
              });
              rules.forEach((rule) => {
                if (cache.get(rule.scope) !== rule.node) {
                  rule.node.remove();
                }
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-repeat-style/src/lib/map.js
var require_map = __commonJS({
  "node_modules/postcss-normalize-repeat-style/src/lib/map.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ new Map([
      [["repeat", "no-repeat"].toString(), "repeat-x"],
      [["no-repeat", "repeat"].toString(), "repeat-y"],
      [["repeat", "repeat"].toString(), "repeat"],
      [["space", "space"].toString(), "space"],
      [["round", "round"].toString(), "round"],
      [["no-repeat", "no-repeat"].toString(), "no-repeat"]
    ]);
  }
});

// node_modules/postcss-normalize-repeat-style/src/index.js
var require_src20 = __commonJS({
  "node_modules/postcss-normalize-repeat-style/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var mappings = require_map();
    function evenValues(item, index) {
      return index % 2 === 0;
    }
    var repeatKeywords = new Set(mappings.values());
    function isCommaNode(node) {
      return node.type === "div" && node.value === ",";
    }
    var variableFunctions = /* @__PURE__ */ new Set(["var", "env", "constant"]);
    function isVariableFunctionNode(node) {
      if (node.type !== "function") {
        return false;
      }
      return variableFunctions.has(node.value.toLowerCase());
    }
    function transform(value) {
      const parsed = valueParser(value);
      if (parsed.nodes.length === 1) {
        return value;
      }
      const ranges = [];
      let rangeIndex = 0;
      let shouldContinue = true;
      parsed.nodes.forEach((node, index) => {
        if (isCommaNode(node)) {
          rangeIndex += 1;
          shouldContinue = true;
          return;
        }
        if (!shouldContinue) {
          return;
        }
        if (node.type === "div" && node.value === "/") {
          shouldContinue = false;
          return;
        }
        if (!ranges[rangeIndex]) {
          ranges[rangeIndex] = {
            start: null,
            end: null
          };
        }
        if (isVariableFunctionNode(node)) {
          shouldContinue = false;
          ranges[rangeIndex].start = null;
          ranges[rangeIndex].end = null;
          return;
        }
        const isRepeatKeyword = node.type === "word" && repeatKeywords.has(node.value.toLowerCase());
        if (ranges[rangeIndex].start === null && isRepeatKeyword) {
          ranges[rangeIndex].start = index;
          ranges[rangeIndex].end = index;
          return;
        }
        if (ranges[rangeIndex].start !== null) {
          if (node.type === "space") {
            return;
          } else if (isRepeatKeyword) {
            ranges[rangeIndex].end = index;
            return;
          }
          return;
        }
      });
      ranges.forEach((range) => {
        if (range.start === null) {
          return;
        }
        const nodes = parsed.nodes.slice(
          range.start,
          range.end + 1
        );
        if (nodes.length !== 3) {
          return;
        }
        const key = nodes.filter(evenValues).map((n2) => n2.value.toLowerCase()).toString();
        const match = mappings.get(key);
        if (match) {
          nodes[0].value = match;
          nodes[1].value = nodes[2].value = "";
        }
      });
      return parsed.toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-repeat-style",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkDecls(
                /^(background(-repeat)?|(-\w+-)?mask-repeat)$/i,
                (decl) => {
                  const value = decl.value;
                  if (!value) {
                    return;
                  }
                  if (cache.has(value)) {
                    decl.value = cache.get(value);
                    return;
                  }
                  const result = transform(value);
                  decl.value = result;
                  cache.set(value, result);
                }
              );
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-merge-rules/src/lib/ensureCompatibility.js
var require_ensureCompatibility = __commonJS({
  "node_modules/postcss-merge-rules/src/lib/ensureCompatibility.js"(exports, module) {
    "use strict";
    var { isSupported } = require_dist2();
    var selectorParser = require_dist3();
    var simpleSelectorRe = /^#?[-._a-z0-9 ]+$/i;
    var cssSel2 = "css-sel2";
    var cssSel3 = "css-sel3";
    var cssGencontent = "css-gencontent";
    var cssFirstLetter = "css-first-letter";
    var cssFirstLine = "css-first-line";
    var cssInOutOfRange = "css-in-out-of-range";
    var formValidation = "form-validation";
    var vendorPrefix = /-(ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)-/;
    var level2Sel = /* @__PURE__ */ new Set(["=", "~=", "|="]);
    var level3Sel = /* @__PURE__ */ new Set(["^=", "$=", "*="]);
    function filterPrefixes(selector) {
      return selector.match(vendorPrefix);
    }
    var findMsInputPlaceholder = (selector) => ~selector.search(/-ms-input-placeholder/i);
    function sameVendor(selectorsA, selectorsB) {
      let same = (selectors) => selectors.map(filterPrefixes).join();
      let findMsVendor = (selectors) => selectors.find(findMsInputPlaceholder);
      return same(selectorsA) === same(selectorsB) && !(findMsVendor(selectorsA) && findMsVendor(selectorsB));
    }
    function noVendor(selector) {
      return !vendorPrefix.test(selector);
    }
    var pseudoElements = {
      ":active": cssSel2,
      ":after": cssGencontent,
      ":any-link": "css-any-link",
      ":before": cssGencontent,
      ":checked": cssSel3,
      ":default": "css-default-pseudo",
      ":dir": "css-dir-pseudo",
      ":disabled": cssSel3,
      ":empty": cssSel3,
      ":enabled": cssSel3,
      ":first-child": cssSel2,
      ":first-letter": cssFirstLetter,
      ":first-line": cssFirstLine,
      ":first-of-type": cssSel3,
      ":focus": cssSel2,
      ":focus-within": "css-focus-within",
      ":focus-visible": "css-focus-visible",
      ":has": "css-has",
      ":hover": cssSel2,
      ":in-range": cssInOutOfRange,
      ":indeterminate": "css-indeterminate-pseudo",
      ":invalid": formValidation,
      ":is": "css-matches-pseudo",
      ":lang": cssSel2,
      ":last-child": cssSel3,
      ":last-of-type": cssSel3,
      ":link": cssSel2,
      ":matches": "css-matches-pseudo",
      ":not": cssSel3,
      ":nth-child": cssSel3,
      ":nth-last-child": cssSel3,
      ":nth-last-of-type": cssSel3,
      ":nth-of-type": cssSel3,
      ":only-child": cssSel3,
      ":only-of-type": cssSel3,
      ":optional": "css-optional-pseudo",
      ":out-of-range": cssInOutOfRange,
      ":placeholder-shown": "css-placeholder-shown",
      ":required": formValidation,
      ":root": cssSel3,
      ":target": cssSel3,
      "::after": cssGencontent,
      "::backdrop": "dialog",
      "::before": cssGencontent,
      "::first-letter": cssFirstLetter,
      "::first-line": cssFirstLine,
      "::marker": "css-marker-pseudo",
      "::placeholder": "css-placeholder",
      "::selection": "css-selection",
      ":valid": formValidation,
      ":visited": cssSel2
    };
    function isCssMixin(selector) {
      return selector[selector.length - 1] === ":";
    }
    function isHostPseudoClass(selector) {
      return selector.includes(":host");
    }
    var isSupportedCache = /* @__PURE__ */ new Map();
    function isSupportedCached(feature, browsers) {
      const key = JSON.stringify({ feature, browsers });
      let result = isSupportedCache.get(key);
      if (!result) {
        result = isSupported(feature, browsers);
        isSupportedCache.set(key, result);
      }
      return result;
    }
    function ensureCompatibility(selectors, browsers, compatibilityCache) {
      if (selectors.some(isCssMixin)) {
        return false;
      }
      if (selectors.some(isHostPseudoClass)) {
        return false;
      }
      return selectors.every((selector) => {
        if (simpleSelectorRe.test(selector)) {
          return true;
        }
        if (compatibilityCache && compatibilityCache.has(selector)) {
          return compatibilityCache.get(selector);
        }
        let compatible = true;
        selectorParser((ast) => {
          ast.walk((node) => {
            const { type, value } = node;
            if (type === "pseudo") {
              const entry = pseudoElements[value];
              if (!entry && noVendor(value)) {
                compatible = false;
              }
              if (entry && compatible) {
                compatible = isSupportedCached(entry, browsers);
              }
            }
            if (type === "combinator") {
              if (value.includes("~")) {
                compatible = isSupportedCached(cssSel3, browsers);
              }
              if (value.includes(">") || value.includes("+")) {
                compatible = isSupportedCached(cssSel2, browsers);
              }
            }
            if (type === "attribute" && node.attribute) {
              if (!node.operator) {
                compatible = isSupportedCached(cssSel2, browsers);
              }
              if (value) {
                if (level2Sel.has(node.operator)) {
                  compatible = isSupportedCached(cssSel2, browsers);
                }
                if (level3Sel.has(node.operator)) {
                  compatible = isSupportedCached(cssSel3, browsers);
                }
              }
              if (node.insensitive) {
                compatible = isSupportedCached("css-case-insensitive", browsers);
              }
            }
            if (!compatible) {
              return false;
            }
          });
        }).processSync(selector);
        if (compatibilityCache) {
          compatibilityCache.set(selector, compatible);
        }
        return compatible;
      });
    }
    module.exports = { sameVendor, noVendor, pseudoElements, ensureCompatibility };
  }
});

// node_modules/postcss-merge-rules/src/index.js
var require_src21 = __commonJS({
  "node_modules/postcss-merge-rules/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var { sameParent } = require_src3();
    var {
      ensureCompatibility,
      sameVendor,
      noVendor
    } = require_ensureCompatibility();
    function declarationIsEqual(a2, b2) {
      return a2.important === b2.important && a2.prop === b2.prop && a2.value === b2.value;
    }
    function indexOfDeclaration(array, decl) {
      return array.findIndex((d2) => declarationIsEqual(d2, decl));
    }
    function intersect(a2, b2, not) {
      return a2.filter((c2) => {
        const index = indexOfDeclaration(b2, c2) !== -1;
        return not ? !index : index;
      });
    }
    function sameDeclarationsAndOrder(a2, b2) {
      if (a2.length !== b2.length) {
        return false;
      }
      return a2.every((d2, index) => declarationIsEqual(d2, b2[index]));
    }
    function canMerge(ruleA, ruleB, browsers, compatibilityCache) {
      const a2 = ruleA.selectors;
      const b2 = ruleB.selectors;
      const selectors = a2.concat(b2);
      if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {
        return false;
      }
      const parent = sameParent(
        ruleA,
        ruleB
      );
      if (parent && ruleA.parent && ruleA.parent.type === "atrule" && ruleA.parent.name.includes(
        "keyframes"
      )) {
        return false;
      }
      return parent && (selectors.every(noVendor) || sameVendor(a2, b2));
    }
    function isDeclaration(node) {
      return node.type === "decl";
    }
    function getDecls(rule) {
      return rule.nodes.filter(isDeclaration);
    }
    var joinSelectors = (...rules) => rules.map((s2) => s2.selector).join();
    function ruleLength(...rules) {
      return rules.map((r2) => r2.nodes.length ? String(r2) : "").join("").length;
    }
    function splitProp(prop) {
      const parts = prop.split("-");
      if (prop[0] !== "-") {
        return {
          prefix: "",
          base: parts[0],
          rest: parts.slice(1)
        };
      }
      if (prop[1] === "-") {
        return {
          prefix: null,
          base: null,
          rest: [prop]
        };
      }
      return {
        prefix: parts[1],
        base: parts[2],
        rest: parts.slice(3)
      };
    }
    function isConflictingProp(propA, propB) {
      if (propA === propB) {
        return true;
      }
      const a2 = splitProp(propA);
      const b2 = splitProp(propB);
      if (!a2.base && !b2.base) {
        return true;
      }
      if (a2.base !== b2.base) {
        return false;
      }
      if (a2.rest.length !== b2.rest.length) {
        return true;
      }
      return a2.rest.every((s2, index) => b2.rest[index] === s2);
    }
    function mergeParents(first, second) {
      if (!first.parent || !second.parent) {
        return false;
      }
      if (first.parent === second.parent) {
        return false;
      }
      second.remove();
      first.parent.append(second);
      return true;
    }
    function partialMerge(first, second) {
      let intersection = intersect(getDecls(first), getDecls(second));
      if (!intersection.length) {
        return second;
      }
      let nextRule = second.next();
      if (!nextRule) {
        const parentSibling = second.parent.next();
        nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];
      }
      if (nextRule && nextRule.type === "rule" && canMerge(second, nextRule)) {
        let nextIntersection = intersect(getDecls(second), getDecls(nextRule));
        if (nextIntersection.length > intersection.length) {
          mergeParents(second, nextRule);
          first = second;
          second = nextRule;
          intersection = nextIntersection;
        }
      }
      const firstDecls = getDecls(first);
      intersection = intersection.filter((decl, intersectIndex) => {
        const indexOfDecl = indexOfDeclaration(firstDecls, decl);
        const nextConflictInFirst = firstDecls.slice(indexOfDecl + 1).filter((d2) => isConflictingProp(d2.prop, decl.prop));
        if (!nextConflictInFirst.length) {
          return true;
        }
        const nextConflictInIntersection = intersection.slice(intersectIndex + 1).filter((d2) => isConflictingProp(d2.prop, decl.prop));
        if (!nextConflictInIntersection.length) {
          return false;
        }
        if (nextConflictInFirst.length !== nextConflictInIntersection.length) {
          return false;
        }
        return nextConflictInFirst.every(
          (d2, index) => declarationIsEqual(d2, nextConflictInIntersection[index])
        );
      });
      const secondDecls = getDecls(second);
      intersection = intersection.filter((decl) => {
        const nextConflictIndex = secondDecls.findIndex(
          (d2) => isConflictingProp(d2.prop, decl.prop)
        );
        if (nextConflictIndex === -1) {
          return false;
        }
        if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {
          return false;
        }
        if (decl.prop.toLowerCase() !== "direction" && decl.prop.toLowerCase() !== "unicode-bidi" && secondDecls.some(
          (declaration) => declaration.prop.toLowerCase() === "all"
        )) {
          return false;
        }
        secondDecls.splice(nextConflictIndex, 1);
        return true;
      });
      if (!intersection.length) {
        return second;
      }
      const receivingBlock = second.clone();
      receivingBlock.selector = joinSelectors(first, second);
      receivingBlock.nodes = [];
      second.parent.insertBefore(second, receivingBlock);
      const firstClone = first.clone();
      const secondClone = second.clone();
      function moveDecl(callback) {
        return (decl) => {
          if (indexOfDeclaration(intersection, decl) !== -1) {
            callback.call(this, decl);
          }
        };
      }
      firstClone.walkDecls(
        moveDecl((decl) => {
          decl.remove();
          receivingBlock.append(decl);
        })
      );
      secondClone.walkDecls(moveDecl((decl) => decl.remove()));
      const merged = ruleLength(firstClone, receivingBlock, secondClone);
      const original = ruleLength(first, second);
      if (merged < original) {
        first.replaceWith(firstClone);
        second.replaceWith(secondClone);
        [firstClone, receivingBlock, secondClone].forEach((r2) => {
          if (!r2.nodes.length) {
            r2.remove();
          }
        });
        if (!secondClone.parent) {
          return receivingBlock;
        }
        return secondClone;
      } else {
        receivingBlock.remove();
        return second;
      }
    }
    function selectorMerger(browsers, compatibilityCache) {
      let cache = null;
      return function(rule) {
        if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {
          cache = rule;
          return;
        }
        if (cache === rule) {
          cache = rule;
          return;
        }
        mergeParents(cache, rule);
        if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {
          rule.selector = joinSelectors(cache, rule);
          cache.remove();
          cache = rule;
          return;
        }
        if (cache.selector === rule.selector) {
          const cached = getDecls(cache);
          rule.walk((node) => {
            if (node.type === "decl" && indexOfDeclaration(cached, node) !== -1) {
              node.remove();
              return;
            }
            cache.append(node);
          });
          rule.remove();
          return;
        }
        cache = partialMerge(cache, rule);
      };
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-merge-rules",
        prepare(result) {
          const resultOpts = result.opts || {};
          const browsers = browserslist(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
          });
          const compatibilityCache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkRules(selectorMerger(browsers, compatibilityCache));
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-discard-empty/src/index.js
var require_src22 = __commonJS({
  "node_modules/postcss-discard-empty/src/index.js"(exports, module) {
    "use strict";
    var plugin = "postcss-discard-empty";
    function discardAndReport(css, result) {
      function discardEmpty(node) {
        const { type } = node;
        const sub = node.nodes;
        if (sub) {
          node.each(discardEmpty);
        }
        if (type === "decl" && !node.value && !node.prop.startsWith("--") || type === "rule" && !node.selector || sub && !sub.length || type === "atrule" && (!sub && !node.params || !node.params && !sub.length)) {
          node.remove();
          result.messages.push({
            type: "removal",
            plugin,
            node
          });
        }
      }
      css.each(discardEmpty);
    }
    function pluginCreator() {
      return {
        postcssPlugin: plugin,
        OnceExit(css, { result }) {
          discardAndReport(css, result);
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-unique-selectors/src/index.js
var require_src23 = __commonJS({
  "node_modules/postcss-unique-selectors/src/index.js"(exports, module) {
    "use strict";
    var selectorParser = require_dist3();
    function parseSelectors(selectors, callback) {
      return selectorParser(callback).processSync(selectors);
    }
    function unique(rule) {
      const selector = [...new Set(rule.selectors)];
      selector.sort();
      return selector.join();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-unique-selectors",
        OnceExit(css) {
          css.walkRules((nodes) => {
            let comments = [];
            const removeAndSaveComments = (selNode) => {
              selNode.walk((sel) => {
                if (sel.type === "comment") {
                  comments.push(sel.value);
                  sel.remove();
                  return;
                } else {
                  return;
                }
              });
            };
            if (nodes.raws.selector && nodes.raws.selector.raw) {
              parseSelectors(nodes.raws.selector.raw, removeAndSaveComments);
              nodes.raws.selector.raw = unique(nodes);
            }
            nodes.selector = parseSelectors(nodes.selector, removeAndSaveComments);
            nodes.selector = unique(nodes);
            nodes.selectors = nodes.selectors.concat(comments);
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-string/src/index.js
var require_src24 = __commonJS({
  "node_modules/postcss-normalize-string/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var WORD_END = /[ \n\t\r\f'"\\]/g;
    var C_STRING = "string";
    var C_ESCAPED_SINGLE_QUOTE = "escapedSingleQuote";
    var C_ESCAPED_DOUBLE_QUOTE = "escapedDoubleQuote";
    var C_SINGLE_QUOTE = "singleQuote";
    var C_DOUBLE_QUOTE = "doubleQuote";
    var C_NEWLINE = "newline";
    var C_SINGLE = "single";
    var L_SINGLE_QUOTE = `'`;
    var L_DOUBLE_QUOTE = `"`;
    var L_NEWLINE = `\\
`;
    var T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\'` };
    var T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\"` };
    var T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };
    var T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };
    var T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };
    function stringify17(ast) {
      return ast.nodes.reduce((str, { value }) => {
        if (value === L_NEWLINE) {
          return str;
        }
        return str + value;
      }, "");
    }
    function parse4(str) {
      let code, next, value;
      let pos = 0;
      let len = str.length;
      const ast = {
        nodes: [],
        types: {
          escapedSingleQuote: 0,
          escapedDoubleQuote: 0,
          singleQuote: 0,
          doubleQuote: 0
        },
        quotes: false
      };
      while (pos < len) {
        code = str.charCodeAt(pos);
        switch (code) {
          case SPACE:
          case TAB:
          case CR:
          case FEED:
            next = pos;
            do {
              next += 1;
              code = str.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            ast.nodes.push({
              type: "space",
              value: str.slice(pos, next)
            });
            pos = next - 1;
            break;
          case SINGLE_QUOTE:
            ast.nodes.push(T_SINGLE_QUOTE);
            ast.types[C_SINGLE_QUOTE]++;
            ast.quotes = true;
            break;
          case DOUBLE_QUOTE:
            ast.nodes.push(T_DOUBLE_QUOTE);
            ast.types[C_DOUBLE_QUOTE]++;
            ast.quotes = true;
            break;
          case BACKSLASH:
            next = pos + 1;
            if (str.charCodeAt(next) === SINGLE_QUOTE) {
              ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);
              ast.types[C_ESCAPED_SINGLE_QUOTE]++;
              ast.quotes = true;
              pos = next;
              break;
            } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {
              ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);
              ast.types[C_ESCAPED_DOUBLE_QUOTE]++;
              ast.quotes = true;
              pos = next;
              break;
            } else if (str.charCodeAt(next) === NEWLINE) {
              ast.nodes.push(T_NEWLINE);
              pos = next;
              break;
            }
          default:
            WORD_END.lastIndex = pos + 1;
            WORD_END.test(str);
            if (WORD_END.lastIndex === 0) {
              next = len - 1;
            } else {
              next = WORD_END.lastIndex - 2;
            }
            value = str.slice(pos, next + 1);
            ast.nodes.push({
              type: C_STRING,
              value
            });
            pos = next;
        }
        pos++;
      }
      return ast;
    }
    function changeWrappingQuotes(node, ast) {
      const { types } = ast;
      if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {
        return;
      }
      if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {
        node.quote = L_DOUBLE_QUOTE;
      }
      if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {
        node.quote = L_SINGLE_QUOTE;
      }
      ast.nodes = changeChildQuotes(ast.nodes, node.quote);
    }
    function changeChildQuotes(childNodes, parentQuote) {
      const updatedChildren = [];
      for (const child of childNodes) {
        if (child.type === C_ESCAPED_DOUBLE_QUOTE && parentQuote === L_SINGLE_QUOTE) {
          updatedChildren.push(T_DOUBLE_QUOTE);
        } else if (child.type === C_ESCAPED_SINGLE_QUOTE && parentQuote === L_DOUBLE_QUOTE) {
          updatedChildren.push(T_SINGLE_QUOTE);
        } else {
          updatedChildren.push(child);
        }
      }
      return updatedChildren;
    }
    function normalize(value, preferredQuote) {
      if (!value || !value.length) {
        return value;
      }
      return valueParser(value).walk((child) => {
        if (child.type !== C_STRING) {
          return;
        }
        const ast = parse4(child.value);
        if (ast.quotes) {
          changeWrappingQuotes(child, ast);
        } else if (preferredQuote === C_SINGLE) {
          child.quote = L_SINGLE_QUOTE;
        } else {
          child.quote = L_DOUBLE_QUOTE;
        }
        child.value = stringify17(ast);
      }).toString();
    }
    function minify(original, cache, preferredQuote) {
      const key = original + "|" + preferredQuote;
      if (cache.has(key)) {
        return cache.get(key);
      }
      const newValue = normalize(original, preferredQuote);
      cache.set(key, newValue);
      return newValue;
    }
    function pluginCreator(opts) {
      const { preferredQuote } = Object.assign(
        {},
        {
          preferredQuote: "double"
        },
        opts
      );
      return {
        postcssPlugin: "postcss-normalize-string",
        OnceExit(css) {
          const cache = /* @__PURE__ */ new Map();
          css.walk((node) => {
            switch (node.type) {
              case "rule":
                node.selector = minify(node.selector, cache, preferredQuote);
                break;
              case "decl":
                node.value = minify(node.value, cache, preferredQuote);
                break;
              case "atrule":
                node.params = minify(node.params, cache, preferredQuote);
                break;
            }
          });
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-positions/src/index.js
var require_src25 = __commonJS({
  "node_modules/postcss-normalize-positions/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var directionKeywords = /* @__PURE__ */ new Set(["top", "right", "bottom", "left", "center"]);
    var center = "50%";
    var horizontal = /* @__PURE__ */ new Map([
      ["right", "100%"],
      ["left", "0"]
    ]);
    var verticalValue = /* @__PURE__ */ new Map([
      ["bottom", "100%"],
      ["top", "0"]
    ]);
    var mathFunctions = /* @__PURE__ */ new Set(["calc", "min", "max", "clamp"]);
    var variableFunctions = /* @__PURE__ */ new Set(["var", "env", "constant"]);
    function isCommaNode(node) {
      return node.type === "div" && node.value === ",";
    }
    function isVariableFunctionNode(node) {
      if (node.type !== "function") {
        return false;
      }
      return variableFunctions.has(node.value.toLowerCase());
    }
    function isMathFunctionNode(node) {
      if (node.type !== "function") {
        return false;
      }
      return mathFunctions.has(node.value.toLowerCase());
    }
    function isNumberNode(node) {
      if (node.type !== "word") {
        return false;
      }
      const value = parseFloat(node.value);
      return !isNaN(value);
    }
    function isDimensionNode(node) {
      if (node.type !== "word") {
        return false;
      }
      const parsed = valueParser.unit(node.value);
      if (!parsed) {
        return false;
      }
      return parsed.unit !== "";
    }
    function transform(value) {
      const parsed = valueParser(value);
      const ranges = [];
      let rangeIndex = 0;
      let shouldContinue = true;
      parsed.nodes.forEach((node, index) => {
        if (isCommaNode(node)) {
          rangeIndex += 1;
          shouldContinue = true;
          return;
        }
        if (!shouldContinue) {
          return;
        }
        if (node.type === "div" && node.value === "/") {
          shouldContinue = false;
          return;
        }
        if (!ranges[rangeIndex]) {
          ranges[rangeIndex] = {
            start: null,
            end: null
          };
        }
        if (isVariableFunctionNode(node)) {
          shouldContinue = false;
          ranges[rangeIndex].start = null;
          ranges[rangeIndex].end = null;
          return;
        }
        const isPositionKeyword = node.type === "word" && directionKeywords.has(node.value.toLowerCase()) || isDimensionNode(node) || isNumberNode(node) || isMathFunctionNode(node);
        if (ranges[rangeIndex].start === null && isPositionKeyword) {
          ranges[rangeIndex].start = index;
          ranges[rangeIndex].end = index;
          return;
        }
        if (ranges[rangeIndex].start !== null) {
          if (node.type === "space") {
            return;
          } else if (isPositionKeyword) {
            ranges[rangeIndex].end = index;
            return;
          }
          return;
        }
      });
      ranges.forEach((range) => {
        if (range.start === null) {
          return;
        }
        const nodes = parsed.nodes.slice(range.start, range.end + 1);
        if (nodes.length > 3) {
          return;
        }
        const firstNode = nodes[0].value.toLowerCase();
        const secondNode = nodes[2] && nodes[2].value ? nodes[2].value.toLowerCase() : null;
        if (nodes.length === 1 || secondNode === "center") {
          if (secondNode) {
            nodes[2].value = nodes[1].value = "";
          }
          const map2 = new Map([...horizontal, ["center", center]]);
          if (map2.has(firstNode)) {
            nodes[0].value = map2.get(firstNode);
          }
          return;
        }
        if (secondNode !== null) {
          if (firstNode === "center" && directionKeywords.has(secondNode)) {
            nodes[0].value = nodes[1].value = "";
            if (horizontal.has(secondNode)) {
              nodes[2].value = horizontal.get(secondNode);
            }
            return;
          }
          if (horizontal.has(firstNode) && verticalValue.has(secondNode)) {
            nodes[0].value = horizontal.get(firstNode);
            nodes[2].value = verticalValue.get(secondNode);
            return;
          } else if (verticalValue.has(firstNode) && horizontal.has(secondNode)) {
            nodes[0].value = horizontal.get(secondNode);
            nodes[2].value = verticalValue.get(firstNode);
            return;
          }
        }
      });
      return parsed.toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-positions",
        OnceExit(css) {
          const cache = /* @__PURE__ */ new Map();
          css.walkDecls(
            /^(background(-position)?|(-\w+-)?perspective-origin)$/i,
            (decl) => {
              const value = decl.value;
              if (!value) {
                return;
              }
              if (cache.has(value)) {
                decl.value = cache.get(value);
                return;
              }
              const result = transform(value);
              decl.value = result;
              cache.set(value, result);
            }
          );
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-whitespace/src/index.js
var require_src26 = __commonJS({
  "node_modules/postcss-normalize-whitespace/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var atrule = "atrule";
    var decl = "decl";
    var rule = "rule";
    var variableFunctions = /* @__PURE__ */ new Set(["var", "env", "constant"]);
    function reduceCalcWhitespaces(node) {
      if (node.type === "space") {
        node.value = " ";
      } else if (node.type === "function") {
        if (!variableFunctions.has(node.value.toLowerCase())) {
          node.before = node.after = "";
        }
      }
    }
    function reduceWhitespaces(node) {
      if (node.type === "space") {
        node.value = " ";
      } else if (node.type === "div") {
        node.before = node.after = "";
      } else if (node.type === "function") {
        if (!variableFunctions.has(node.value.toLowerCase())) {
          node.before = node.after = "";
        }
        if (node.value.toLowerCase() === "calc") {
          valueParser.walk(node.nodes, reduceCalcWhitespaces);
          return false;
        }
      }
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-whitespace",
        OnceExit(css) {
          const cache = /* @__PURE__ */ new Map();
          css.walk((node) => {
            const { type } = node;
            if ([decl, rule, atrule].includes(type) && node.raws.before) {
              node.raws.before = node.raws.before.replace(/\s/g, "");
            }
            if (type === decl) {
              if (node.important) {
                node.raws.important = "!important";
              }
              node.value = node.value.replace(/\s*(\\9)\s*/, "$1");
              const value = node.value;
              if (cache.has(value)) {
                node.value = cache.get(value);
              } else {
                const parsed = valueParser(node.value);
                const result = parsed.walk(reduceWhitespaces).toString();
                node.value = result;
                cache.set(value, result);
              }
              if (node.prop.startsWith("--") && node.value === "") {
                node.value = " ";
              }
              if (node.raws.before) {
                const prev = node.prev();
                if (prev && prev.type !== rule) {
                  node.raws.before = node.raws.before.replace(/;/g, "");
                }
              }
              node.raws.between = ":";
              node.raws.semicolon = false;
            } else if (type === rule || type === atrule) {
              node.raws.between = node.raws.after = "";
              node.raws.semicolon = false;
            }
          });
          css.raws.after = "";
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-unicode/src/index.js
var require_src27 = __commonJS({
  "node_modules/postcss-normalize-unicode/src/index.js"(exports, module) {
    "use strict";
    var browserslist = require_browserslist();
    var valueParser = require_lib();
    var regexLowerCaseUPrefix = /^u(?=\+)/;
    function unicode(range) {
      const values = range.slice(2).split("-");
      if (values.length < 2) {
        return range;
      }
      const left = values[0].split("");
      const right = values[1].split("");
      if (left.length !== right.length) {
        return range;
      }
      const merged = mergeRangeBounds(left, right);
      if (merged) {
        return merged;
      }
      return range;
    }
    function mergeRangeBounds(left, right) {
      let questionCounter = 0;
      let group = "u+";
      for (const [index, value] of left.entries()) {
        if (value === right[index] && questionCounter === 0) {
          group = group + value;
        } else if (value === "0" && right[index] === "f") {
          questionCounter++;
          group = group + "?";
        } else {
          return false;
        }
      }
      if (questionCounter < 6) {
        return group;
      } else {
        return false;
      }
    }
    function hasLowerCaseUPrefixBug(browser) {
      return browserslist("ie <=11, edge <= 15").includes(browser);
    }
    function transform(value, isLegacy = false) {
      return valueParser(value).walk((child) => {
        if (child.type === "unicode-range") {
          const transformed = unicode(child.value.toLowerCase());
          child.value = isLegacy ? transformed.replace(regexLowerCaseUPrefix, "U") : transformed;
        }
        return false;
      }).toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-unicode",
        prepare(result) {
          const cache = /* @__PURE__ */ new Map();
          const resultOpts = result.opts || {};
          const browsers = browserslist(null, {
            stats: resultOpts.stats,
            path: __dirname,
            env: resultOpts.env
          });
          const isLegacy = browsers.some(hasLowerCaseUPrefixBug);
          return {
            OnceExit(css) {
              css.walkDecls(/^unicode-range$/i, (decl) => {
                const value = decl.value;
                if (cache.has(value)) {
                  decl.value = cache.get(value);
                  return;
                }
                const newValue = transform(value, isLegacy);
                decl.value = newValue;
                cache.set(value, newValue);
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-display-values/src/lib/map.js
var require_map2 = __commonJS({
  "node_modules/postcss-normalize-display-values/src/lib/map.js"(exports, module) {
    "use strict";
    var block = "block";
    var flex = "flex";
    var flow = "flow";
    var flowRoot = "flow-root";
    var grid = "grid";
    var inline = "inline";
    var inlineBlock = "inline-block";
    var inlineFlex = "inline-flex";
    var inlineGrid = "inline-grid";
    var inlineTable = "inline-table";
    var listItem = "list-item";
    var ruby = "ruby";
    var rubyBase = "ruby-base";
    var rubyText = "ruby-text";
    var runIn = "run-in";
    var table = "table";
    var tableCell = "table-cell";
    var tableCaption = "table-caption";
    module.exports = /* @__PURE__ */ new Map([
      [[block, flow].toString(), block],
      [[block, flowRoot].toString(), flowRoot],
      [[inline, flow].toString(), inline],
      [[inline, flowRoot].toString(), inlineBlock],
      [[runIn, flow].toString(), runIn],
      [[listItem, block, flow].toString(), listItem],
      [[inline, flow, listItem].toString(), inline + " " + listItem],
      [[block, flex].toString(), flex],
      [[inline, flex].toString(), inlineFlex],
      [[block, grid].toString(), grid],
      [[inline, grid].toString(), inlineGrid],
      [[inline, ruby].toString(), ruby],
      [[block, table].toString(), table],
      [[inline, table].toString(), inlineTable],
      [[tableCell, flow].toString(), tableCell],
      [[tableCaption, flow].toString(), tableCaption],
      [[rubyBase, flow].toString(), rubyBase],
      [[rubyText, flow].toString(), rubyText]
    ]);
  }
});

// node_modules/postcss-normalize-display-values/src/index.js
var require_src28 = __commonJS({
  "node_modules/postcss-normalize-display-values/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var mappings = require_map2();
    function transform(value) {
      const { nodes } = valueParser(value);
      if (nodes.length === 1) {
        return value;
      }
      const values = nodes.filter((list, index) => index % 2 === 0).filter((node) => node.type === "word").map((n2) => n2.value.toLowerCase());
      if (values.length === 0) {
        return value;
      }
      const match = mappings.get(values.toString());
      if (!match) {
        return value;
      }
      return match;
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-display-values",
        prepare() {
          const cache = /* @__PURE__ */ new Map();
          return {
            OnceExit(css) {
              css.walkDecls(/^display$/i, (decl) => {
                const value = decl.value;
                if (!value) {
                  return;
                }
                if (cache.has(value)) {
                  decl.value = cache.get(value);
                  return;
                }
                const result = transform(value);
                decl.value = result;
                cache.set(value, result);
              });
            }
          };
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/postcss-normalize-timing-functions/src/index.js
var require_src29 = __commonJS({
  "node_modules/postcss-normalize-timing-functions/src/index.js"(exports, module) {
    "use strict";
    var valueParser = require_lib();
    var getValue = (node) => parseFloat(node.value);
    var conversions = /* @__PURE__ */ new Map([
      [[0.25, 0.1, 0.25, 1].toString(), "ease"],
      [[0, 0, 1, 1].toString(), "linear"],
      [[0.42, 0, 1, 1].toString(), "ease-in"],
      [[0, 0, 0.58, 1].toString(), "ease-out"],
      [[0.42, 0, 0.58, 1].toString(), "ease-in-out"]
    ]);
    function reduce(node) {
      if (node.type !== "function") {
        return false;
      }
      if (!node.value) {
        return;
      }
      const lowerCasedValue = node.value.toLowerCase();
      if (lowerCasedValue === "steps") {
        if (node.nodes[0].type === "word" && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === "word" && (node.nodes[2].value.toLowerCase() === "start" || node.nodes[2].value.toLowerCase() === "jump-start")) {
          node.type = "word";
          node.value = "step-start";
          delete node.nodes;
          return;
        }
        if (node.nodes[0].type === "word" && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === "word" && (node.nodes[2].value.toLowerCase() === "end" || node.nodes[2].value.toLowerCase() === "jump-end")) {
          node.type = "word";
          node.value = "step-end";
          delete node.nodes;
          return;
        }
        if (node.nodes[2] && node.nodes[2].type === "word" && (node.nodes[2].value.toLowerCase() === "end" || node.nodes[2].value.toLowerCase() === "jump-end")) {
          node.nodes = [node.nodes[0]];
          return;
        }
        return false;
      }
      if (lowerCasedValue === "cubic-bezier") {
        const values = node.nodes.filter((list, index) => {
          return index % 2 === 0;
        }).map(getValue);
        if (values.length !== 4) {
          return;
        }
        const match = conversions.get(values.toString());
        if (match) {
          node.type = "word";
          node.value = match;
          delete node.nodes;
          return;
        }
      }
    }
    function transform(value) {
      return valueParser(value).walk(reduce).toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-normalize-timing-functions",
        OnceExit(css) {
          const cache = /* @__PURE__ */ new Map();
          css.walkDecls(
            /^(-\w+-)?(animation|transition)(-timing-function)?$/i,
            (decl) => {
              const value = decl.value;
              if (cache.has(value)) {
                decl.value = cache.get(value);
                return;
              }
              const result = transform(value);
              decl.value = result;
              cache.set(value, result);
            }
          );
        }
      };
    }
    pluginCreator.postcss = true;
    module.exports = pluginCreator;
  }
});

// node_modules/cssnano-preset-default/src/index.js
var require_src30 = __commonJS({
  "node_modules/cssnano-preset-default/src/index.js"(exports, module) {
    "use strict";
    var cssDeclarationSorter2 = (init_main(), __toCommonJS(main_exports));
    var postcssDiscardComments = require_src();
    var postcssReduceInitial = require_src2();
    var postcssMinifyGradients = require_src4();
    var postcssSvgo = require_src5();
    var postcssReduceTransforms = require_src6();
    var postcssConvertValues = require_src7();
    var postcssCalc = require_src8();
    var postcssColormin = require_src9();
    var postcssOrderedValues = require_src10();
    var postcssMinifySelectors = require_src11();
    var postcssMinifyParams = require_src12();
    var postcssNormalizeCharset = require_src13();
    var postcssMinifyFontValues = require_src14();
    var postcssNormalizeUrl = require_src15();
    var postcssMergeLonghand = require_src17();
    var postcssDiscardDuplicates = require_src18();
    var postcssDiscardOverridden = require_src19();
    var postcssNormalizeRepeatStyle = require_src20();
    var postcssMergeRules = require_src21();
    var postcssDiscardEmpty = require_src22();
    var postcssUniqueSelectors = require_src23();
    var postcssNormalizeString = require_src24();
    var postcssNormalizePositions = require_src25();
    var postcssNormalizeWhitespace = require_src26();
    var postcssNormalizeUnicode = require_src27();
    var postcssNormalizeDisplayValues = require_src28();
    var postcssNormalizeTimingFunctions = require_src29();
    var { rawCache } = require_src3();
    var defaultOpts = {
      convertValues: {
        length: false
      },
      normalizeCharset: {
        add: false
      },
      cssDeclarationSorter: {
        keepOverrides: true
      }
    };
    function defaultPreset(opts = {}) {
      const options = Object.assign({}, defaultOpts, opts);
      const plugins = [
        [postcssDiscardComments, options.discardComments],
        [postcssMinifyGradients, options.minifyGradients],
        [postcssReduceInitial, options.reduceInitial],
        [postcssSvgo, options.svgo],
        [postcssNormalizeDisplayValues, options.normalizeDisplayValues],
        [postcssReduceTransforms, options.reduceTransforms],
        [postcssColormin, options.colormin],
        [postcssNormalizeTimingFunctions, options.normalizeTimingFunctions],
        [postcssCalc, options.calc],
        [postcssConvertValues, options.convertValues],
        [postcssOrderedValues, options.orderedValues],
        [postcssMinifySelectors, options.minifySelectors],
        [postcssMinifyParams, options.minifyParams],
        [postcssNormalizeCharset, options.normalizeCharset],
        [postcssDiscardOverridden, options.discardOverridden],
        [postcssNormalizeString, options.normalizeString],
        [postcssNormalizeUnicode, options.normalizeUnicode],
        [postcssMinifyFontValues, options.minifyFontValues],
        [postcssNormalizeUrl, options.normalizeUrl],
        [postcssNormalizeRepeatStyle, options.normalizeRepeatStyle],
        [postcssNormalizePositions, options.normalizePositions],
        [postcssNormalizeWhitespace, options.normalizeWhitespace],
        [postcssMergeLonghand, options.mergeLonghand],
        [postcssDiscardDuplicates, options.discardDuplicates],
        [postcssMergeRules, options.mergeRules],
        [postcssDiscardEmpty, options.discardEmpty],
        [postcssUniqueSelectors, options.uniqueSelectors],
        [cssDeclarationSorter2, options.cssDeclarationSorter],
        [rawCache, options.rawCache]
      ];
      return { plugins };
    }
    module.exports = defaultPreset;
  }
});

// node_modules/cssnano/src/index.js
var require_src31 = __commonJS({
  "node_modules/cssnano/src/index.js"(exports, module) {
    "use strict";
    var path = require_path();
    var postcss = require_postcss();
    var yaml = require_browser();
    var { lilconfigSync } = require_dist();
    var cssnano = "cssnano";
    function isResolvable(moduleId) {
      try {
        __require.resolve(moduleId);
        return true;
      } catch (e2) {
        return false;
      }
    }
    function resolvePreset(preset) {
      let fn, options;
      if (Array.isArray(preset)) {
        fn = preset[0];
        options = preset[1];
      } else {
        fn = preset;
        options = {};
      }
      if (preset.plugins) {
        return preset.plugins;
      }
      if (fn === "default") {
        return require_src30()(options).plugins;
      }
      if (typeof fn === "function") {
        return fn(options).plugins;
      }
      if (isResolvable(fn)) {
        return __require(fn)(options).plugins;
      }
      const sugar = `cssnano-preset-${fn}`;
      if (isResolvable(sugar)) {
        return __require(sugar)(options).plugins;
      }
      throw new Error(
        `Cannot load preset "${fn}". Please check your configuration for errors and try again.`
      );
    }
    function resolveConfig(options) {
      if (options.preset) {
        return resolvePreset(options.preset);
      }
      let searchPath = process.cwd();
      let configPath = void 0;
      if (options.configFile) {
        searchPath = void 0;
        configPath = path.resolve(process.cwd(), options.configFile);
      }
      const configExplorer = lilconfigSync(cssnano, {
        searchPlaces: [
          "package.json",
          ".cssnanorc",
          ".cssnanorc.json",
          ".cssnanorc.yaml",
          ".cssnanorc.yml",
          ".cssnanorc.js",
          "cssnano.config.js"
        ],
        loaders: {
          ".yaml": (filepath, content) => yaml.parse(content),
          ".yml": (filepath, content) => yaml.parse(content)
        }
      });
      const config = configPath ? configExplorer.load(configPath) : configExplorer.search(searchPath);
      if (config === null) {
        return resolvePreset("default");
      }
      return resolvePreset(config.config.preset || config.config);
    }
    function cssnanoPlugin(options = {}) {
      if (Array.isArray(options.plugins)) {
        if (!options.preset || !options.preset.plugins) {
          options.preset = { plugins: [] };
        }
        options.plugins.forEach((plugin) => {
          if (Array.isArray(plugin)) {
            const [pluginDef, opts = {}] = plugin;
            if (typeof pluginDef === "string" && isResolvable(pluginDef)) {
              options.preset.plugins.push([__require(pluginDef), opts]);
            } else {
              options.preset.plugins.push([pluginDef, opts]);
            }
          } else if (typeof plugin === "string" && isResolvable(plugin)) {
            options.preset.plugins.push([__require(plugin), {}]);
          } else {
            options.preset.plugins.push([plugin, {}]);
          }
        });
      }
      const plugins = [];
      const nanoPlugins = resolveConfig(options);
      for (const nanoPlugin of nanoPlugins) {
        if (Array.isArray(nanoPlugin)) {
          const [processor, opts] = nanoPlugin;
          if (typeof opts === "undefined" || typeof opts === "object" && !opts.exclude || typeof opts === "boolean" && opts === true) {
            plugins.push(processor(opts));
          }
        } else {
          plugins.push(nanoPlugin);
        }
      }
      return postcss(plugins);
    }
    cssnanoPlugin.postcss = true;
    module.exports = cssnanoPlugin;
  }
});

export {
  require_browser,
  require_os,
  require_dist,
  require_base64_vlq,
  require_util,
  require_array_set,
  require_source_map_generator,
  require_dist3 as require_dist2,
  require_src31 as require_src
};
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/**
 * @author Ben Briggs
 * @license MIT
 * @module cssnano:preset:default
 * @overview
 *
 * This default preset for cssnano only includes transforms that make no
 * assumptions about your CSS other than what is passed in. In previous
 * iterations of cssnano, assumptions were made about your CSS which caused
 * output to look different in certain use cases, but not others. These
 * transforms have been moved from the defaults to other presets, to make
 * this preset require only minimal configuration.
 */
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//! © 2018 Angry Bytes and contributors. MIT licensed.
//# sourceMappingURL=chunk-G5DYNEYO.js.map
